import logging
import os
import json
import random
import urllib.parse
from datetime import datetime, timedelta, timezone

import psycopg2
from psycopg2 import sql

from aiogram import Bot, Dispatcher
from aiogram.types import WebAppInfo, InlineKeyboardMarkup, InlineKeyboardButton, Message
from aiogram.filters import CommandStart, Command
from aiogram.webhook.aiohttp_server import SimpleRequestHandler

from aiohttp.web import Application, json_response, Request
import aiohttp_cors

# --- –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ª–æ–≥—É–≤–∞–Ω–Ω—è ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- –ó–º—ñ–Ω–Ω—ñ —Å–µ—Ä–µ–¥–æ–≤–∏—â–∞ ---
API_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
WEB_APP_URL = os.getenv('WEB_APP_FRONTEND_URL', 'https://placeholder.com')
WEBHOOK_HOST = os.getenv('WEBHOOK_HOST')

WEBHOOK_PATH = f'/webhook/{API_TOKEN}'
WEBHOOK_URL = f"{WEBHOOK_HOST}{WEBHOOK_PATH}"

ADMIN_ID_STR = os.getenv('ADMIN_ID')
ADMIN_ID = None
try:
    if ADMIN_ID_STR:
        ADMIN_ID = int(ADMIN_ID_STR)
except ValueError:
    logger.error(f"Invalid ADMIN_ID provided: '{ADMIN_ID_STR}'. It must be an integer.")

# --- –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –±–∞–∑–∏ –¥–∞–Ω–∏—Ö PostgreSQL ---
DATABASE_URL = os.getenv('DATABASE_URL')

bot = Bot(token=API_TOKEN)
dp = Dispatcher()

# --- –ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è –≥—Ä–∏ (–∑–±—ñ–≥–∞—î—Ç—å—Å—è –∑ JS —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–æ–º) ---
SYMBOLS = ['üçí', 'üçã', 'üçä', 'üçá', 'üîî', 'üíé', 'üçÄ']
WILD_SYMBOL = '‚≠ê'
SCATTER_SYMBOL = 'üí∞'
ALL_REEL_SYMBOLS = SYMBOLS + [WILD_SYMBOL, SCATTER_SYMBOL]

BET_AMOUNT = 100
FREE_COINS_AMOUNT = 500 # –ö—ñ–ª—å–∫—ñ—Å—Ç—å —Ñ–∞–Ω—Ç–∏–∫—ñ–≤ –¥–ª—è /get_coins
COOLDOWN_HOURS = 24 # –ó–∞—Ç—Ä–∏–º–∫–∞ –≤ –≥–æ–¥–∏–Ω–∞—Ö –¥–ª—è /get_coins

DAILY_BONUS_AMOUNT = 300 # –©–æ–¥–µ–Ω–Ω–∏–π –±–æ–Ω—É—Å —á–µ—Ä–µ–∑ Web App
DAILY_BONUS_COOLDOWN_HOURS = 24

QUICK_BONUS_AMOUNT = 100 # –®–≤–∏–¥–∫–∏–π –±–æ–Ω—É—Å —á–µ—Ä–µ–∑ Web App
QUICK_BONUS_COOLDOWN_MINUTES = 15

# XP —Ç–∞ –†—ñ–≤–Ω—ñ
XP_PER_SPIN = 10
XP_PER_WIN_MULTIPLIER = 2 
LEVEL_THRESHOLDS = [
    0,    # Level 1: 0 XP
    100,  # Level 2: 100 XP
    300,  # Level 3: 300 XP
    600,  # Level 4: 600 XP
    1000, # Level 5: 1000 XP
    1500, # Level 6: 1500 XP
    2200, # Level 7: 2200 XP
    3000, # Level 8: 3000 XP
    4000, # Level 9: 4000 XP
    5500, # Level 10: 5500 XP
    7500, # Level 11: 7500 XP
    10000 # Level 12: 10000 XP (and beyond)
]

def get_level_from_xp(xp):
    """–í–∏–∑–Ω–∞—á–∞—î —Ä—ñ–≤–µ–Ω—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –¥–æ—Å–≤—ñ–¥—É."""
    for i, threshold in enumerate(LEVEL_THRESHOLDS):
        if xp < threshold:
            return i + 1 # –†—ñ–≤–Ω—ñ –ø–æ—á–∏–Ω–∞—é—Ç—å—Å—è –∑ 1, —ñ–Ω–¥–µ–∫—Å–∏ –∑ 0
    return len(LEVEL_THRESHOLDS) # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∏–π —Ä—ñ–≤–µ–Ω—å, —è–∫—â–æ XP –ø–µ—Ä–µ–≤–∏—â—É—î –≤—Å—ñ –ø–æ—Ä–æ–≥–∏

def get_xp_for_next_level(level):
    """–ü–æ–≤–µ—Ä—Ç–∞—î XP, –Ω–µ–æ–±—Ö—ñ–¥–Ω–∏–π –¥–ª—è –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ —Ä—ñ–≤–Ω—è (–∞–±–æ –¥–ª—è –ø–æ—Ç–æ—á–Ω–æ–≥–æ, —è–∫—â–æ —Ü–µ –æ—Å—Ç–∞–Ω–Ω—ñ–π)."""
    if level < len(LEVEL_THRESHOLDS):
        return LEVEL_THRESHOLDS[level] # –ü–æ—Ä–æ–≥ –¥–ª—è –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ —Ä—ñ–≤–Ω—è
    return LEVEL_THRESHOLDS[-1] # –Ø–∫—â–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∏–π —Ä—ñ–≤–µ–Ω—å, –ø–æ–≤–µ—Ä—Ç–∞—î –æ—Å—Ç–∞–Ω–Ω—ñ–π –ø–æ—Ä—ñ–≥

PAYOUTS = {
    # –¢—Ä–∏ –æ–¥–Ω–∞–∫–æ–≤—ñ (–≤–∫–ª—é—á–∞—é—á–∏ Wild, —â–æ –¥—ñ—î —è–∫ –∑–∞–º—ñ–Ω–Ω–∏–∫)
    ('üçí', 'üçí', 'üçí'): 1000,
    ('üçã', 'üçã', 'üçã'): 800,
    ('üçä', 'üçä', 'üçä'): 600,
    ('üçá', 'üçá', 'üçá'): 400,
    ('üîî', 'üîî', 'üîî'): 300,
    ('üíé', 'üíé', 'üíé'): 200,
    ('üçÄ', 'üçÄ', 'üçÄ'): 150,
    ('‚≠ê', '‚≠ê', '‚≠ê'): 2000, # –í–∏—Å–æ–∫–∏–π –≤–∏–≥—Ä–∞—à –∑–∞ —Ç—Ä–∏ Wild
    
    # –î–≤—ñ –æ–¥–Ω–∞–∫–æ–≤—ñ (–≤–∫–ª—é—á–∞—é—á–∏ Wild) - WILD –º–æ–∂–µ –±—É—Ç–∏ –¥—Ä—É–≥–∏–º –∞–±–æ —Ç—Ä–µ—Ç—ñ–º
    ('üçí', 'üçí'): 100,
    ('üçã', 'üçã'): 80,

    # Scatter –≤–∏–≥—Ä–∞—à—ñ (–Ω–µ –∑–∞–ª–µ–∂–∞—Ç—å –≤—ñ–¥ –ø–æ–∑–∏—Ü—ñ—ó)
    ('üí∞', 'üí∞'): 200, # –ó–∞ 2 Scatter
    ('üí∞', 'üí∞', 'üí∞'): 500, # –ó–∞ 3 Scatter
}

# --- –§—É–Ω–∫—Ü—ñ—ó –¥–ª—è —Ä–æ–±–æ—Ç–∏ –∑ –±–∞–∑–æ—é –¥–∞–Ω–∏—Ö ---

def get_db_connection():
    """–°—Ç–≤–æ—Ä—é—î —Ç–∞ –ø–æ–≤–µ—Ä—Ç–∞—î –∑'—î–¥–Ω–∞–Ω–Ω—è –¥–æ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö PostgreSQL –∑–∞ URL."""
    conn = None
    try:
        url = urllib.parse.urlparse(DATABASE_URL)
        conn = psycopg2.connect(
            database=url.path[1:],
            user=url.username,
            password=url.password,
            host=url.hostname,
            port=url.port,
            sslmode='require',
            keepalives=1, 
            keepalives_idle=30,
            keepalives_interval=10,
            keepalives_count=5
        )
        return conn
    except psycopg2.Error as err:
        logger.error(f"DB connection error: {err}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error during DB connection: {e}")
        raise

def init_db():
    """–Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î —Ç–∞–±–ª–∏—Ü—ñ —Ç–∞ –≤–∏–∫–æ–Ω—É—î –º—ñ–≥—Ä–∞—Ü—ñ—ó –¥–ª—è –±–∞–∑–∏ –¥–∞–Ω–∏—Ö PostgreSQL."""
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                user_id BIGINT PRIMARY KEY,
                username TEXT DEFAULT 'Unnamed Player', -- –î–æ–¥–∞–Ω–æ username
                balance INTEGER DEFAULT 1000,
                xp INTEGER DEFAULT 0,
                level INTEGER DEFAULT 1,
                last_free_coins_claim TIMESTAMP WITH TIME ZONE DEFAULT NULL,
                last_daily_bonus_claim TIMESTAMP WITH TIME ZONE DEFAULT NULL,
                last_quick_bonus_claim TIMESTAMP WITH TIME ZONE DEFAULT NULL
            )
        ''')
        conn.commit()
        logger.info("Table 'users' initialized or already exists.")

        # –ú—ñ–≥—Ä–∞—Ü—ñ—ó –¥–ª—è –¥–æ–¥–∞–≤–∞–Ω–Ω—è —Å—Ç–æ–≤–ø—Ü—ñ–≤, —è–∫—â–æ –≤–æ–Ω–∏ –Ω–µ —ñ—Å–Ω—É—é—Ç—å
        migrations_to_add = [
            "ALTER TABLE users ADD COLUMN IF NOT EXISTS username TEXT DEFAULT 'Unnamed Player';",
            "ALTER TABLE users ADD COLUMN IF NOT EXISTS xp INTEGER DEFAULT 0;",
            "ALTER TABLE users ADD COLUMN IF NOT EXISTS level INTEGER DEFAULT 1;",
            "ALTER TABLE users ADD COLUMN IF NOT EXISTS last_free_coins_claim TIMESTAMP WITH TIME ZONE DEFAULT NULL;",
            "ALTER TABLE users ADD COLUMN IF NOT EXISTS last_daily_bonus_claim TIMESTAMP WITH TIME ZONE DEFAULT NULL;",
            "ALTER TABLE users ADD COLUMN IF NOT EXISTS last_quick_bonus_claim TIMESTAMP WITH TIME ZONE DEFAULT NULL;"
        ]

        for mig_sql in migrations_to_add:
            try:
                cursor.execute(mig_sql)
                conn.commit()
                logger.info(f"Migration applied: {mig_sql.strip()}")
            except psycopg2.ProgrammingError as e:
                logger.warning(f"Migration failed (might already exist or specific DB error): {e} -> {mig_sql}")
                conn.rollback()

        logger.info("DB schema migration checked.")

    except Exception as e:
        logger.error(f"DB init/migration error: {e}")
    finally:
        if conn:
            conn.close()

def get_user_data(user_id):
    """–û—Ç—Ä–∏–º—É—î –≤—Å—ñ –¥–∞–Ω—ñ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –∑ –ë–î. –°—Ç–≤–æ—Ä—é—î, —è–∫—â–æ –Ω–µ —ñ—Å–Ω—É—î."""
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute(
            'SELECT username, balance, xp, level, last_free_coins_claim, last_daily_bonus_claim, last_quick_bonus_claim FROM users WHERE user_id = %s', 
            (user_id,)
        )
        result = cursor.fetchone()
        if result:
            # –ü–µ—Ä–µ—Ç–≤–æ—Ä—é—î–º–æ naive datetime –æ–±'—î–∫—Ç–∏ –Ω–∞ aware (UTC)
            last_free_coins_claim_db = result[4]
            if last_free_coins_claim_db and last_free_coins_claim_db.tzinfo is None:
                last_free_coins_claim_db = last_free_coins_claim_db.replace(tzinfo=timezone.utc)
            
            last_daily_bonus_claim_db = result[5]
            if last_daily_bonus_claim_db and last_daily_bonus_claim_db.tzinfo is None:
                last_daily_bonus_claim_db = last_daily_bonus_claim_db.replace(tzinfo=timezone.utc)

            last_quick_bonus_claim_db = result[6]
            if last_quick_bonus_claim_db and last_quick_bonus_claim_db.tzinfo is None:
                last_quick_bonus_claim_db = last_quick_bonus_claim_db.replace(tzinfo=timezone.utc)

            return {
                'username': result[0],
                'balance': result[1],
                'xp': result[2],
                'level': result[3],
                'last_free_coins_claim': last_free_coins_claim_db,
                'last_daily_bonus_claim': last_daily_bonus_claim_db,
                'last_quick_bonus_claim': last_quick_bonus_claim_db
            }
        else:
            # –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –Ω–æ–≤–æ–≥–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –∑ –¥–µ—Ñ–æ–ª—Ç–Ω–∏–º–∏ –∑–Ω–∞—á–µ–Ω–Ω—è–º–∏
            # –Ø–∫—â–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –∑–∞–ø—É—Å—Ç–∏–≤ –±–æ—Ç–∞ –≤–ø–µ—Ä—à–µ, username –º–æ–∂–µ –±—É—Ç–∏ –≤–∑—è—Ç–∏–π –∑ Telegram.WebApp.initDataUnsafe.user.username
            # –ê–ª–µ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç–∏ —Ç—É—Ç –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –¥–µ—Ñ–æ–ª—Ç. –§—Ä–æ–Ω—Ç–µ–Ω–¥ –º–æ–∂–µ –ø–µ—Ä–µ–¥–∞—Ç–∏ username –ø—Ä–∏ –ø–µ—Ä—à–æ–º—É –∑–≤–µ—Ä–Ω–µ–Ω–Ω—ñ.
            cursor.execute(
                'INSERT INTO users (user_id, username, balance, xp, level, last_free_coins_claim, last_daily_bonus_claim, last_quick_bonus_claim) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)', 
                (user_id, 'Unnamed Player', 1000, 0, 1, None, None, None)
            )
            conn.commit()
            return {
                'username': 'Unnamed Player',
                'balance': 1000,
                'xp': 0,
                'level': 1,
                'last_free_coins_claim': None,
                'last_daily_bonus_claim': None,
                'last_quick_bonus_claim': None
            }
    except Exception as e:
        logger.error(f"Error getting user data from PostgreSQL for {user_id}: {e}")
        return {
            'username': 'Error Player', 'balance': 0, 'xp': 0, 'level': 1, 
            'last_free_coins_claim': None, 'last_daily_bonus_claim': None, 'last_quick_bonus_claim': None
        }
    finally:
        if conn:
            conn.close()

def update_user_data(user_id, **kwargs):
    """–û–Ω–æ–≤–ª—é—î –¥–∞–Ω—ñ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –≤ –±–∞–∑—ñ –¥–∞–Ω–∏—Ö PostgreSQL. –ü—Ä–∏–π–º–∞—î –∫–ª—é—á–æ–≤—ñ –∞—Ä–≥—É–º–µ–Ω—Ç–∏ –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è."""
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        current_data_from_db = get_user_data(user_id) 

        update_fields_parts = []
        update_values = []

        # –ó–∞–ø–æ–≤–Ω—é—î–º–æ –∑–Ω–∞—á–µ–Ω–Ω—è –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è
        fields_to_update = {
            'username': kwargs.get('username', current_data_from_db['username']), # –î–æ–¥–∞–Ω–æ username
            'balance': kwargs.get('balance', current_data_from_db['balance']),
            'xp': kwargs.get('xp', current_data_from_db['xp']),
            'level': kwargs.get('level', current_data_from_db['level']),
            'last_free_coins_claim': kwargs.get('last_free_coins_claim', current_data_from_db['last_free_coins_claim']),
            'last_daily_bonus_claim': kwargs.get('last_daily_bonus_claim', current_data_from_db['last_daily_bonus_claim']),
            'last_quick_bonus_claim': kwargs.get('last_quick_bonus_claim', current_data_from_db['last_quick_bonus_claim'])
        }

        for field, value in fields_to_update.items():
            update_fields_parts.append(sql.SQL("{} = %s").format(sql.Identifier(field)))
            update_values.append(value)
        
        if not update_fields_parts:
            logger.info(f"No fields specified for update for user {user_id}.")
            return

        update_query = sql.SQL('''
            UPDATE users SET {fields} WHERE user_id = %s
        ''').format(fields=sql.SQL(', ').join(update_fields_parts))

        update_values.append(user_id)

        cursor.execute(update_query, update_values)
        conn.commit()
        logger.info(f"User {user_id} data updated.")
    except Exception as e:
        logger.error(f"Error updating user data in PostgreSQL for {user_id}: {e}")
    finally:
        if conn:
            conn.close()


def check_win_conditions(symbols):
    """–ü–µ—Ä–µ–≤—ñ—Ä—è—î –≤–∏–≥—Ä–∞—à–Ω—ñ –∫–æ–º–±—ñ–Ω–∞—Ü—ñ—ó, –≤—Ä–∞—Ö–æ–≤—É—é—á–∏ Wild —Ç–∞ Scatter."""
    winnings = 0
    s1, s2, s3 = symbols

    # --- –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ Scatter –≤–∏–≥—Ä–∞—à—ñ–≤ (–ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç –Ω–∞–¥ —ñ–Ω—à–∏–º–∏) ---
    scatter_count = symbols.count(SCATTER_SYMBOL)
    if scatter_count >= 2:
        return PAYOUTS.get(tuple([SCATTER_SYMBOL] * scatter_count), 0)

    # --- –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≤–∏–≥—Ä–∞—à—ñ–≤ –¥–ª—è 3 –æ–¥–Ω–∞–∫–æ–≤–∏—Ö —Å–∏–º–≤–æ–ª—ñ–≤ (–∑ Wild) ---
    if s1 == WILD_SYMBOL and s2 == WILD_SYMBOL and s3 == WILD_SYMBOL:
        return PAYOUTS.get(('‚≠ê', '‚≠ê', '‚≠ê'), 0)

    for main_symbol in SYMBOLS:
        current_match_count = 0
        if s1 == main_symbol or s1 == WILD_SYMBOL: current_match_count += 1
        if s2 == main_symbol or s2 == WILD_SYMBOL: current_match_count += 1
        if s3 == main_symbol or s3 == WILD_SYMBOL: current_match_count += 1

        if current_match_count == 3:
            return PAYOUTS.get((main_symbol, main_symbol, main_symbol), 0)

    # --- –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≤–∏–≥—Ä–∞—à—ñ–≤ –¥–ª—è 2 –æ–¥–Ω–∞–∫–æ–≤–∏—Ö —Å–∏–º–≤–æ–ª—ñ–≤ (–∑ Wild) ---
    for main_symbol in SYMBOLS:
        # s1, s2 - s3 –Ω–µ match
        if ((s1 == main_symbol or s1 == WILD_SYMBOL) and 
            (s2 == main_symbol or s2 == WILD_SYMBOL) and
            (s3 != main_symbol and s3 != WILD_SYMBOL and s3 != SCATTER_SYMBOL)):
            return PAYOUTS.get((main_symbol, main_symbol), 0)
        
        # s1, s3 - s2 –Ω–µ match
        if ((s1 == main_symbol or s1 == WILD_SYMBOL) and 
            (s3 == main_symbol or s3 == WILD_SYMBOL) and
            (s2 != main_symbol and s2 != WILD_SYMBOL and s2 != SCATTER_SYMBOL)):
            return PAYOUTS.get((main_symbol, main_symbol), 0)
        
        # s2, s3 - s1 –Ω–µ match
        if ((s2 == main_symbol or s2 == WILD_SYMBOL) and 
            (s3 == main_symbol or s3 == WILD_SYMBOL) and
            (s1 != main_symbol and s1 != WILD_SYMBOL and s1 != SCATTER_SYMBOL)):
            return PAYOUTS.get((main_symbol, main_symbol), 0)
            
    return winnings

def spin_slot(user_id):
    user_data = get_user_data(user_id)
    current_balance = user_data['balance']
    current_xp = user_data['xp']

    if current_balance < BET_AMOUNT:
        logger.info(f"User {user_id} tried to spin with insufficient balance: {current_balance}.")
        return {'error': '–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –∫–æ—à—Ç—ñ–≤ –¥–ª—è —Å–ø—ñ–Ω–∞!'}, current_balance

    result_symbols = [random.choice(ALL_REEL_SYMBOLS) for _ in range(3)]
    winnings = check_win_conditions(result_symbols)

    new_balance = current_balance - BET_AMOUNT + winnings
    xp_gained = XP_PER_SPIN
    if winnings > 0:
        xp_gained += (XP_PER_SPIN * XP_PER_WIN_MULTIPLIER)
        logger.info(f"User {user_id} won {winnings}. Symbols: {result_symbols}")
    else:
        logger.info(f"User {user_id} lost on spin. Symbols: {result_symbols}")
    
    new_xp = current_xp + xp_gained
    new_level = get_level_from_xp(new_xp)

    update_user_data(user_id, balance=new_balance, xp=new_xp, level=new_level)

    final_user_data = get_user_data(user_id)
    
    return {
        'symbols': result_symbols,
        'winnings': winnings,
        'new_balance': final_user_data['balance'],
        'xp': final_user_data['xp'],
        'level': final_user_data['level'],
        'next_level_xp': get_xp_for_next_level(final_user_data['level'])
    }, final_user_data['balance']


# --- –û–±—Ä–æ–±–Ω–∏–∫–∏ Telegram-–±–æ—Ç–∞ (aiogram v3 —Å–∏–Ω—Ç–∞–∫—Å–∏—Å) ---

@dp.message(CommandStart())
async def send_welcome(message: Message):
    user_id = message.from_user.id
    # –û–Ω–æ–≤–ª—é—î–º–æ username, —è–∫—â–æ –≤—ñ–Ω –¥–æ—Å—Ç—É–ø–Ω–∏–π —á–µ—Ä–µ–∑ initDataUnsafe (–∑ telegram-web-app.js)
    # –¶–µ –ø—Ä–∏–ø—É—Å–∫–∞—î, —â–æ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥ –ø–µ—Ä–µ–¥–∞–≤ username –ø—Ä–∏ –∑–∞–ø–∏—Ç—ñ /api/get_balance –∞–±–æ —ñ–Ω—à–æ–º—É.
    # –î–ª—è –∫–æ–º–∞–Ω–¥–∏ /start, username –±–µ—Ä–µ—Ç—å—Å—è –∑ message.from_user.
    user_data = get_user_data(user_id) # –¶–µ —Å—Ç–≤–æ—Ä–∏—Ç—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞, —è–∫—â–æ –π–æ–≥–æ –Ω–µ–º–∞—î
    if message.from_user.username and user_data['username'] == 'Unnamed Player':
        update_user_data(user_id, username=message.from_user.username)

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üé∞ –í—ñ–¥–∫—Ä–∏—Ç–∏ –°–ª–æ—Ç-–ö–∞–∑–∏–Ω–æ üé∞", web_app=WebAppInfo(url=WEB_APP_URL))]
    ])

    await message.reply(
        f"–ü—Ä–∏–≤—ñ—Ç, {message.from_user.first_name}!\n"
        f"–õ–∞—Å–∫–∞–≤–æ –ø—Ä–æ—Å–∏–º–æ –¥–æ –≤—ñ—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –°–ª–æ—Ç-–ö–∞–∑–∏–Ω–æ!\n"
        f"–í–∞—à –ø–æ—Ç–æ—á–Ω–∏–π –±–∞–ª–∞–Ω—Å: {user_data['balance']} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤.\n"
        f"–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –∫–Ω–æ–ø–∫—É –Ω–∏–∂—á–µ, —â–æ–± –ø–æ—á–∞—Ç–∏ –≥—Ä–∞—Ç–∏!",
        reply_markup=keyboard
    )

@dp.message(Command("add_balance"))
async def add_balance_command(message: Message):
    user_id = message.from_user.id
    
    if ADMIN_ID is None or user_id != ADMIN_ID:
        await message.reply("–£ –≤–∞—Å –Ω–µ–º–∞—î –¥–æ–∑–≤–æ–ª—É –Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è —Ü—ñ—î—ó –∫–æ–º–∞–Ω–¥–∏.")
        logger.warning(f"User {user_id} tried to use /add_balance without admin privileges.")
        return

    args = message.text.split()
    if len(args) != 2:
        await message.reply("–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–∫–∞–∂—ñ—Ç—å —Å—É–º—É –¥–ª—è –¥–æ–¥–∞–≤–∞–Ω–Ω—è. –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è: `/add_balance <—Å—É–º–∞>`")
        return

    try:
        amount = int(args[1])
        if amount <= 0:
            await message.reply("–°—É–º–∞ –º–∞—î –±—É—Ç–∏ –ø–æ–∑–∏—Ç–∏–≤–Ω–∏–º —á–∏—Å–ª–æ–º.")
            return
    except ValueError:
        await message.reply("–ù–µ–≤—ñ—Ä–Ω–∞ —Å—É–º–∞. –ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å —á–∏—Å–ª–æ.")
        return

    current_user_data = get_user_data(user_id)
    new_balance = current_user_data['balance'] + amount
    update_user_data(user_id, balance=new_balance)
    updated_user_data = get_user_data(user_id)

    await message.reply(f"üéâ {amount} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤ —É—Å–ø—ñ—à–Ω–æ –¥–æ–¥–∞–Ω–æ! –í–∞—à –Ω–æ–≤–∏–π –±–∞–ª–∞–Ω—Å: {updated_user_data['balance']} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤. üéâ")
    logger.info(f"Admin {user_id} added {amount} to their balance. New balance: {updated_user_data['balance']}.")


@dp.message(Command("get_coins"))
async def get_free_coins_command(message: Message):
    user_id = message.from_user.id
    user_data = get_user_data(user_id)
    last_claim_time = user_data['last_free_coins_claim']

    current_time = datetime.now(timezone.utc)

    cooldown_duration = timedelta(hours=COOLDOWN_HOURS)

    if last_claim_time and (current_time - last_claim_time) < cooldown_duration:
        time_left = cooldown_duration - (current_time - last_claim_time)
        hours = int(time_left.total_seconds() // 3600)
        minutes = int((time_left.total_seconds() % 3600) // 60)
        await message.reply(
            f"üí∞ –í–∏ –≤–∂–µ –æ—Ç—Ä–∏–º—É–≤–∞–ª–∏ —Ñ–∞–Ω—Ç–∏–∫–∏ –Ω–µ—â–æ–¥–∞–≤–Ω–æ. –°–ø—Ä–æ–±—É–π—Ç–µ –∑–Ω–æ–≤—É —á–µ—Ä–µ–∑ {hours} –≥–æ–¥ {minutes} —Ö–≤."
        )
        logger.info(f"User {user_id} tried to claim free coins but is on cooldown.")
    else:
        new_balance = user_data['balance'] + FREE_COINS_AMOUNT
        update_user_data(user_id, balance=new_balance, last_free_coins_claim=current_time)
        updated_user_data = get_user_data(user_id)
        await message.reply(
            f"üéâ –í—ñ—Ç–∞—î–º–æ! –í–∏ –æ—Ç—Ä–∏–º–∞–ª–∏ {FREE_COINS_AMOUNT} –±–µ–∑–∫–æ—à—Ç–æ–≤–Ω–∏—Ö —Ñ–∞–Ω—Ç–∏–∫—ñ–≤!\n"
            f"–í–∞—à –Ω–æ–≤–∏–π –±–∞–ª–∞–Ω—Å: {updated_user_data['balance']} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤. üéâ"
        )
        logger.info(f"User {user_id} claimed {FREE_COINS_AMOUNT} free coins. New balance: {updated_user_data['balance']}.")


# --- –û–±—Ä–æ–±–∫–∞ –∑–∞–ø–∏—Ç—ñ–≤ –≤—ñ–¥ Web App (—á–µ—Ä–µ–∑ aiohttp.web) ---

async def api_get_balance(request: Request):
    data = await request.json()
    user_id = data.get('user_id')
    # –î–æ–¥–∞–Ω–æ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è username –∑ –∑–∞–ø–∏—Ç—É –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è
    username = data.get('username', 'Unnamed Player') 

    if not user_id:
        logger.warning("api_get_balance: User ID is missing in request.")
        return json_response({'error': 'User ID is required'}, status=400)
    
    # –û–Ω–æ–≤–ª—é—î–º–æ username –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –ø—Ä–∏ –∫–æ–∂–Ω–æ–º—É –∑–∞–ø–∏—Ç—ñ –±–∞–ª–∞–Ω—Å—É, —è–∫—â–æ –≤—ñ–Ω –∑–º—ñ–Ω–∏–≤—Å—è –∞–±–æ –Ω–µ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–π
    current_user_data = get_user_data(user_id)
    if current_user_data['username'] == 'Unnamed Player' or current_user_data['username'] != username:
         update_user_data(user_id, username=username)

    user_data = get_user_data(user_id)
    return json_response({
        'balance': user_data['balance'],
        'xp': user_data['xp'],
        'level': user_data['level'],
        'next_level_xp': get_xp_for_next_level(user_data['level']),
        'last_free_coins_claim': user_data['last_free_coins_claim'].isoformat() if user_data['last_free_coins_claim'] else None,
        'last_daily_bonus_claim': user_data['last_daily_bonus_claim'].isoformat() if user_data['last_daily_bonus_claim'] else None,
        'last_quick_bonus_claim': user_data['last_quick_bonus_claim'].isoformat() if user_data['last_quick_bonus_claim'] else None
    })

async def api_spin(request: Request):
    data = await request.json()
    user_id = data.get('user_id')
    if not user_id:
        logger.warning("api_spin: User ID is missing in request.")
        return json_response({'error': 'User ID is required'}, status=400)
    
    result, _ = spin_slot(user_id)
    if 'error' in result:
        return json_response(result, status=400)
    
    return json_response(result)

async def api_claim_daily_bonus(request: Request):
    """API-–µ–Ω–¥–ø–æ—ñ–Ω—Ç –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —â–æ–¥–µ–Ω–Ω–æ–≥–æ –±–æ–Ω—É—Å—É —á–µ—Ä–µ–∑ Web App."""
    data = await request.json()
    user_id = data.get('user_id')
    if not user_id:
        logger.warning("api_claim_daily_bonus: User ID is missing in request.")
        return json_response({'error': 'User ID is required'}, status=400)
    
    user_data = get_user_data(user_id)
    last_claim_time = user_data['last_daily_bonus_claim']

    current_time = datetime.now(timezone.utc)
    cooldown_duration = timedelta(hours=DAILY_BONUS_COOLDOWN_HOURS)

    if last_claim_time and (current_time - last_claim_time) < cooldown_duration:
        time_left = cooldown_duration - (current_time - last_claim_time)
        hours = int(time_left.total_seconds() // 3600)
        minutes = int((time_left.total_seconds() % 3600) // 60)
        seconds = int(time_left.total_seconds() % 60)
        return json_response(
            {'error': f"–ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞—á–µ–∫–∞–π—Ç–µ {hours:02d}:{minutes:02d}:{seconds:02d} –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –±–æ–Ω—É—Å—É."}, 
            status=403
        )
    else:
        new_balance = user_data['balance'] + DAILY_BONUS_AMOUNT
        update_user_data(user_id, balance=new_balance, last_daily_bonus_claim=current_time)
        return json_response({'message': '–ë–æ–Ω—É—Å —É—Å–ø—ñ—à–Ω–æ –æ—Ç—Ä–∏–º–∞–Ω–æ!', 'amount': DAILY_BONUS_AMOUNT})

async def api_claim_quick_bonus(request: Request):
    """API-–µ–Ω–¥–ø–æ—ñ–Ω—Ç –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —à–≤–∏–¥–∫–æ–≥–æ –±–æ–Ω—É—Å—É —á–µ—Ä–µ–∑ Web App (15 —Ö–≤)."""
    data = await request.json()
    user_id = data.get('user_id')
    if not user_id:
        logger.warning("api_claim_quick_bonus: User ID is missing in request.")
        return json_response({'error': 'User ID is required'}, status=400)
    
    user_data = get_user_data(user_id)
    last_claim_time = user_data['last_quick_bonus_claim']

    current_time = datetime.now(timezone.utc)
    cooldown_duration = timedelta(minutes=QUICK_BONUS_COOLDOWN_MINUTES)

    if last_claim_time and (current_time - last_claim_time) < cooldown_duration:
        time_left = cooldown_duration - (current_time - last_claim_time)
        minutes = int(time_left.total_seconds() // 60)
        seconds = int(time_left.total_seconds() % 60)
        return json_response(
            {'error': f"–ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞—á–µ–∫–∞–π—Ç–µ {minutes:02d}:{seconds:02d} –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ —à–≤–∏–¥–∫–æ–≥–æ –±–æ–Ω—É—Å—É."}, 
            status=403
        )
    else:
        new_balance = user_data['balance'] + QUICK_BONUS_AMOUNT
        update_user_data(user_id, balance=new_balance, last_quick_bonus_claim=current_time)
        return json_response({'message': '–®–≤–∏–¥–∫–∏–π –±–æ–Ω—É—Å —É—Å–ø—ñ—à–Ω–æ –æ—Ç—Ä–∏–º–∞–Ω–æ!', 'amount': QUICK_BONUS_AMOUNT})

async def api_get_leaderboard(request: Request):
    """API-–µ–Ω–¥–ø–æ—ñ–Ω—Ç –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö –¥–æ—à–∫–∏ –ª—ñ–¥–µ—Ä—ñ–≤."""
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        # –°–æ—Ä—Ç—É—î–º–æ –∑–∞ XP (—Å–ø–∞–¥–∞—é—á–æ—é), –ø–æ—Ç—ñ–º –∑–∞ –±–∞–ª–∞–Ω—Å–æ–º (—Å–ø–∞–¥–∞—é—á–æ—é)
        cursor.execute(
            'SELECT username, level, balance, xp FROM users ORDER BY xp DESC, balance DESC LIMIT 100;' # –û–±–º–µ–∂–µ–Ω–Ω—è –¥–æ 100 –ª—ñ–¥–µ—Ä—ñ–≤
        )
        results = cursor.fetchall()
        leaderboard = []
        for row in results:
            leaderboard.append({
                'username': row[0],
                'level': row[1],
                'balance': row[2],
                'xp': row[3]
            })
        return json_response({'leaderboard': leaderboard})
    except Exception as e:
        logger.error(f"Error fetching leaderboard: {e}")
        return json_response({'error': '–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ –¥–æ—à–∫–∏ –ª—ñ–¥–µ—Ä—ñ–≤.'}, status=500)
    finally:
        if conn:
            conn.close()


# --- –§—É–Ω–∫—Ü—ñ—ó –¥–ª—è –∑–∞–ø—É—Å–∫—É –±–æ—Ç–∞ —Ç–∞ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞ ---

async def on_startup_webhook(web_app: Application):
    """–í–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è –ø—Ä–∏ –∑–∞–ø—É—Å–∫—É Aiohttp –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞."""
    logger.warning('Starting bot and webhook...')
    init_db()
    await bot.set_webhook(WEBHOOK_URL)
    logger.info(f"Webhook set to: {WEBHOOK_URL}")

async def on_shutdown_webhook(web_app: Application):
    """–í–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ñ —Ä–æ–±–æ—Ç–∏ Aiohttp –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞."""
    logger.warning('Shutting down bot and webhook...')
    await bot.delete_webhook()

app_aiohttp = Application()

# –†–µ—î—Å—Ç—Ä–∞—Ü—ñ—è API –µ–Ω–¥–ø–æ—ñ–Ω—Ç—ñ–≤ –¥–ª—è Web App (–ü–ï–†–ï–î CORS)
app_aiohttp.router.add_post('/api/get_balance', api_get_balance, name='api_get_balance')
app_aiohttp.router.add_post('/api/spin', api_spin, name='api_spin')
app_aiohttp.router.add_post('/api/claim_daily_bonus', api_claim_daily_bonus, name='api_claim_daily_bonus')
app_aiohttp.router.add_post('/api/claim_quick_bonus', api_claim_quick_bonus, name='api_claim_quick_bonus')
app_aiohttp.router.add_post('/api/get_leaderboard', api_get_leaderboard, name='api_get_leaderboard') # –ù–û–í–ò–ô –ï–ù–î–ü–û–Ü–ù–¢

# –ù–∞–ª–∞—à—Ç–æ–≤—É—î–º–æ CORS –¥–ª—è –¥–æ–∑–≤–æ–ª—É –∑–∞–ø–∏—Ç—ñ–≤ –∑ Web App URL
cors = aiohttp_cors.setup(app_aiohttp, defaults={
    WEB_APP_URL: aiohttp_cors.ResourceOptions(
        allow_credentials=True,
        expose_headers="*",
        allow_headers="*",
        allow_methods="*",
    )
})

# –ó–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ CORS –¥–æ –≤–∞—à–∏—Ö API-–º–∞—Ä—à—Ä—É—Ç—ñ–≤
for route in list(app_aiohttp.router.routes()):
    if route.resource and route.resource.name in ['api_get_balance', 'api_spin', 'api_claim_daily_bonus', 'api_claim_quick_bonus', 'api_get_leaderboard']:
        cors.add(route)

# –†–µ—î—Å—Ç—Ä–∞—Ü—ñ—è —Ö–µ–Ω–¥–ª–µ—Ä–∞ –¥–ª—è Telegram webhook
SimpleRequestHandler(
    dispatcher=dp,
    bot=bot,
).register(app_aiohttp, WEBHOOK_PATH)

# –î–æ–¥–∞—î–º–æ —Ñ—É–Ω–∫—Ü—ñ—ó –∑–∞–ø—É—Å–∫—É/–∑—É–ø–∏–Ω–∫–∏ –¥–æ Aiohttp –¥–æ–¥–∞—Ç–∫–∞
app_aiohttp.on_startup.append(on_startup_webhook)
app_aiohttp.on_shutdown.append(on_shutdown_webhook)

if __name__ == '__main__':
    pass
