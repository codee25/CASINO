<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Імперія Слота: Віртуальне Казино</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="./style.css">
    <!-- Third-party libraries that need to be globally available -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body class="flex flex-col items-center justify-between w-screen h-screen bg-gradient-to-br from-purple-900 via-gray-900 to-indigo-900 text-white overflow-hidden">
    <div id="root" class="relative w-full h-full flex flex-col items-center justify-start">
        <!-- React App will be mounted here -->
        <p id="initialLoadingMessage" class="text-xl text-white mt-10">
            Завантаження гри... Будь ласка, зачекайте...
        </p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "react": "https://esm.sh/react@18.2.0",
                "react-dom/client": "https://esm.sh/react-dom@18.2.0/client"
            }
        }
    </script>
    <script type="module">
        import React, { useState, useEffect, useContext, createContext, useCallback, useRef } from 'react';
        import ReactDOM from 'react-dom/client';

        // Initialize Telegram WebApp
        if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
            Telegram.WebApp.ready();
            Telegram.WebApp.expand();
            Telegram.WebApp.setHeaderColor('#6B46C1');
            Telegram.WebApp.setBackgroundColor('#0d1117');
            Telegram.WebApp.sendData('JS_VERY_FIRST_LOG: Telegram WebApp initialized and ready.');
        } else {
            console.warn('Telegram WebApp object not found. Running in standalone mode.');
        }

        // --- Global State Management for User Data ---
        const UserContext = createContext(null);

        function UserProvider({ children }) {
            const [user, setUser] = useState({
                id: null,
                username: 'Завантаження...',
                balance: 0,
                xp: 0,
                level: 1,
                next_level_xp: 100,
                last_daily_bonus_claim: null,
                last_quick_bonus_claim: null
            });
            const [loadingUser, setLoadingUser] = useState(true);
            const [errorUser, setErrorUser] = useState(null);

            const API_BASE_URL = 'https://casino-0h0l.onrender.com'; // <--- ПЕРЕВІРТЕ ЦЕЙ URL!

            const fetchUserInfo = useCallback(async () => {
                if (!Telegram.WebApp.initDataUnsafe || !Telegram.WebApp.initDataUnsafe.user) {
                    setErrorUser('Telegram user data not available. Please open via Telegram.');
                    setLoadingUser(false);
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData('JS_ERROR: Telegram user data missing.');
                    }
                    return;
                }

                const telegramUser = Telegram.WebApp.initDataUnsafe.user;
                const userId = telegramUser.id;
                const username = telegramUser.username || telegramUser.first_name || 'Unnamed Player';

                try {
                    const response = await fetch(`${API_BASE_URL}/api/get_balance`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: userId, username: username })
                    });
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    setUser({
                        id: userId,
                        username: data.username,
                        balance: data.balance,
                        xp: data.xp,
                        level: data.level,
                        next_level_xp: data.next_level_xp,
                        last_daily_bonus_claim: data.last_daily_bonus_claim ? new Date(data.last_daily_bonus_claim) : null,
                        last_quick_bonus_claim: data.last_quick_bonus_claim ? new Date(data.last_quick_bonus_claim) : null
                    });
                    setLoadingUser(false);
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData(`JS_LOG: User ${userId} data fetched: Balance ${data.balance}, XP ${data.xp}, Level ${data.level}`);
                    }
                } catch (error) {
                    console.error('Error fetching user info:', error);
                    setErrorUser(`Failed to load user data: ${error.message}`);
                    setLoadingUser(false);
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData(`JS_ERROR: Failed to fetch user data: ${error.message.substring(0, Math.min(error.message.length, 100))}`);
                    }
                }
            }, []);

            useEffect(() => {
                fetchUserInfo();
            }, [fetchUserInfo]);

            const updateBalance = useCallback((amount) => {
                setUser(prev => ({ ...prev, balance: prev.balance + amount }));
                fetchUserInfo(); // Re-fetch to ensure consistency with DB
            }, [fetchUserInfo]);

            const updateXP = useCallback((amount) => {
                setUser(prev => ({ ...prev, xp: prev.xp + amount }));
                fetchUserInfo(); // Re-fetch to ensure consistency with DB
            }, [fetchUserInfo]);

            return (
                <UserContext.Provider value={{ user, loadingUser, errorUser, fetchUserInfo, updateBalance, updateXP }}>
                    {children}
                </UserContext.Provider>
            );
        }

        // Modal Component
        const Modal = ({ children, onClose, title }) => {
            return (
                <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm relative">
                        <h3 className="text-xl font-bold text-white mb-4">{title}</h3>
                        <button
                            onClick={onClose}
                            className="absolute top-3 right-3 text-gray-400 hover:text-white text-2xl font-bold"
                        >
                            &times;
                        </button>
                        {children}
                    </div>
                </div>
            );
        };

        // Message Box Component
        const MessageBox = ({ message, type = 'info', onClose }) => {
            const bgColor = type === 'error' ? 'bg-red-600' : type === 'success' ? 'bg-green-600' : 'bg-blue-600';
            return (
                <Modal title={type === 'error' ? 'Помилка' : type === 'success' ? 'Успіх' : 'Інформація'} onClose={onClose}>
                    <div className={`p-4 rounded-lg ${bgColor} text-white text-center`}>
                        <p>{message}</p>
                        <button
                            onClick={onClose}
                            className="mt-4 px-4 py-2 bg-white bg-opacity-20 rounded-md hover:bg-opacity-30 transition-colors"
                        >
                            Закрити
                        </button>
                    </div>
                </Modal>
            );
        };

        // Global Message State
        const MessageContext = createContext(null);

        function MessageProvider({ children }) {
            const [message, setMessage] = useState(null);

            const showMessage = useCallback((msg, type = 'info') => {
                setMessage({ text: msg, type });
            }, []);

            const clearMessage = useCallback(() => {
                setMessage(null);
            }, []);

            return (
                <MessageContext.Provider value={{ showMessage, clearMessage }}>
                    {children}
                    {message && <MessageBox message={message.text} type={message.type} onClose={clearMessage} />}
                </MessageContext.Provider>
            );
        }

        // --- Main App Component ---
        function App() {
            const { user, loadingUser, errorUser, fetchUserInfo } = useContext(UserContext);
            const { showMessage } = useContext(MessageContext);
            const [activeGame, setActiveGame] = useState(null); // 'slot', 'coin_flip', 'blackjack', null
            const [showLeaderboard, setShowLeaderboard] = useState(false);

            useEffect(() => {
                if (errorUser) {
                    showMessage(errorUser, 'error');
                }
            }, [errorUser, showMessage]);

            if (loadingUser) {
                return (
                    <div className="flex flex-col items-center justify-center h-full">
                        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-500"></div>
                        <p className="mt-4 text-white">Завантаження даних користувача...</p>
                    </div>
                );
            }

            if (errorUser && !loadingUser) {
                return (
                    <div className="flex flex-col items-center justify-center h-full text-red-500 text-center p-4">
                        <p className="text-xl font-bold">Помилка завантаження!</p>
                        <p className="mt-2">{errorUser}</p>
                        <button
                            onClick={fetchUserInfo}
                            className="mt-4 px-6 py-2 bg-blue-600 text-white rounded-lg shadow-md hover:bg-blue-700 transition-colors"
                        >
                            Спробувати знову
                        </button>
                    </div>
                );
            }

            return (
                <div className="relative w-full h-full flex flex-col items-center justify-start p-4 pb-20 overflow-auto">
                    {/* Header */}
                    <div className="w-full max-w-md bg-gray-800 bg-opacity-80 rounded-xl p-4 mb-4 shadow-lg flex flex-col items-center">
                        <h1 className="text-3xl font-extrabold text-yellow-400 mb-2 drop-shadow-lg">ІМПЕРІЯ СЛОТА</h1>
                        <div className="text-center mb-4">
                            <p className="text-lg text-gray-300">Вітаємо, <span className="font-semibold text-white">{user.username}</span>!</p>
                            <p className="text-2xl font-bold text-white">Баланс: <span className="text-yellow-300">{user.balance}</span> фантиків</p>
                            <p className="text-md text-gray-400">Рівень: <span className="font-semibold text-blue-300">{user.level}</span> (XP: <span className="text-green-300">{user.xp}/{user.next_level_xp}</span>)</p>
                        </div>
                        <div className="flex space-x-2 w-full justify-center">
                            <DailyBonusButton />
                            <QuickBonusButton />
                        </div>
                    </div>

                    {/* Game Selection */}
                    <div className="w-full max-w-md bg-gray-800 bg-opacity-80 rounded-xl p-4 shadow-lg flex flex-col items-center flex-grow">
                        <h2 className="text-2xl font-bold text-purple-300 mb-4">Оберіть гру:</h2>
                        <div className="grid grid-cols-1 gap-4 w-full">
                            <GameButton title="🎰 Слоти" onClick={() => setActiveGame('slot')} />
                            <GameButton title="🪙 Підкидання Монетки" onClick={() => setActiveGame('coin_flip')} />
                            <GameButton title="♠️ Блекджек" onClick={() => setActiveGame('blackjack')} />
                        </div>
                        <button
                            onClick={() => setShowLeaderboard(true)}
                            className="mt-6 w-full px-6 py-3 bg-indigo-700 text-white font-bold rounded-xl shadow-lg hover:bg-indigo-800 transition-all transform hover:scale-105"
                        >
                            🏆 Дошка Лідерів
                        </button>
                    </div>

                    {/* Game Modals */}
                    {activeGame === 'slot' && <SlotMachine onClose={() => setActiveGame(null)} />}
                    {activeGame === 'coin_flip' && <CoinFlipGame onClose={() => setActiveGame(null)} />}
                    {activeGame === 'blackjack' && <BlackjackGame onClose={() => setActiveGame(null)} />}
                    {showLeaderboard && <LeaderboardModal onClose={() => setShowLeaderboard(false)} />}
                </div>
            );
        }

        const GameButton = ({ title, onClick }) => (
            <button
                onClick={onClick}
                className="w-full px-6 py-3 bg-purple-700 text-white text-xl font-bold rounded-xl shadow-lg hover:bg-purple-800 transition-all transform hover:scale-105"
            >
                {title}
            </button>
        );

        // --- Slot Machine Game ---
        const SlotMachine = ({ onClose }) => {
            const { user, fetchUserInfo } = useContext(UserContext);
            const { showMessage } = useContext(MessageContext);
            const [reels, setReels] = useState(['?', '?', '?']);
            const [spinning, setSpinning] = useState(false);
            const [lastWin, setLastWin] = useState(0);
            const BET_AMOUNT = 100;
            const symbols = ['🍒', '🍋', '🍊', '🍇', '🔔', '💎', '🍀', '⭐', '💰']; // All possible symbols

            const spinSound = useRef(null);
            const winSound = useRef(null);
            const loseSound = useRef(null);

            useEffect(() => {
                // Initialize Tone.js for sounds
                if (typeof Tone !== 'undefined') {
                    spinSound.current = new Tone.Player("https://assets.mixkit.co/sfx/preview/mixkit-mechanical-slot-machine-spin-1961.mp3").toDestination();
                    winSound.current = new Tone.Player("https://assets.mixkit.co/sfx/preview/mixkit-game-level-win-689.mp3").toDestination();
                    loseSound.current = new Tone.Player("https://assets.mixkit.co/sfx/preview/mixkit-arcade-retro-game-over-213.mp3").toDestination();
                }
            }, []);

            const handleSpin = async () => {
                if (spinning) return;
                if (user.balance < BET_AMOUNT) {
                    showMessage(`Недостатньо фантиків! Потрібно ${BET_AMOUNT}. Ваш баланс: ${user.balance}`, 'error');
                    return;
                }

                setSpinning(true);
                setLastWin(0);
                if (spinSound.current) {
                    spinSound.current.start();
                }

                try {
                    const response = await fetch(`${API_BASE_URL}/api/spin`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.id })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    
                    // GSAP animation for reels
                    const reelElements = document.querySelectorAll('.symbol-reel');
                    const spinDuration = 2; // seconds

                    const finalSymbols = data.symbols;
                    const animationPromises = Array.from(reelElements).map((reel, index) => {
                        return new Promise(resolve => {
                            const initialPosition = 0;
                            const targetPosition = -2000 - (symbols.indexOf(finalSymbols[index]) * 80); // Spin multiple times + land on target
                            
                            gsap.to(reel, {
                                y: targetPosition,
                                duration: spinDuration + (index * 0.2), // Stagger spins
                                ease: "power2.out",
                                onComplete: () => {
                                    reel.style.transform = `translateY(${targetPosition % (symbols.length * 80)}px)`; // Reset position visually
                                    reel.innerHTML = finalSymbols[index]; // Set final symbol
                                    resolve();
                                }
                            });
                        });
                    });

                    await Promise.all(animationPromises); // Wait for all reels to stop

                    setReels(data.symbols);
                    setLastWin(data.winnings);
                    fetchUserInfo(); // Update balance, XP, level

                    if (data.winnings > 0) {
                        if (winSound.current) winSound.current.start();
                        showMessage(`🎉 Ви виграли ${data.winnings} фантиків! ${data.message}`, 'success');
                    } else {
                        if (loseSound.current) loseSound.current.start();
                        showMessage(`Спробуйте ще раз! ${data.message}`, 'info');
                    }

                } catch (error) {
                    console.error('Error during spin:', error);
                    showMessage(`Помилка спіна: ${error.message}`, 'error');
                } finally {
                    setSpinning(false);
                    if (spinSound.current && spinSound.current.state === 'started') {
                        spinSound.current.stop();
                    }
                }
            };

            return (
                <Modal title="🎰 Слоти" onClose={onClose}>
                    <div className="flex flex-col items-center justify-center p-4 bg-gray-900 rounded-lg shadow-inner">
                        <div className="flex space-x-2 mb-6 bg-gray-700 p-4 rounded-lg shadow-md">
                            {reels.map((symbol, index) => (
                                <div key={index} className="overflow-hidden w-20 h-20 bg-gray-800 rounded-lg flex items-center justify-center shadow-inner">
                                    <div className="symbol-reel text-5xl flex items-center justify-center h-full w-full" style={{ transform: 'translateY(0)' }}>
                                        {symbol}
                                    </div>
                                </div>
                            ))}
                        </div>
                        <p className="text-xl font-bold text-white mb-4">Остання виграш: <span className="text-green-400">{lastWin}</span> фантиків</p>
                        <button
                            onClick={handleSpin}
                            disabled={spinning || user.balance < BET_AMOUNT}
                            className={`w-full py-3 rounded-lg text-white font-bold text-lg shadow-lg transition-all transform ${
                                spinning || user.balance < BET_AMOUNT
                                    ? 'bg-gray-600 cursor-not-allowed'
                                    : 'bg-green-600 hover:bg-green-700 hover:scale-105'
                            }`}
                        >
                            {spinning ? 'Крутиться...' : `Крутити (${BET_AMOUNT} фантиків)`}
                        </button>
                    </div>
                </Modal>
            );
        };

        // --- Coin Flip Game ---
        const CoinFlipGame = ({ onClose }) => {
            const { user, fetchUserInfo } = useContext(UserContext);
            const { showMessage } = useContext(MessageContext);
            const [flipping, setFlipping] = useState(false);
            const [result, setResult] = useState(null); // 'heads' or 'tails'
            const [choice, setChoice] = useState(null); // 'heads' or 'tails'
            const [message, setMessage] = useState('');
            const BET_AMOUNT = 50;

            const flipSound = useRef(null);
            const winSound = useRef(null);
            const loseSound = useRef(null);

            useEffect(() => {
                if (typeof Tone !== 'undefined') {
                    flipSound.current = new Tone.Player("https://assets.mixkit.co/sfx/preview/mixkit-coin-flip-205.mp3").toDestination();
                    winSound.current = new Tone.Player("https://assets.mixkit.co/sfx/preview/mixkit-game-level-win-689.mp3").toDestination();
                    loseSound.current = new Tone.Player("https://assets.mixkit.co/sfx/preview/mixkit-arcade-retro-game-over-213.mp3").toDestination();
                }
            }, []);

            const handleFlip = async (playerChoice) => {
                if (flipping) return;
                if (user.balance < BET_AMOUNT) {
                    showMessage(`Недостатньо фантиків! Потрібно ${BET_AMOUNT}. Ваш баланс: ${user.balance}`, 'error');
                    return;
                }

                setFlipping(true);
                setResult(null);
                setChoice(playerChoice);
                setMessage('');

                if (flipSound.current) flipSound.current.start();

                try {
                    const response = await fetch(`${API_BASE_URL}/api/coin_flip`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.id, choice: playerChoice })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    
                    // Simulate flip animation
                    const coinElement = document.getElementById('coin');
                    gsap.to(coinElement, {
                        rotationY: 720, // Spin twice
                        duration: 1.5,
                        ease: "power2.out",
                        onComplete: () => {
                            setResult(data.result);
                            setMessage(data.message);
                            fetchUserInfo(); // Update balance, XP, level

                            if (data.winnings > 0) {
                                if (winSound.current) winSound.current.start();
                            } else {
                                if (loseSound.current) loseSound.current.start();
                            }
                            setFlipping(false);
                        }
                    });

                } catch (error) {
                    console.error('Error during coin flip:', error);
                    showMessage(`Помилка підкидання монетки: ${error.message}`, 'error');
                    setFlipping(false);
                } finally {
                    if (flipSound.current && flipSound.current.state === 'started') {
                        flipSound.current.stop();
                    }
                }
            };

            return (
                <Modal title="🪙 Підкидання Монетки" onClose={onClose}>
                    <div className="flex flex-col items-center justify-center p-4 bg-gray-900 rounded-lg shadow-inner">
                        <div id="coin" className={`text-6xl mb-6 transform transition-transform duration-500 ${flipping ? 'animate-spin-y' : ''}`}>
                            {result === 'heads' ? '🪙' : result === 'tails' ? '💰' : '❓'}
                        </div>
                        <p className="text-xl text-white mb-4">{message || 'Оберіть Орел або Решка'}</p>
                        <div className="flex space-x-4 mb-6">
                            <button
                                onClick={() => handleFlip('heads')}
                                disabled={flipping || user.balance < BET_AMOUNT}
                                className={`px-6 py-3 rounded-lg text-white font-bold text-lg shadow-lg transition-all transform ${
                                    flipping || user.balance < BET_AMOUNT
                                        ? 'bg-gray-600 cursor-not-allowed'
                                        : 'bg-blue-600 hover:bg-blue-700 hover:scale-105'
                                }`}
                            >
                                Орел
                            </button>
                            <button
                                onClick={() => handleFlip('tails')}
                                disabled={flipping || user.balance < BET_AMOUNT}
                                className={`px-6 py-3 rounded-lg text-white font-bold text-lg shadow-lg transition-all transform ${
                                    flipping || user.balance < BET_AMOUNT
                                        ? 'bg-gray-600 cursor-not-allowed'
                                        : 'bg-red-600 hover:bg-red-700 hover:scale-105'
                                }`}
                            >
                                Решка
                            </button>
                        </div>
                        <p className="text-lg text-gray-300">Ставка: {BET_AMOUNT} фантиків</p>
                    </div>
                </Modal>
            );
        };

        // --- Blackjack Game ---
        const BlackjackGame = ({ onClose }) => {
            const { user, fetchUserInfo } = useContext(UserContext);
            const { showMessage } = useContext(MessageContext);
            const [ws, setWs] = useState(null);
            const [roomState, setRoomState] = useState(null);
            const [betAmount, setBetAmount] = useState(100); // Default bet
            const [message, setMessage] = useState('');
            const [isConnected, setIsConnected] = useState(false);
            const reconnectAttempts = useRef(0);
            const MAX_RECONNECT_ATTEMPTS = 5;
            const RECONNECT_DELAY_MS = 2000;

            const connectWebSocket = useCallback(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    console.log("WebSocket is already open.");
                    return;
                }
                if (!user.id) {
                    console.warn("User ID not available for WebSocket connection.");
                    return;
                }

                const WS_BASE_URL = API_BASE_URL.replace('https://', 'wss://');
                const newWs = new WebSocket(`${WS_BASE_URL}/ws/${user.id}`);
                console.log(`[WS] Attempting to connect to ${WS_BASE_URL}/ws/${user.id}`);
                if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                    Telegram.WebApp.sendData(`JS_DEBUG: Attempting WS connect to ${WS_BASE_URL}/ws/${user.id}`);
                }

                newWs.onopen = () => {
                    console.log('[WS] Connected to WebSocket.');
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData('JS_LOG: WebSocket connected.');
                    }
                    setIsConnected(true);
                    reconnectAttempts.current = 0; // Reset attempts on successful connection
                    newWs.send(JSON.stringify({ action: "request_state" })); // Request initial state
                    console.log('[WS] Sent request_state on open.');
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData('JS_DEBUG: Sent request_state on WS open.');
                    }
                };

                newWs.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('[WS] Received message:', data);
                        if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                            Telegram.WebApp.sendData(`JS_DEBUG: WS received: ${JSON.stringify(data).substring(0, Math.min(JSON.stringify(data).length, 100))}`);
                        }

                        if (data.type === 'ping') {
                            newWs.send(JSON.stringify({ type: 'pong' }));
                            console.log('[WS] Sent pong.');
                        } else if (data.type === 'error') {
                            showMessage(data.message, 'error');
                            setMessage(data.message);
                        } else if (data.type === 'game_message') {
                            showMessage(data.message, 'info');
                            setMessage(data.message);
                        } else if (data.type === 'round_result') {
                            showMessage(data.message, data.winnings > 0 ? 'success' : 'info');
                            setMessage(data.message);
                            fetchUserInfo(); // Update user balance, XP, level after round
                            setRoomState(data); // Update state with final round data
                        } else if (data.type === 'level_up') {
                            showMessage(`🎉 Вітаємо! Ви досягли рівня ${data.level}!`, 'success');
                            fetchUserInfo(); // Fetch updated user data
                        } else {
                            // This is likely a room state update
                            setRoomState(data);
                            // Clear messages that are not related to current game flow (e.g. old error messages)
                            if (data.status === 'betting' || data.status === 'playing') {
                                setMessage(''); 
                            }
                        }
                    } catch (e) {
                        console.error('[WS] Error parsing message or handling data:', e, event.data);
                        if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                            Telegram.WebApp.sendData(`JS_ERROR: WS message error: ${e.message.substring(0, Math.min(e.message.length, 100))}`);
                        }
                        showMessage(`Помилка обробки даних від сервера: ${e.message}`, 'error');
                    }
                };

                newWs.onclose = (event) => {
                    setIsConnected(false);
                    console.log('[WS] Disconnected from WebSocket:', event.code, event.reason);
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData(`JS_WARN: WebSocket disconnected: Code ${event.code}, Reason: ${event.reason.substring(0, Math.min(event.reason.length, 100))}`);
                    }
                    // Attempt to reconnect
                    if (reconnectAttempts.current < MAX_RECONNECT_ATTEMPTS) {
                        reconnectAttempts.current++;
                        console.log(`[WS] Attempting reconnect ${reconnectAttempts.current}/${MAX_RECONNECT_ATTEMPTS}...`);
                        if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                            Telegram.WebApp.sendData(`JS_DEBUG: WS reconnect attempt ${reconnectAttempts.current}.`);
                        }
                        setTimeout(connectWebSocket, RECONNECT_DELAY_MS);
                    } else {
                        showMessage('З\'єднання з грою втрачено. Будь ласка, спробуйте пізніше.', 'error');
                        if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                            Telegram.WebApp.sendData('JS_ERROR: Max WS reconnect attempts reached.');
                        }
                    }
                };

                newWs.onerror = (error) => {
                    console.error('[WS] WebSocket error:', error);
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData(`JS_ERROR: WebSocket error: ${error.message || 'Unknown error'}`);
                    }
                    newWs.close(); // Close immediately on error to trigger onclose
                };

                setWs(newWs);
            }, [user.id, showMessage]);

            useEffect(() => {
                if (user.id && !ws) {
                    connectWebSocket();
                }
                // Cleanup on component unmount
                return () => {
                    if (ws) {
                        console.log('[WS] Closing WebSocket on component unmount.');
                        ws.close();
                        setWs(null);
                        setIsConnected(false);
                    }
                };
            }, [user.id, ws, connectWebSocket]);

            const sendWebSocketMessage = (action, payload = {}) => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    const messageToSend = { action, user_id: user.id, room_id: roomState?.room_id, ...payload };
                    ws.send(JSON.stringify(messageToSend));
                    console.log('[WS] Sent message:', messageToSend);
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData(`JS_DEBUG: WS sent: ${JSON.stringify(messageToSend).substring(0, Math.min(JSON.stringify(messageToSend).length, 100))}`);
                    }
                } else {
                    showMessage('З\'єднання з сервером не встановлено. Спробуйте перепідключитися.', 'error');
                    console.warn('[WS] WebSocket not open. State:', ws?.readyState);
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData('JS_WARN: WS not open for sending.');
                    }
                    // Attempt to reconnect if not connected
                    if (!isConnected) {
                        connectWebSocket();
                    }
                }
            };

            const handleBet = () => {
                if (user.balance < betAmount) {
                    showMessage(`Недостатньо фантиків! Потрібно ${betAmount}. Ваш баланс: ${user.balance}`, 'error');
                    return;
                }
                sendWebSocketMessage('bet', { amount: betAmount });
            };

            const handleHit = () => {
                sendWebSocketMessage('hit');
            };

            const handleStand = () => {
                sendWebSocketMessage('stand');
            };

            const getPlayerById = (playerId) => roomState?.players.find(p => p.user_id === playerId);
            const currentPlayer = getPlayerById(user.id);
            const isMyTurn = roomState?.current_player_turn === user.id;
            const isBettingPhase = roomState?.status === 'betting';
            const isPlayingPhase = roomState?.status === 'playing';
            const isWaitingPhase = roomState?.status === 'waiting' || roomState?.status === 'starting_timer';
            const isRoundEndPhase = roomState?.status === 'round_end';

            const canBet = isBettingPhase && !currentPlayer?.has_bet && user.balance >= betAmount;
            const canHitOrStand = isPlayingPhase && isMyTurn && currentPlayer?.is_playing;

            return (
                <Modal title="♠️ Блекджек" onClose={onClose}>
                    <div className="flex flex-col items-center justify-center p-4 bg-gray-900 rounded-lg shadow-inner text-white">
                        {!isConnected && (
                            <div className="text-red-400 mb-4 text-center">
                                <p>З\'єднання втрачено або встановлюється...</p>
                                <button
                                    onClick={connectWebSocket}
                                    className="mt-2 px-4 py-2 bg-blue-600 rounded-md hover:bg-blue-700 transition-colors"
                                >
                                    Перепідключитися
                                </button>
                            </div>
                        )}

                        {roomState ? (
                            <>
                                <p className="text-lg mb-2">Кімната: <span className="font-bold text-yellow-300">{roomState.room_id}</span></p>
                                <p className="text-md mb-4">Гравців: {roomState.player_count}/{roomState.max_players} (Мін: {roomState.min_players})</p>

                                {isWaitingPhase && (
                                    <p className="text-center text-gray-300 mb-4">
                                        Очікування гравців... ({roomState.timer > 0 ? `Гра почнеться через ${roomState.timer} сек.` : 'Зачекайте'})
                                    </p>
                                )}
                                {isBettingPhase && (
                                    <div className="mb-4 text-center">
                                        <p className="text-yellow-300 text-xl font-bold">Зробіть вашу ставку!</p>
                                        <p className="text-gray-400 text-sm">Таймер ставок: {roomState.timer} сек.</p>
                                        <input
                                            type="number"
                                            value={betAmount}
                                            onChange={(e) => setBetAmount(Math.max(1, parseInt(e.target.value) || 1))}
                                            min="1"
                                            className="mt-2 p-2 w-24 bg-gray-700 text-white rounded-md text-center"
                                            disabled={!canBet}
                                        />
                                        <button
                                            onClick={handleBet}
                                            disabled={!canBet}
                                            className={`mt-2 ml-2 px-4 py-2 rounded-lg text-white font-bold transition-all transform ${
                                                canBet ? 'bg-green-600 hover:bg-green-700 hover:scale-105' : 'bg-gray-600 cursor-not-allowed'
                                            }`}
                                        >
                                            Ставка ({betAmount})
                                        </button>
                                        {currentPlayer?.has_bet && !currentPlayer?.is_playing && (
                                            <p className="text-red-300 mt-2">Недостатньо фантиків для ставки. Ви не берете участь у цьому раунді.</p>
                                        )}
                                        {currentPlayer?.has_bet && currentPlayer?.is_playing && (
                                            <p className="text-green-300 mt-2">Ваша ставка прийнята. Очікуємо інших гравців.</p>
                                        )}
                                    </div>
                                )}
                                {isPlayingPhase && (
                                    <p className="text-center text-blue-300 text-xl font-bold mb-4">
                                        {isMyTurn ? 'Ваш хід!' : `Хід гравця ${roomState.players.find(p => p.user_id === roomState.current_player_turn)?.username || 'Невідомий'}`}
                                    </p>
                                )}
                                {isRoundEndPhase && (
                                    <p className="text-center text-yellow-300 text-xl font-bold mb-4">Раунд завершено!</p>
                                )}

                                {message && (
                                    <p className="text-center text-lg font-semibold mb-4 text-purple-300">{message}</p>
                                )}

                                {/* Players' Hands */}
                                <div className="w-full grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                                    {roomState.players.map(player => (
                                        <div
                                            key={player.user_id}
                                            className={`p-4 rounded-lg shadow-md ${player.user_id === user.id ? 'bg-blue-800 border-2 border-blue-500' : 'bg-gray-800'} ${roomState.current_player_turn === player.user_id ? 'border-4 border-yellow-500 animate-pulse' : ''}`}
                                        >
                                            <p className="font-bold text-lg mb-1">
                                                {player.username} {player.user_id === user.id ? '(Ви)' : ''}
                                            </p>
                                            <p className="text-sm text-gray-300">Ставка: {player.bet}</p>
                                            <p className="text-sm text-gray-300">Рахунок: {player.score} {player.is_busted ? '(Перебір!)' : ''}</p>
                                            <div className="flex flex-wrap gap-1 mt-2">
                                                {player.hand.length > 0 ? (
                                                    player.hand.map((card, idx) => (
                                                        <span key={idx} className="bg-gray-700 px-2 py-1 rounded-md text-sm">
                                                            {card}
                                                        </span>
                                                    ))
                                                ) : (
                                                    <span className="text-gray-500">Немає карт</span>
                                                )}
                                            </div>
                                            {!player.is_playing && player.has_bet && player.score <= 21 && roomState.status === 'playing' && (
                                                <p className="text-green-400 text-sm mt-2">Зупинився</p>
                                            )}
                                        </div>
                                    ))}
                                </div>

                                {/* Actions */}
                                {isPlayingPhase && isMyTurn && currentPlayer?.is_playing && (
                                    <div className="flex space-x-4 mt-4">
                                        <button
                                            onClick={handleHit}
                                            disabled={!canHitOrStand}
                                            className={`px-6 py-3 rounded-lg text-white font-bold text-lg shadow-lg transition-all transform ${
                                                canHitOrStand ? 'bg-blue-600 hover:bg-blue-700 hover:scale-105' : 'bg-gray-600 cursor-not-allowed'
                                            }`}
                                        >
                                            Взяти карту
                                        </button>
                                        <button
                                            onClick={handleStand}
                                            disabled={!canHitOrStand}
                                            className={`px-6 py-3 rounded-lg text-white font-bold text-lg shadow-lg transition-all transform ${
                                                canHitOrStand ? 'bg-red-600 hover:bg-red-700 hover:scale-105' : 'bg-gray-600 cursor-not-allowed'
                                            }`}
                                        >
                                            Зупинитись
                                        </button>
                                    </div>
                                )}
                            </>
                        ) : (
                            <p className="text-center text-gray-400">Підключення до кімнати Блекджеку...</p>
                        )}
                    </div>
                </Modal>
            );
        };

        // --- Daily Bonus Component ---
        const DailyBonusButton = () => {
            const { user, fetchUserInfo } = useContext(UserContext);
            const { showMessage } = useContext(MessageContext);
            const [cooldownTime, setCooldownTime] = useState(null);
            const DAILY_BONUS_AMOUNT = 300; // Must match backend

            useEffect(() => {
                if (user.last_daily_bonus_claim) {
                    const lastClaim = user.last_daily_bonus_claim;
                    const nextClaimTime = new Date(lastClaim.getTime() + (24 * 60 * 60 * 1000)); // 24 hours
                    const now = new Date();
                    if (now < nextClaimTime) {
                        setCooldownTime(nextClaimTime);
                    } else {
                        setCooldownTime(null);
                    }
                } else {
                    setCooldownTime(null);
                }
            }, [user.last_daily_bonus_claim]);

            useEffect(() => {
                const interval = setInterval(() => {
                    if (cooldownTime) {
                        const now = new Date();
                        if (now >= cooldownTime) {
                            setCooldownTime(null);
                            fetchUserInfo(); // Refresh user data to enable button
                        }
                    }
                }, 1000); // Update every second

                return () => clearInterval(interval);
            }, [cooldownTime, fetchUserInfo]);

            const formatTimeLeft = (endTime) => {
                const now = new Date();
                const timeLeftMs = endTime - now;
                if (timeLeftMs <= 0) return 'Готово!';

                const hours = Math.floor(timeLeftMs / (1000 * 60 * 60));
                const minutes = Math.floor((timeLeftMs % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeLeftMs % (1000 * 60)) / 1000);
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            };

            const handleClaim = async () => {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/claim_daily_bonus`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.id })
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    showMessage(`+${data.amount} фантиків! ${data.message}`, 'success');
                    fetchUserInfo(); // Update user data and cooldown
                } catch (error) {
                    console.error('Error claiming daily bonus:', error);
                    showMessage(`Помилка: ${error.message}`, 'error');
                }
            };

            const isButtonDisabled = cooldownTime !== null;

            return (
                <button
                    onClick={handleClaim}
                    disabled={isButtonDisabled}
                    className={`flex-1 px-4 py-2 rounded-lg text-white font-bold transition-all transform ${
                        isButtonDisabled
                            ? 'bg-gray-600 cursor-not-allowed'
                            : 'bg-blue-600 hover:bg-blue-700 hover:scale-105'
                    }`}
                >
                    Щоденна Винагорода {isButtonDisabled && `(${formatTimeLeft(cooldownTime)})`}
                </button>
            );
        };

        // --- Quick Bonus Component ---
        const QuickBonusButton = () => {
            const { user, fetchUserInfo } = useContext(UserContext);
            const { showMessage } = useContext(MessageContext);
            const [cooldownTime, setCooldownTime] = useState(null);
            const QUICK_BONUS_AMOUNT = 100; // Must match backend

            useEffect(() => {
                if (user.last_quick_bonus_claim) {
                    const lastClaim = user.last_quick_bonus_claim;
                    const nextClaimTime = new Date(lastClaim.getTime() + (15 * 60 * 1000)); // 15 minutes
                    const now = new Date();
                    if (now < nextClaimTime) {
                        setCooldownTime(nextClaimTime);
                    } else {
                        setCooldownTime(null);
                    }
                } else {
                    setCooldownTime(null);
                }
            }, [user.last_quick_bonus_claim]);

            useEffect(() => {
                const interval = setInterval(() => {
                    if (cooldownTime) {
                        const now = new Date();
                        if (now >= cooldownTime) {
                            setCooldownTime(null);
                            fetchUserInfo(); // Refresh user data to enable button
                        }
                    }
                }, 1000); // Update every second

                return () => clearInterval(interval);
            }, [cooldownTime, fetchUserInfo]);

            const formatTimeLeft = (endTime) => {
                const now = new Date();
                const timeLeftMs = endTime - now;
                if (timeLeftMs <= 0) return 'Готово!';

                const minutes = Math.floor((timeLeftMs % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeLeftMs % (1000 * 60)) / 1000);
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            };

            const handleClaim = async () => {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/claim_quick_bonus`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.id })
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    showMessage(`+${data.amount} фантиків! ${data.message}`, 'success');
                    fetchUserInfo(); // Update user data and cooldown
                } catch (error) {
                    console.error('Error claiming quick bonus:', error);
                    showMessage(`Помилка: ${error.message}`, 'error');
                }
            };

            const isButtonDisabled = cooldownTime !== null;

            return (
                <button
                    onClick={handleClaim}
                    disabled={isButtonDisabled}
                    className={`flex-1 px-4 py-2 rounded-lg text-white font-bold transition-all transform ${
                        isButtonDisabled
                            ? 'bg-gray-600 cursor-not-allowed'
                            : 'bg-red-600 hover:bg-red-700 hover:scale-105'
                    }`}
                >
                    Швидкий Бонус {isButtonDisabled && `(${formatTimeLeft(cooldownTime)})`}
                </button>
            );
        };

        // --- Leaderboard Modal ---
        const LeaderboardModal = ({ onClose }) => {
            const { showMessage } = useContext(MessageContext);
            const [leaderboard, setLeaderboard] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);

            const fetchLeaderboard = useCallback(async () => {
                setLoading(true);
                setError(null);
                try {
                    const response = await fetch(`${API_BASE_URL}/api/get_leaderboard`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({}) // No body needed for this endpoint
                    });
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    setLeaderboard(data.leaderboard);
                } catch (err) {
                    console.error('Error fetching leaderboard:', err);
                    setError(`Помилка завантаження лідерборду: ${err.message}`);
                    showMessage(`Помилка завантаження лідерборду: ${err.message}`, 'error');
                } finally {
                    setLoading(false);
                }
            }, [showMessage]);

            useEffect(() => {
                fetchLeaderboard();
            }, [fetchLeaderboard]);

            return (
                <Modal title="🏆 Дошка Лідерів" onClose={onClose}>
                    <div className="bg-gray-900 rounded-lg p-4 max-h-96 overflow-y-auto">
                        {loading && <p className="text-center text-gray-400">Завантаження...</p>}
                        {error && <p className="text-center text-red-400">{error}</p>}
                        {!loading && !error && leaderboard.length === 0 && (
                            <p className="text-center text-gray-400">Дошка лідерів порожня.</p>
                        )}
                        {!loading && !error && leaderboard.length > 0 && (
                            <ul className="space-y-2">
                                {leaderboard.map((entry, index) => (
                                    <li key={entry.user_id} className="flex items-center justify-between bg-gray-800 p-3 rounded-md shadow-sm">
                                        <span className="font-bold text-purple-300 mr-2">{index + 1}.</span>
                                        <div className="flex-1">
                                            <p className="text-white font-semibold">{entry.username}</p>
                                            <p className="text-sm text-blue-300">ID: {entry.user_id}</p>
                                        </div>
                                        <div className="text-right">
                                            <p className="text-white">{entry.balance} фантиків</p>
                                            <p className="text-sm text-gray-400">Рівень {entry.level} (XP: {entry.xp})</p>
                                        </div>
                                    </li>
                                ))}
                            </ul>
                        )}
                    </div>
                </Modal>
            );
        };

        // --- Root Render ---
        const rootElement = document.getElementById('root');
        const initialMessage = document.getElementById('initialLoadingMessage');

        if (!Telegram.WebApp.initDataUnsafe || !Telegram.WebApp.initDataUnsafe.user) {
            if (rootElement) {
                rootElement.innerHTML = `
                    <p class="text-red-500 text-center mt-10 text-lg">
                        Це додаток Telegram Mini App. Будь ласка, відкрийте його через Telegram.
                    </p>
                    <p class="text-gray-400 text-center mt-4">
                        Якщо ви розробник, перевірте, чи ваш Telegram WebApp SDK завантажено та ініціалізовано.
                    </p>
                `;
            }
            if (initialMessage) {
                initialMessage.remove();
            }
            console.error("Telegram WebApp initDataUnsafe or user is missing. Cannot proceed.");
        } else {
            // Remove loading message
            if (initialMessage) {
                initialMessage.remove();
            }
            
            try {
                const root = ReactDOM.createRoot(rootElement);
                root.render(
                    <React.StrictMode>
                        <MessageProvider>
                            <UserProvider>
                                <App />
                            </UserProvider>
                        </MessageProvider>
                    </React.StrictMode>
                );

                if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                    Telegram.WebApp.sendData('JS_LOG: React app rendered successfully into DOM.');
                }
            } catch (e) {
                console.error("Error during final React mounting:", e);
                if (rootElement) {
                    rootElement.innerHTML = `<p class="text-red-500 text-center mt-10 text-lg">
                        Невідома помилка при запуску гри: <br/> ${e.message}
                        <br/> Перевірте консоль браузера або логи Render.
                    </p>`;
                }
                if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                    Telegram.WebApp.sendData(`JS_FATAL_REACT_MOUNT_ERROR: ${e.message.substring(0, Math.min(e.message.length, 100))}`);
                }
            }
        }
    </script>
</body>
</html>
