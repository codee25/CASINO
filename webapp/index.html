<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>–Ü–º–ø–µ—Ä—ñ—è –°–ª–æ—Ç–∞: –í—ñ—Ä—Ç—É–∞–ª—å–Ω–µ –ö–∞–∑–∏–Ω–æ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="./style.css">
    <!-- Third-party libraries that need to be globally available -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body class="flex flex-col items-center justify-between w-screen h-screen bg-gradient-to-br from-purple-900 via-gray-900 to-indigo-900 text-white overflow-hidden font-inter">
    <div id="root" class="relative w-full h-full flex flex-col items-center justify-start">
        <!-- React App will be mounted here -->
        <p id="initialLoadingMessage" class="text-xl text-white mt-10">
            –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≥—Ä–∏... –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞—á–µ–∫–∞–π—Ç–µ...
        </p>
    </div>

    <script type="text/babel">
        const { useState, useEffect, useRef, createContext, useContext, useCallback } = React;

        // --- Global Configuration ---
        // !!! –í–ê–ñ–õ–ò–í–û: –ó–∞–º—ñ–Ω—ñ—Ç—å —Ü–µ–π URL –Ω–∞ URL –≤–∞—à–æ–≥–æ –±–µ–∫–µ–Ω–¥—É –Ω–∞ Render !!!
        // –ù–∞–ø—Ä–∏–∫–ª–∞–¥: https://your-backend-app.onrender.com
        const API_BASE_URL = "https://casino-0h0l.onrender.com"; 

        // --- Telegram WebApp Integration ---
        const sendTelegramLog = (message, type = 'JS_LOG') => {
            if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                const fullMessage = `${type}: ${message}`;
                Telegram.WebApp.sendData(fullMessage.substring(0, Math.min(fullMessage.length, 250))); // Limit message length
            } else {
                console.log(`[Telegram Log - ${type}]: ${message}`);
            }
        };

        // Ensure Telegram WebApp is ready and expanded
        if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
            Telegram.WebApp.ready();
            Telegram.WebApp.expand();
            sendTelegramLog('Telegram WebApp ready and expanded.', 'JS_VERY_FIRST_LOG');
        }

        // --- User Context for Global State Management ---
        const UserContext = createContext(null);

        const UserProvider = ({ children }) => {
            const [user, setUser] = useState({
                userId: null,
                username: '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...',
                balance: 0,
                xp: 0,
                level: 1,
                nextLevelXp: 100,
                lastDailyBonusClaim: null,
                lastQuickBonusClaim: null,
                blackjackRoom: null, // Current blackjack room state
                blackjackPlayers: [], // List of players in blackjack room
                blackjackStatus: 'waiting', // waiting, starting_timer, betting, playing, round_end
                blackjackCurrentPlayerTurn: null,
                blackjackTimer: 0,
                blackjackDealerHand: [],
                blackjackDealerScore: 0,
            });
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const wsRef = useRef(null); // WebSocket reference
            const wsReconnectAttempts = useRef(0);
            const MAX_WS_RECONNECT_ATTEMPTS = 5;
            const wsReconnectTimeout = useRef(null);

            // Function to send messages via WebSocket
            const sendWsMessage = useCallback((action, data = {}) => {
                if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
                    const message = { action, ...data };
                    wsRef.current.send(JSON.stringify(message));
                    sendTelegramLog(`WS Sent: ${action}`, 'JS_DEBUG');
                } else {
                    sendTelegramLog(`WS Error: Cannot send message, WebSocket not open. Action: ${action}`, 'JS_ERROR');
                }
            }, []);

            // Function to connect WebSocket
            const connectBlackjackWebSocket = useCallback(async () => {
                if (wsRef.current && (wsRef.current.readyState === WebSocket.OPEN || wsRef.current.readyState === WebSocket.CONNECTING)) {
                    sendTelegramLog('WS already open or connecting, skipping new connection attempt.', 'JS_DEBUG');
                    return;
                }

                if (!user.userId) {
                    sendTelegramLog('WS: user.userId not available for connection.', 'JS_DEBUG');
                    return;
                }

                sendTelegramLog(`Attempting to connect WebSocket to ${API_BASE_URL.replace('https', 'wss')}/ws/${user.userId}`, 'JS_LOG');
                
                try {
                    wsRef.current = new WebSocket(`${API_BASE_URL.replace('https', 'wss')}/ws/${user.userId}`);
                    
                    wsRef.current.onopen = () => {
                        sendTelegramLog('WebSocket connection opened successfully.', 'JS_LOG');
                        wsReconnectAttempts.current = 0; // Reset reconnect attempts on successful connection
                        if (wsReconnectTimeout.current) {
                            clearTimeout(wsReconnectTimeout.current);
                            wsReconnectTimeout.current = null;
                        }
                        sendWsMessage("request_state"); // Request initial state after connection
                    };

                    wsRef.current.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            // sendTelegramLog(`WS Received: ${JSON.stringify(data)}`, 'JS_DEBUG'); // Too verbose for production
                            
                            if (data.type === "ping") {
                                sendWsMessage("pong"); // Respond to ping
                            } else if (data.type === "error") {
                                setError(data.message);
                                sendTelegramLog(`WS Error from server: ${data.message}`, 'JS_ERROR');
                            } else if (data.type === "game_message") {
                                // Display game-specific messages (e.g., "You busted!")
                                setError(data.message); // Using error state to display temporary messages
                                setTimeout(() => setError(null), 3000); // Clear message after 3 seconds
                            } else if (data.type === "round_result") {
                                // Handle round results, update user balance/xp/level
                                const message = data.message;
                                const winnings = data.winnings;
                                const newBalance = data.balance;
                                const newXp = data.xp;
                                const newLevel = data.level;
                                const nextLevelXp = data.next_level_xp;
                                const finalPlayerScore = data.final_player_score;
                                const finalPlayerHand = data.final_player_hand;

                                setUser(prev => ({
                                    ...prev,
                                    balance: newBalance,
                                    xp: newXp,
                                    level: newLevel,
                                    nextLevelXp: nextLevelXp,
                                    blackjackStatus: 'round_end', // Ensure status is round_end
                                    blackjackDealerHand: data.final_dealer_hand || [], // Dealer hand might be empty if no dealer
                                    blackjackDealerScore: data.final_dealer_score || 0,
                                    blackjackPlayers: prev.blackjackPlayers.map(p => 
                                        p.user_id === user.userId ? { ...p, hand: finalPlayerHand, score: finalPlayerScore } : p
                                    )
                                }));
                                setError(`${message} –í–∏–≥—Ä–∞—à: ${winnings}. –ë–∞–ª–∞–Ω—Å: ${newBalance}`);
                                setTimeout(() => setError(null), 5000); // Clear message after 5 seconds
                                sendTelegramLog(`WS Round Result: ${message}, Winnings: ${winnings}`, 'JS_LOG');

                            } else if (data.type === "level_up") {
                                setError(`üéâ –ù–û–í–ò–ô –†–Ü–í–ï–ù–¨: ${data.level}! üéâ`);
                                setTimeout(() => setError(null), 5000);
                                sendTelegramLog(`WS Level Up: ${data.level}`, 'JS_LOG');
                            }
                            else {
                                // This is a general room state update
                                setUser(prev => ({
                                    ...prev,
                                    blackjackRoom: data.room_id,
                                    blackjackPlayers: data.players,
                                    blackjackStatus: data.status,
                                    blackjackCurrentPlayerTurn: data.current_player_turn,
                                    blackjackTimer: data.timer,
                                    blackjackDealerHand: data.dealer_hand,
                                    blackjackDealerScore: data.dealer_score,
                                }));
                                // sendTelegramLog(`WS State Update: Status=${data.status}, Timer=${data.timer}`, 'JS_DEBUG');
                            }
                        } catch (e) {
                            sendTelegramLog(`WS Error parsing message: ${e.message}, Data: ${event.data.substring(0, 100)}`, 'JS_ERROR');
                            setError("–ü–æ–º–∏–ª–∫–∞ –æ–±—Ä–æ–±–∫–∏ –¥–∞–Ω–∏—Ö –≥—Ä–∏.");
                        }
                    };

                    wsRef.current.onclose = (event) => {
                        sendTelegramLog(`WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason}`, 'JS_WARN');
                        setUser(prev => ({ ...prev, blackjackStatus: 'disconnected' }));
                        // Attempt to reconnect after a delay
                        if (wsReconnectAttempts.current < MAX_WS_RECONNECT_ATTEMPTS) {
                            wsReconnectAttempts.current++;
                            const delay = Math.min(1000 * wsReconnectAttempts.current, 5000); // Exponential backoff up to 5 seconds
                            sendTelegramLog(`Attempting to reconnect WS in ${delay / 1000} seconds (attempt ${wsReconnectAttempts.current}).`, 'JS_LOG');
                            wsReconnectTimeout.current = setTimeout(() => connectBlackjackWebSocket(), delay);
                        } else {
                            sendTelegramLog('Max WebSocket reconnect attempts reached. Please refresh.', 'JS_ERROR');
                            setError('–í—ñ–¥–∫–ª—é—á–µ–Ω–æ –≤—ñ–¥ –≥—Ä–∏. –°–ø—Ä–æ–±—É–π—Ç–µ –æ–Ω–æ–≤–∏—Ç–∏ —Å—Ç–æ—Ä—ñ–Ω–∫—É.');
                        }
                    };

                    wsRef.current.onerror = (error) => {
                        sendTelegramLog(`WebSocket error: ${error.message || error}`, 'JS_ERROR');
                        setError('–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ –≥—Ä–∏.');
                        wsRef.current.close(); // Force close to trigger onclose and reconnect logic
                    };

                } catch (e) {
                    sendTelegramLog(`Failed to establish WS connection: ${e.message}`, 'JS_FATAL_REACT_ERROR');
                    setError('–ù–µ –≤–¥–∞–ª–æ—Å—è –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è –¥–æ –≥—Ä–∏. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ.');
                }
            }, [user.userId, sendWsMessage]);

            // Fetch user data from backend
            const fetchUserData = useCallback(async () => {
                if (!user.userId) {
                    sendTelegramLog('fetchUserData: User ID not available, skipping fetch.', 'JS_DEBUG');
                    return;
                }
                setLoading(true);
                setError(null);
                try {
                    sendTelegramLog(`Fetching user data from ${API_BASE_URL}/api/get_balance for userId: ${user.userId}`, 'JS_LOG');
                    const response = await fetch(`${API_BASE_URL}/api/get_balance`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ 
                            user_id: user.userId, 
                            username: Telegram.WebApp.initDataUnsafe?.user?.username || Telegram.WebApp.initDataUnsafe?.user?.first_name || 'Unnamed Player'
                        }),
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || 'Failed to fetch user data');
                    }

                    const data = await response.json();
                    setUser(prev => ({
                        ...prev,
                        username: data.username,
                        balance: data.balance,
                        xp: data.xp,
                        level: data.level,
                        nextLevelXp: data.next_level_xp,
                        lastDailyBonusClaim: data.last_daily_bonus_claim,
                        lastQuickBonusClaim: data.last_quick_bonus_claim,
                    }));
                    sendTelegramLog(`User data fetched successfully. Balance: ${data.balance}`, 'JS_LOG');
                } catch (e) {
                    sendTelegramLog(`Error fetching user data: ${e.message}`, 'JS_ERROR');
                    setError(`–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö: ${e.message}.`);
                } finally {
                    setLoading(false);
                }
            }, [user.userId]);

            // Initial setup: Get userId from Telegram WebApp
            useEffect(() => {
                if (typeof Telegram !== 'undefined' && Telegram.WebApp && Telegram.WebApp.initDataUnsafe) {
                    const tgUser = Telegram.WebApp.initDataUnsafe.user;
                    if (tgUser && tgUser.id) {
                        setUser(prev => ({ ...prev, userId: tgUser.id }));
                        sendTelegramLog(`Telegram User ID set: ${tgUser.id}`, 'JS_LOG');
                    } else {
                        sendTelegramLog('Telegram User ID not found in initDataUnsafe.', 'JS_ERROR');
                        setError('–ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ ID –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ Telegram.');
                        setLoading(false);
                    }
                } else {
                    // Fallback for local testing outside Telegram WebApp
                    const dummyUserId = localStorage.getItem('dummyUserId') || '123456789';
                    localStorage.setItem('dummyUserId', dummyUserId);
                    setUser(prev => ({ ...prev, userId: parseInt(dummyUserId) }));
                    sendTelegramLog('Running outside Telegram WebApp, using dummy user ID.', 'JS_WARN');
                    setLoading(false);
                }
            }, []);

            // Effect to fetch user data when userId is available
            useEffect(() => {
                if (user.userId) {
                    fetchUserData();
                }
            }, [user.userId, fetchUserData]);

            // Effect to connect WebSocket when userId is available and not already connected
            useEffect(() => {
                let isMounted = true; // Flag to track if component is mounted

                const initWebSocket = async () => {
                    if (user.userId && !wsRef.current) { // Only connect if userId is available and WS not initialized
                        sendTelegramLog('Attempting initial WebSocket connection from useEffect.', 'JS_DEBUG');
                        await connectBlackjackWebSocket();
                    }
                };

                initWebSocket();

                // Cleanup function for WebSocket on component unmount
                return () => {
                    isMounted = false;
                    if (wsRef.current) {
                        sendTelegramLog('Closing WebSocket on component unmount.', 'JS_LOG');
                        wsRef.current.close();
                        wsRef.current = null;
                    }
                    if (wsReconnectTimeout.current) {
                        clearTimeout(wsReconnectTimeout.current);
                        wsReconnectTimeout.current = null;
                    }
                };
            }, [user.userId, connectBlackjackWebSocket]); // Depend on user.userId and connectBlackjackWebSocket

            const value = {
                user,
                loading,
                error,
                fetchUserData,
                sendWsMessage, // Expose sendWsMessage for components
                connectBlackjackWebSocket, // Expose connectBlackjackWebSocket for manual reconnect if needed
            };

            return (
                <UserContext.Provider value={value}>
                    {children}
                </UserContext.Provider>
            );
        };

        // --- Components ---

        const BalanceDisplay = () => {
            const { user, loading, error } = useContext(UserContext);

            if (loading) return <p className="text-center text-gray-400">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</p>;
            if (error) return <p className="text-center text-red-400">{error}</p>;

            const progress = user.level === 0 ? 0 : ((user.xp - (user.level > 1 ? (user.level - 1) * 100 : 0)) / (user.nextLevelXp - (user.level > 1 ? (user.level - 1) * 100 : 0))) * 100;

            return (
                <div className="w-full max-w-md bg-gray-800 p-4 rounded-xl shadow-lg text-center mb-4 border border-yellow-500">
                    <h2 className="text-xl font-bold text-yellow-400 mb-2">–Ü–º–ø–µ—Ä—ñ—è –°–ª–æ—Ç–∞</h2>
                    <p className="text-lg text-white mb-1">–ü—Ä–∏–≤—ñ—Ç, <span className="font-semibold">{user.username}</span>!</p>
                    <p className="text-2xl font-bold text-green-400 mb-2">
                        –ë–ê–õ–ê–ù–°: <span className="text-yellow-300">{user.balance}</span> –§–ê–ù–¢–ò–ö–Ü–í
                    </p>
                    <div className="text-sm text-gray-300 mb-2">
                        –†–Ü–í–ï–ù–¨: <span className="font-bold">{user.level}</span> | XP: <span className="font-bold">{user.xp}/{user.nextLevelXp}</span>
                    </div>
                    <div className="w-full bg-gray-700 rounded-full h-2.5 mb-4">
                        <div className="bg-blue-600 h-2.5 rounded-full" style={{ width: `${progress}%` }}></div>
                    </div>
                </div>
            );
        };

        const GameButton = ({ icon, text, onClick }) => (
            <button
                onClick={onClick}
                className="flex flex-col items-center justify-center p-3 m-2 bg-blue-600 hover:bg-blue-700 text-white rounded-xl shadow-md transition-all duration-200 ease-in-out transform hover:scale-105 active:scale-95 w-28 h-28 text-sm font-semibold"
            >
                <i className={`${icon} text-3xl mb-1`}></i>
                <span>{text}</span>
            </button>
        );

        const SlotMachine = () => {
            const { user, fetchUserData, loading, error: contextError } = useContext(UserContext);
            const [symbols, setSymbols] = useState(['?', '?', '?']);
            const [message, setMessage] = useState('');
            const [isSpinning, setIsSpinning] = useState(false);
            const [localError, setLocalError] = useState(null);

            const handleSpin = async () => {
                if (isSpinning || loading || user.balance < 100) return; // Basic check, backend will validate

                setIsSpinning(true);
                setLocalError(null);
                setMessage('');

                // Simple animation: rapidly change symbols
                let animationInterval = setInterval(() => {
                    setSymbols([
                        ['üçí', 'üçã', 'üçä', 'üçá', 'üîî', 'üíé', 'üçÄ', '‚≠ê', 'üí∞'][Math.floor(Math.random() * 9)],
                        ['üçí', 'üçã', 'üçä', 'üçá', 'üîî', 'üíé', 'üçÄ', '‚≠ê', 'üí∞'][Math.floor(Math.random() * 9)],
                        ['üçí', 'üçã', 'üçä', 'üçá', 'üîî', 'üíé', 'üçÄ', '‚≠ê', 'üí∞'][Math.floor(Math.random() * 9)]
                    ]);
                }, 100);

                try {
                    const response = await fetch(`${API_BASE_URL}/api/spin`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.userId }),
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || '–ü–æ–º–∏–ª–∫–∞ —Å–ø—ñ–Ω–∞.');
                    }

                    const data = await response.json();
                    clearInterval(animationInterval); // Stop animation
                    setSymbols(data.symbols);
                    setMessage(data.message || (data.winnings > 0 ? `–í–∏ –≤–∏–≥—Ä–∞–ª–∏ ${data.winnings} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤!` : '–í–∏ –ø—Ä–æ–≥—Ä–∞–ª–∏.'));
                    fetchUserData(); // Update user data globally
                    sendTelegramLog(`Slot spin result: Winnings=${data.winnings}, Balance=${data.balance}`, 'JS_LOG');
                } catch (e) {
                    clearInterval(animationInterval); // Stop animation on error
                    setSymbols(['?', '?', '?']); // Reset symbols
                    setLocalError(e.message);
                    sendTelegramLog(`Slot spin error: ${e.message}`, 'JS_ERROR');
                } finally {
                    setIsSpinning(false);
                }
            };

            return (
                <div className="w-full max-w-md bg-gray-800 p-6 rounded-xl shadow-lg mb-4 border border-pink-500">
                    <h3 className="text-xl font-bold text-center text-pink-400 mb-4">–°–ª–æ—Ç-–ú–∞—à–∏–Ω–∞</h3>
                    <div className="flex justify-around items-center text-5xl mb-6 bg-gray-900 p-4 rounded-lg border border-gray-700">
                        {symbols.map((s, i) => (
                            <span key={i} className="slot-symbol animate-bounce-once">{s}</span>
                        ))}
                    </div>
                    <button
                        onClick={handleSpin}
                        disabled={isSpinning || loading || user.balance < 100}
                        className={`w-full py-3 rounded-xl text-lg font-bold transition-all duration-200 ease-in-out shadow-lg
                            ${isSpinning || loading || user.balance < 100
                                ? 'bg-gray-600 cursor-not-allowed'
                                : 'bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 transform hover:scale-105 active:scale-95'
                            }`}
                    >
                        {isSpinning ? '–ö—Ä—É—Ç–∏—Ç—å—Å—è...' : `–ö—Ä—É—Ç–∏—Ç–∏ –∑–∞ 100 —Ñ–∞–Ω—Ç–∏–∫—ñ–≤`}
                    </button>
                    {message && <p className="mt-4 text-center text-green-400 font-semibold">{message}</p>}
                    {localError && <p className="mt-4 text-center text-red-400 font-semibold">{localError}</p>}
                </div>
            );
        };

        const CoinFlip = () => {
            const { user, fetchUserData, loading, error: contextError } = useContext(UserContext);
            const [result, setResult] = useState(null);
            const [message, setMessage] = useState('');
            const [isFlipping, setIsFlipping] = useState(false);
            const [localError, setLocalError] = useState(null);

            const handleFlip = async (choice) => {
                if (isFlipping || loading || user.balance < 50) return;

                setIsFlipping(true);
                setLocalError(null);
                setMessage('');
                setResult(null);

                try {
                    const response = await fetch(`${API_BASE_URL}/api/coin_flip`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.userId, choice }),
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || '–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥–∫–∏–¥–∞–Ω–Ω—è –º–æ–Ω–µ—Ç–∫–∏.');
                    }

                    const data = await response.json();
                    setResult(data.result); // 'heads' or 'tails'
                    setMessage(data.message);
                    fetchUserData();
                    sendTelegramLog(`Coin flip result: ${data.result}, Winnings: ${data.winnings}`, 'JS_LOG');
                } catch (e) {
                    setLocalError(e.message);
                    sendTelegramLog(`Coin flip error: ${e.message}`, 'JS_ERROR');
                } finally {
                    setIsFlipping(false);
                }
            };

            return (
                <div className="w-full max-w-md bg-gray-800 p-6 rounded-xl shadow-lg mb-4 border border-blue-500">
                    <h3 className="text-xl font-bold text-center text-blue-400 mb-4">–ü—ñ–¥–∫–∏–¥–∞–Ω–Ω—è –ú–æ–Ω–µ—Ç–∫–∏</h3>
                    <div className="flex justify-center items-center text-6xl mb-6 h-20">
                        {isFlipping ? (
                            <i className="fas fa-sync fa-spin text-gray-400"></i> // Spinner icon
                        ) : (
                            result === 'heads' ? 'ü™ô' : (result === 'tails' ? 'ü™ô' : '‚ùì') // Coin emoji for heads/tails
                        )}
                    </div>
                    <div className="flex justify-around gap-4 mb-4">
                        <button
                            onClick={() => handleFlip('heads')}
                            disabled={isFlipping || loading || user.balance < 50}
                            className={`flex-1 py-3 rounded-xl text-lg font-bold transition-all duration-200 ease-in-out shadow-lg
                                ${isFlipping || loading || user.balance < 50
                                    ? 'bg-gray-600 cursor-not-allowed'
                                    : 'bg-gradient-to-r from-purple-500 to-indigo-600 hover:from-purple-600 hover:to-indigo-700 transform hover:scale-105 active:scale-95'
                                }`}
                        >
                            –û—Ä–µ–ª
                        </button>
                        <button
                            onClick={() => handleFlip('tails')}
                            disabled={isFlipping || loading || user.balance < 50}
                            className={`flex-1 py-3 rounded-xl text-lg font-bold transition-all duration-200 ease-in-out shadow-lg
                                ${isFlipping || loading || user.balance < 50
                                    ? 'bg-gray-600 cursor-not-allowed'
                                    : 'bg-gradient-to-r from-purple-500 to-indigo-600 hover:from-purple-600 hover:to-indigo-700 transform hover:scale-105 active:scale-95'
                                }`}
                        >
                            –†–µ—à–∫–∞
                        </button>
                    </div>
                    <p className="text-center text-sm text-gray-300 mb-4">–í–∞—Ä—Ç—ñ—Å—Ç—å: 50 —Ñ–∞–Ω—Ç–∏–∫—ñ–≤</p>
                    {message && <p className="mt-4 text-center text-green-400 font-semibold">{message}</p>}
                    {localError && <p className="mt-4 text-center text-red-400 font-semibold">{localError}</p>}
                </div>
            );
        };

        const BonusClaimer = () => {
            const { user, fetchUserData, loading, error: contextError } = useContext(UserContext);
            const [dailyMessage, setDailyMessage] = useState('');
            const [quickMessage, setQuickMessage] = useState('');
            const [dailyError, setDailyError] = useState(null);
            const [quickError, setQuickError] = useState(null);

            const calculateTimeLeft = (lastClaim, cooldownHours, cooldownMinutes = 0) => {
                if (!lastClaim) return { hours: 0, minutes: 0, seconds: 0, available: true };

                const lastClaimDate = new Date(lastClaim);
                const cooldownDurationMs = (cooldownHours * 3600 + cooldownMinutes * 60) * 1000;
                const nextClaimTime = lastClaimDate.getTime() + cooldownDurationMs;
                const now = Date.now();
                const timeLeftMs = nextClaimTime - now;

                if (timeLeftMs <= 0) return { hours: 0, minutes: 0, seconds: 0, available: true };

                const hours = Math.floor(timeLeftMs / (1000 * 60 * 60));
                const minutes = Math.floor((timeLeftMs % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeLeftMs % (1000 * 60)) / 1000);
                return { hours, minutes, seconds, available: false };
            };

            const dailyBonusTimeLeft = calculateTimeLeft(user.lastDailyBonusClaim, 24);
            const quickBonusTimeLeft = calculateTimeLeft(user.lastQuickBonusClaim, 0, 15);

            const handleClaimBonus = async (type) => {
                const endpoint = type === 'daily' ? 'claim_daily_bonus' : 'claim_quick_bonus';
                const setMessage = type === 'daily' ? setDailyMessage : setQuickMessage;
                const setError = type === 'daily' ? setDailyError : setQuickError;

                setMessage('');
                setError(null);

                try {
                    const response = await fetch(`${API_BASE_URL}/api/${endpoint}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.userId }),
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || '–ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –±–æ–Ω—É—Å—É.');
                    }

                    const data = await response.json();
                    setMessage(`–í–∏ –æ—Ç—Ä–∏–º–∞–ª–∏ ${data.amount} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤!`);
                    fetchUserData(); // Update user data globally
                    sendTelegramLog(`Claimed ${type} bonus. Amount: ${data.amount}`, 'JS_LOG');
                } catch (e) {
                    setError(e.message);
                    sendTelegramLog(`Error claiming ${type} bonus: ${e.message}`, 'JS_ERROR');
                }
            };

            // Update timers every second
            useEffect(() => {
                const interval = setInterval(() => {
                    fetchUserData(); // Re-fetch all user data to update timers
                }, 1000);
                return () => clearInterval(interval);
            }, [fetchUserData]);


            return (
                <div className="w-full max-w-md bg-gray-800 p-6 rounded-xl shadow-lg mb-4 border border-orange-500">
                    <h3 className="text-xl font-bold text-center text-orange-400 mb-4">–ë–æ–Ω—É—Å–∏</h3>
                    <div className="mb-4">
                        <button
                            onClick={() => handleClaimBonus('daily')}
                            disabled={!dailyBonusTimeLeft.available || loading}
                            className={`w-full py-3 rounded-xl text-lg font-bold transition-all duration-200 ease-in-out shadow-lg mb-2
                                ${!dailyBonusTimeLeft.available || loading
                                    ? 'bg-gray-600 cursor-not-allowed'
                                    : 'bg-gradient-to-r from-yellow-500 to-orange-600 hover:from-yellow-600 hover:to-orange-700 transform hover:scale-105 active:scale-95'
                                }`}
                        >
                            –©–æ–¥–µ–Ω–Ω–∞ –í–∏–Ω–∞–≥–æ—Ä–æ–¥–∞ ({dailyBonusTimeLeft.available ? '–î–æ—Å—Ç—É–ø–Ω–æ' : `${dailyBonusTimeLeft.hours} –≥–æ–¥ ${dailyBonusTimeLeft.minutes} —Ö–≤`})
                        </button>
                        {dailyMessage && <p className="text-center text-green-400 text-sm">{dailyMessage}</p>}
                        {dailyError && <p className="text-center text-red-400 text-sm">{dailyError}</p>}
                    </div>
                    <div>
                        <button
                            onClick={() => handleClaimBonus('quick')}
                            disabled={!quickBonusTimeLeft.available || loading}
                            className={`w-full py-3 rounded-xl text-lg font-bold transition-all duration-200 ease-in-out shadow-lg
                                ${!quickBonusTimeLeft.available || loading
                                    ? 'bg-gray-600 cursor-not-allowed'
                                    : 'bg-gradient-to-r from-red-500 to-pink-600 hover:from-red-600 hover:to-pink-700 transform hover:scale-105 active:scale-95'
                                }`}
                        >
                            –®–≤–∏–¥–∫–∏–π –ë–æ–Ω—É—Å ({quickBonusTimeLeft.available ? '–î–æ—Å—Ç—É–ø–Ω–æ' : `${quickBonusTimeLeft.minutes} —Ö–≤ ${quickBonusTimeLeft.seconds} —Å–µ–∫`})
                        </button>
                        {quickMessage && <p className="mt-2 text-center text-green-400 text-sm">{quickMessage}</p>}
                        {quickError && <p className="mt-2 text-center text-red-400 text-sm">{quickError}</p>}
                    </div>
                </div>
            );
        };

        const BlackjackGame = () => {
            const { user, sendWsMessage, error: contextError, fetchUserData } = useContext(UserContext);
            const [betAmount, setBetAmount] = useState(100); // Default bet
            const [localError, setLocalError] = useState(null);

            const playersInRoom = user.blackjackPlayers;
            const currentPlayerTurn = user.blackjackCurrentPlayerTurn;
            const isMyTurn = currentPlayerTurn === user.userId;
            const myPlayerState = playersInRoom.find(p => p.user_id === user.userId);
            const isPlayerActive = myPlayerState?.is_playing;
            const hasPlayerBet = myPlayerState?.has_bet;

            const handleBet = () => {
                if (user.blackjackStatus !== 'betting' || hasPlayerBet) {
                    setLocalError('–ó–∞—Ä–∞–∑ –Ω–µ –º–æ–∂–Ω–∞ —Ä–æ–±–∏—Ç–∏ —Å—Ç–∞–≤–∫–∏ –∞–±–æ –≤–∏ –≤–∂–µ –ø–æ—Å—Ç–∞–≤–∏–ª–∏.');
                    setTimeout(() => setLocalError(null), 3000);
                    return;
                }
                if (betAmount <= 0 || betAmount > user.balance) {
                    setLocalError('–ù–µ–≤—ñ—Ä–Ω–∞ —Å—É–º–∞ —Å—Ç–∞–≤–∫–∏ –∞–±–æ –Ω–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —Ñ–∞–Ω—Ç–∏–∫—ñ–≤.');
                    setTimeout(() => setLocalError(null), 3000);
                    return;
                }
                sendWsMessage("bet", { amount: betAmount });
                setLocalError(null); // Clear previous errors
            };

            const handleAction = (action) => {
                if (user.blackjackStatus !== 'playing' || !isMyTurn || !isPlayerActive) {
                    setLocalError('–ó–∞—Ä–∞–∑ –Ω–µ –≤–∞—à —Ö—ñ–¥ –∞–±–æ –≤–∏ –Ω–µ –±–µ—Ä–µ—Ç–µ —É—á–∞—Å—Ç—å —É —Ä–∞—É–Ω–¥—ñ.');
                    setTimeout(() => setLocalError(null), 3000);
                    return;
                }
                sendWsMessage(action);
                setLocalError(null); // Clear previous errors
            };

            const getStatusMessage = () => {
                switch (user.blackjackStatus) {
                    case 'waiting':
                        return `–û—á—ñ–∫—É–≤–∞–Ω–Ω—è –≥—Ä–∞–≤—Ü—ñ–≤ (${user.blackjackPlayers.length}/${user.min_players})...`;
                    case 'starting_timer':
                        return `–ì—Ä–∞ –ø–æ—á–Ω–µ—Ç—å—Å—è —á–µ—Ä–µ–∑ ${user.blackjackTimer} —Å–µ–∫.`;
                    case 'betting':
                        return `–†–æ–±—ñ—Ç—å —Å—Ç–∞–≤–∫–∏! –ó–∞–ª–∏—à–∏–ª–æ—Å—å ${user.blackjackTimer} —Å–µ–∫.`;
                    case 'playing':
                        if (isMyTurn) {
                            return `–í–∞—à —Ö—ñ–¥! –ó–∞–ª–∏—à–∏–ª–æ—Å—å ${user.blackjackTimer} —Å–µ–∫.`;
                        } else {
                            const currentTurnPlayer = playersInRoom.find(p => p.user_id === currentPlayerTurn);
                            return `–•—ñ–¥ –≥—Ä–∞–≤—Ü—è ${currentTurnPlayer?.username || '...'}.`;
                        }
                    case 'round_end':
                        return `–†–∞—É–Ω–¥ –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –†–µ–∑—É–ª—å—Ç–∞—Ç–∏...`;
                    case 'disconnected':
                        return `–í—ñ–¥–∫–ª—é—á–µ–Ω–æ –≤—ñ–¥ –≥—Ä–∏. –°–ø—Ä–æ–±—É–π—Ç–µ –æ–Ω–æ–≤–∏—Ç–∏.`;
                    default:
                        return `–°—Ç–∞—Ç—É—Å: ${user.blackjackStatus}`;
                }
            };

            // Update user balance/xp after round end, if not already handled by round_result message
            useEffect(() => {
                if (user.blackjackStatus === 'round_end') {
                    fetchUserData(); // Ensure balance/xp is updated from DB
                }
            }, [user.blackjackStatus, fetchUserData]);

            // Display players in the room
            const renderPlayers = () => {
                return playersInRoom.map(player => (
                    <div 
                        key={player.user_id} 
                        className={`p-3 rounded-lg mb-2 shadow-md ${player.user_id === user.userId ? 'bg-blue-700 border-2 border-yellow-400' : 'bg-gray-700'}
                            ${player.user_id === currentPlayerTurn ? 'animate-pulse border-green-400 border-2' : ''}
                            ${!player.is_playing ? 'opacity-50 line-through' : ''}
                        `}
                    >
                        <p className="font-semibold text-lg">{player.username} {player.user_id === user.userId ? '(–í–∏)' : ''}</p>
                        <p className="text-sm text-gray-300">
                            –ö–∞—Ä—Ç–∏: {player.hand.length > 0 ? player.hand.join(', ') : '–ù–µ–º–∞—î'} | 
                            –†–∞—Ö—É–Ω–æ–∫: {player.score} | 
                            –°—Ç–∞–≤–∫–∞: {player.bet} | 
                            {player.has_bet ? ' –°—Ç–∞–≤–∫–∞ –∑—Ä–æ–±–ª–µ–Ω–∞' : ' –û—á—ñ–∫—É–≤–∞–Ω–Ω—è —Å—Ç–∞–≤–∫–∏'}
                            {!player.is_playing && ' (–ù–µ –≥—Ä–∞—î)'}
                        </p>
                    </div>
                ));
            };

            return (
                <div className="w-full max-w-md bg-gray-800 p-6 rounded-xl shadow-lg border border-green-500 flex flex-col items-center">
                    <h3 className="text-xl font-bold text-center text-green-400 mb-4">–ë–ª–µ–∫–¥–∂–µ–∫</h3>
                    <div className="text-center w-full mb-4">
                        <p className="text-lg font-semibold text-white">{getStatusMessage()}</p>
                        {contextError && <p className="text-red-400 text-sm mt-1">{contextError}</p>}
                        {localError && <p className="text-red-400 text-sm mt-1">{localError}</p>}
                    </div>

                    {/* Dealer's Hand (hidden until round_end/dealer_turn) */}
                    {user.blackjackStatus === 'round_end' || user.blackjackStatus === 'dealer_turn' ? (
                        <div className="w-full bg-gray-900 p-3 rounded-lg mb-4 border border-gray-600">
                            <p className="font-semibold text-lg text-red-300">–î–∏–ª–µ—Ä</p>
                            <p className="text-sm text-gray-300">
                                –ö–∞—Ä—Ç–∏: {user.blackjackDealerHand.join(', ')} | –†–∞—Ö—É–Ω–æ–∫: {user.blackjackDealerScore}
                            </p>
                        </div>
                    ) : (
                        <div className="w-full bg-gray-900 p-3 rounded-lg mb-4 border border-gray-600">
                             <p className="font-semibold text-lg text-red-300">–î–∏–ª–µ—Ä</p>
                            <p className="text-sm text-gray-300">
                                –ö–∞—Ä—Ç–∏: {user.blackjackDealerHand.length > 0 ? user.blackjackDealerHand[0] + ', ??' : '–ù–µ–º–∞—î'} | –†–∞—Ö—É–Ω–æ–∫: ?
                            </p>
                        </div>
                    )}

                    {/* Players in room */}
                    <div className="w-full mb-4 max-h-48 overflow-y-auto custom-scrollbar">
                        {renderPlayers()}
                    </div>

                    {/* Betting/Action Controls */}
                    {user.blackjackStatus === 'betting' && !hasPlayerBet && isPlayerActive && (
                        <div className="w-full flex flex-col items-center gap-2 mt-4">
                            <input
                                type="number"
                                value={betAmount}
                                onChange={(e) => setBetAmount(Math.max(0, parseInt(e.target.value) || 0))}
                                min="1"
                                max={user.balance}
                                className="w-full p-2 rounded-md bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
                            />
                            <button
                                onClick={handleBet}
                                className="w-full py-2 rounded-xl text-lg font-bold bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 transition-all duration-200 ease-in-out transform hover:scale-105 active:scale-95 shadow-lg"
                            >
                                –ó—Ä–æ–±–∏—Ç–∏ —Å—Ç–∞–≤–∫—É ({betAmount})
                            </button>
                        </div>
                    )}

                    {user.blackjackStatus === 'playing' && isMyTurn && isPlayerActive && (
                        <div className="w-full flex justify-around gap-4 mt-4">
                            <button
                                onClick={() => handleAction('hit')}
                                className="flex-1 py-3 rounded-xl text-lg font-bold bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 transition-all duration-200 ease-in-out transform hover:scale-105 active:scale-95 shadow-lg"
                            >
                                –í–∑—è—Ç–∏ –∫–∞—Ä—Ç—É
                            </button>
                            <button
                                onClick={() => handleAction('stand')}
                                className="flex-1 py-3 rounded-xl text-lg font-bold bg-gradient-to-r from-red-500 to-orange-600 hover:from-red-600 hover:to-orange-700 transition-all duration-200 ease-in-out transform hover:scale-105 active:scale-95 shadow-lg"
                            >
                                –ó—É–ø–∏–Ω–∏—Ç–∏—Å—å
                            </button>
                        </div>
                    )}
                    
                    {/* Reconnect button if disconnected */}
                    {user.blackjackStatus === 'disconnected' && (
                        <button
                            onClick={user.connectBlackjackWebSocket}
                            className="w-full py-3 rounded-xl text-lg font-bold bg-gradient-to-r from-blue-500 to-cyan-600 hover:from-blue-600 hover:to-cyan-700 transition-all duration-200 ease-in-out transform hover:scale-105 active:scale-95 shadow-lg mt-4"
                        >
                            –ü—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—å –¥–æ –≥—Ä–∏
                        </button>
                    )}
                </div>
            );
        };


        const App = () => {
            const [activeGame, setActiveGame] = useState('blackjack'); // Default to blackjack

            const renderGame = () => {
                switch (activeGame) {
                    case 'slots':
                        return <SlotMachine />;
                    case 'coin_flip':
                        return <CoinFlip />;
                    case 'blackjack':
                        return <BlackjackGame />;
                    default:
                        return <BlackjackGame />;
                }
            };

            return (
                <div className="flex flex-col items-center justify-start w-full h-full p-4 overflow-y-auto custom-scrollbar">
                    <BalanceDisplay />
                    <BonusClaimer />

                    {/* Game Selection Buttons */}
                    <div className="flex justify-center flex-wrap gap-4 mb-6 w-full max-w-md">
                        <GameButton icon="fas fa-gem" text="–ë–ª–µ–∫–¥–∂–µ–∫" onClick={() => setActiveGame('blackjack')} />
                        <GameButton icon="fas fa-dice" text="–ú–æ–Ω–µ—Ç–∫–∞" onClick={() => setActiveGame('coin_flip')} />
                        <GameButton icon="fas fa-slots" text="–°–ª–æ—Ç–∏" onClick={() => setActiveGame('slots')} />
                    </div>

                    {renderGame()}

                    <style jsx>{`
                        /* Custom scrollbar for better aesthetics */
                        .custom-scrollbar::-webkit-scrollbar {
                            width: 8px;
                        }
                        .custom-scrollbar::-webkit-scrollbar-track {
                            background: #2d3748; /* gray-800 */
                            border-radius: 10px;
                        }
                        .custom-scrollbar::-webkit-scrollbar-thumb {
                            background: #4a5568; /* gray-700 */
                            border-radius: 10px;
                        }
                        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
                            background: #6b7280; /* gray-600 */
                        }

                        /* Basic animation for slot symbols */
                        @keyframes bounce-once {
                            0%, 100% {
                                transform: translateY(0);
                            }
                            20% {
                                transform: translateY(-5px);
                            }
                            40% {
                                transform: translateY(0);
                            }
                            60% {
                                transform: translateY(-2px);
                            }
                            80% {
                                transform: translateY(0);
                            }
                        }
                        .slot-symbol {
                            display: inline-block;
                            animation: none; /* Default to no animation */
                        }
                        .slot-symbol:nth-child(1) { animation-delay: 0s; }
                        .slot-symbol:nth-child(2) { animation-delay: 0.1s; }
                        .slot-symbol:nth-child(3) { animation-delay: 0.2s; }

                        /* Apply animation when spinning (you'd toggle a class in JS) */
                        .is-spinning .slot-symbol {
                            animation: bounce-once 0.6s ease-in-out forwards;
                        }
                    `}</style>
                </div>
            );
        };

        // --- Root Render ---
        try {
            const rootElement = document.getElementById('root');
            if (!rootElement) {
                sendTelegramLog('Root element not found in DOM.', 'JS_FATAL_REACT_MOUNT_ERROR');
                document.body.innerHTML = `<p class="text-red-500 text-center mt-10 text-lg">
                    –ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞: –ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ –µ–ª–µ–º–µ–Ω—Ç #root.
                </p>`;
            } else {
                const initialMessage = document.getElementById('initialLoadingMessage');
                if (initialMessage) {
                    initialMessage.textContent = '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É...';
                }

                const root = ReactDOM.createRoot(rootElement);
                root.render(
                    <React.StrictMode>
                        <UserProvider>
                            <App />
                        </UserProvider>
                    </React.StrictMode>
                );

                if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                    Telegram.WebApp.sendData('JS_LOG: React app rendered successfully into DOM.');
                }
            }
        } catch (e) {
            console.error("Error during final React mounting:", e);
            const rootElement = document.getElementById('root');
            if (rootElement) {
                rootElement.innerHTML = `<p class="text-red-500 text-center mt-10 text-lg">
                    –ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫—É –≥—Ä–∏: <br/> ${e.message}
                    <br/> –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –∫–æ–Ω—Å–æ–ª—å –±—Ä–∞—É–∑–µ—Ä–∞ –∞–±–æ –ª–æ–≥–∏ Render.
                </p>`;
            }
            if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                Telegram.WebApp.sendData(`JS_FATAL_REACT_MOUNT_ERROR: ${e.message.substring(0, Math.min(e.message.length, 100))}`);
            }
        }
    </script>
</body>
</html>
