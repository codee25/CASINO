<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>–Ü–º–ø–µ—Ä—ñ—è –°–ª–æ—Ç–∞: –í—ñ—Ä—Ç—É–∞–ª—å–Ω–µ –ö–∞–∑–∏–Ω–æ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="./style.css">
    <!-- Third-party libraries that need to be globally available -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body class="flex flex-col items-center justify-between w-screen h-screen bg-gradient-to-br from-purple-900 via-gray-900 to-indigo-900 text-white overflow-hidden">
    <div id="root" class="relative w-full h-full flex flex-col items-center justify-start">
        <!-- React App will be mounted here -->
        <p id="initialLoadingMessage" class="text-xl text-white mt-10">
            –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≥—Ä–∏... –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞—á–µ–∫–∞–π—Ç–µ...
        </p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "react": "https://esm.sh/react@18.2.0",
                "react-dom/client": "https://esm.sh/react-dom@18.2.0/client"
            }
        }
    </script>
    <script type="module">
        import React, { useState, useEffect, useContext, createContext, useCallback, useRef } from 'react';
        import ReactDOM from 'react-dom/client';

        // Initialize Telegram WebApp
        if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
            Telegram.WebApp.ready();
            Telegram.WebApp.expand();
            Telegram.WebApp.setHeaderColor('#6B46C1');
            Telegram.WebApp.setBackgroundColor('#0d1117');
            Telegram.WebApp.sendData('JS_VERY_FIRST_LOG: Telegram WebApp initialized and ready.');
        } else {
            console.warn('Telegram WebApp object not found. Running in standalone mode.');
        }

        // --- Global State Management for User Data ---
        const UserContext = createContext(null);

        function UserProvider({ children }) {
            const [user, setUser] = useState({
                id: null,
                username: '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...',
                balance: 0,
                xp: 0,
                level: 1,
                next_level_xp: 100,
                last_daily_bonus_claim: null,
                last_quick_bonus_claim: null
            });
            const [loadingUser, setLoadingUser] = useState(true);
            const [errorUser, setErrorUser] = useState(null);

            const API_BASE_URL = 'https://casino-0h0l.onrender.com'; // <--- –ü–ï–†–ï–í–Ü–†–¢–ï –¶–ï–ô URL!

            const fetchUserInfo = useCallback(async () => {
                if (!Telegram.WebApp.initDataUnsafe || !Telegram.WebApp.initDataUnsafe.user) {
                    setErrorUser('Telegram user data not available. Please open via Telegram.');
                    setLoadingUser(false);
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData('JS_ERROR: Telegram user data missing.');
                    }
                    return;
                }

                const telegramUser = Telegram.WebApp.initDataUnsafe.user;
                const userId = telegramUser.id;
                const username = telegramUser.username || telegramUser.first_name || 'Unnamed Player';

                try {
                    const response = await fetch(`${API_BASE_URL}/api/get_balance`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: userId, username: username })
                    });
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    setUser({
                        id: userId,
                        username: data.username,
                        balance: data.balance,
                        xp: data.xp,
                        level: data.level,
                        next_level_xp: data.next_level_xp,
                        last_daily_bonus_claim: data.last_daily_bonus_claim ? new Date(data.last_daily_bonus_claim) : null,
                        last_quick_bonus_claim: data.last_quick_bonus_claim ? new Date(data.last_quick_bonus_claim) : null
                    });
                    setLoadingUser(false);
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData(`JS_LOG: User ${userId} data fetched: Balance ${data.balance}, XP ${data.xp}, Level ${data.level}`);
                    }
                } catch (error) {
                    console.error('Error fetching user info:', error);
                    setErrorUser(`Failed to load user data: ${error.message}`);
                    setLoadingUser(false);
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData(`JS_ERROR: Failed to fetch user data: ${error.message.substring(0, Math.min(error.message.length, 100))}`);
                    }
                }
            }, []);

            useEffect(() => {
                fetchUserInfo();
            }, [fetchUserInfo]);

            const updateBalance = useCallback((amount) => {
                setUser(prev => ({ ...prev, balance: prev.balance + amount }));
                fetchUserInfo(); // Re-fetch to ensure consistency with DB
            }, [fetchUserInfo]);

            const updateXP = useCallback((amount) => {
                setUser(prev => ({ ...prev, xp: prev.xp + amount }));
                fetchUserInfo(); // Re-fetch to ensure consistency with DB
            }, [fetchUserInfo]);

            return (
                <UserContext.Provider value={{ user, loadingUser, errorUser, fetchUserInfo, updateBalance, updateXP }}>
                    {children}
                </UserContext.Provider>
            );
        }

        // Modal Component
        const Modal = ({ children, onClose, title }) => {
            return (
                <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
                    <div className="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm relative">
                        <h3 className="text-xl font-bold text-white mb-4">{title}</h3>
                        <button
                            onClick={onClose}
                            className="absolute top-3 right-3 text-gray-400 hover:text-white text-2xl font-bold"
                        >
                            &times;
                        </button>
                        {children}
                    </div>
                </div>
            );
        };

        // Message Box Component
        const MessageBox = ({ message, type = 'info', onClose }) => {
            const bgColor = type === 'error' ? 'bg-red-600' : type === 'success' ? 'bg-green-600' : 'bg-blue-600';
            return (
                <Modal title={type === 'error' ? '–ü–æ–º–∏–ª–∫–∞' : type === 'success' ? '–£—Å–ø—ñ—Ö' : '–Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è'} onClose={onClose}>
                    <div className={`p-4 rounded-lg ${bgColor} text-white text-center`}>
                        <p>{message}</p>
                        <button
                            onClick={onClose}
                            className="mt-4 px-4 py-2 bg-white bg-opacity-20 rounded-md hover:bg-opacity-30 transition-colors"
                        >
                            –ó–∞–∫—Ä–∏—Ç–∏
                        </button>
                    </div>
                </Modal>
            );
        };

        // Global Message State
        const MessageContext = createContext(null);

        function MessageProvider({ children }) {
            const [message, setMessage] = useState(null);

            const showMessage = useCallback((msg, type = 'info') => {
                setMessage({ text: msg, type });
            }, []);

            const clearMessage = useCallback(() => {
                setMessage(null);
            }, []);

            return (
                <MessageContext.Provider value={{ showMessage, clearMessage }}>
                    {children}
                    {message && <MessageBox message={message.text} type={message.type} onClose={clearMessage} />}
                </MessageContext.Provider>
            );
        }

        // --- Main App Component ---
        function App() {
            const { user, loadingUser, errorUser, fetchUserInfo } = useContext(UserContext);
            const { showMessage } = useContext(MessageContext);
            const [activeGame, setActiveGame] = useState(null); // 'slot', 'coin_flip', 'blackjack', null
            const [showLeaderboard, setShowLeaderboard] = useState(false);

            useEffect(() => {
                if (errorUser) {
                    showMessage(errorUser, 'error');
                }
            }, [errorUser, showMessage]);

            if (loadingUser) {
                return (
                    <div className="flex flex-col items-center justify-center h-full">
                        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-500"></div>
                        <p className="mt-4 text-white">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞...</p>
                    </div>
                );
            }

            if (errorUser && !loadingUser) {
                return (
                    <div className="flex flex-col items-center justify-center h-full text-red-500 text-center p-4">
                        <p className="text-xl font-bold">–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è!</p>
                        <p className="mt-2">{errorUser}</p>
                        <button
                            onClick={fetchUserInfo}
                            className="mt-4 px-6 py-2 bg-blue-600 text-white rounded-lg shadow-md hover:bg-blue-700 transition-colors"
                        >
                            –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –∑–Ω–æ–≤—É
                        </button>
                    </div>
                );
            }

            return (
                <div className="relative w-full h-full flex flex-col items-center justify-start p-4 pb-20 overflow-auto">
                    {/* Header */}
                    <div className="w-full max-w-md bg-gray-800 bg-opacity-80 rounded-xl p-4 mb-4 shadow-lg flex flex-col items-center">
                        <h1 className="text-3xl font-extrabold text-yellow-400 mb-2 drop-shadow-lg">–Ü–ú–ü–ï–†–Ü–Ø –°–õ–û–¢–ê</h1>
                        <div className="text-center mb-4">
                            <p className="text-lg text-gray-300">–í—ñ—Ç–∞—î–º–æ, <span className="font-semibold text-white">{user.username}</span>!</p>
                            <p className="text-2xl font-bold text-white">–ë–∞–ª–∞–Ω—Å: <span className="text-yellow-300">{user.balance}</span> —Ñ–∞–Ω—Ç–∏–∫—ñ–≤</p>
                            <p className="text-md text-gray-400">–†—ñ–≤–µ–Ω—å: <span className="font-semibold text-blue-300">{user.level}</span> (XP: <span className="text-green-300">{user.xp}/{user.next_level_xp}</span>)</p>
                        </div>
                        <div className="flex space-x-2 w-full justify-center">
                            <DailyBonusButton />
                            <QuickBonusButton />
                        </div>
                    </div>

                    {/* Game Selection */}
                    <div className="w-full max-w-md bg-gray-800 bg-opacity-80 rounded-xl p-4 shadow-lg flex flex-col items-center flex-grow">
                        <h2 className="text-2xl font-bold text-purple-300 mb-4">–û–±–µ—Ä—ñ—Ç—å –≥—Ä—É:</h2>
                        <div className="grid grid-cols-1 gap-4 w-full">
                            <GameButton title="üé∞ –°–ª–æ—Ç–∏" onClick={() => setActiveGame('slot')} />
                            <GameButton title="ü™ô –ü—ñ–¥–∫–∏–¥–∞–Ω–Ω—è –ú–æ–Ω–µ—Ç–∫–∏" onClick={() => setActiveGame('coin_flip')} />
                            <GameButton title="‚ô†Ô∏è –ë–ª–µ–∫–¥–∂–µ–∫" onClick={() => setActiveGame('blackjack')} />
                        </div>
                        <button
                            onClick={() => setShowLeaderboard(true)}
                            className="mt-6 w-full px-6 py-3 bg-indigo-700 text-white font-bold rounded-xl shadow-lg hover:bg-indigo-800 transition-all transform hover:scale-105"
                        >
                            üèÜ –î–æ—à–∫–∞ –õ—ñ–¥–µ—Ä—ñ–≤
                        </button>
                    </div>

                    {/* Game Modals */}
                    {activeGame === 'slot' && <SlotMachine onClose={() => setActiveGame(null)} />}
                    {activeGame === 'coin_flip' && <CoinFlipGame onClose={() => setActiveGame(null)} />}
                    {activeGame === 'blackjack' && <BlackjackGame onClose={() => setActiveGame(null)} />}
                    {showLeaderboard && <LeaderboardModal onClose={() => setShowLeaderboard(false)} />}
                </div>
            );
        }

        const GameButton = ({ title, onClick }) => (
            <button
                onClick={onClick}
                className="w-full px-6 py-3 bg-purple-700 text-white text-xl font-bold rounded-xl shadow-lg hover:bg-purple-800 transition-all transform hover:scale-105"
            >
                {title}
            </button>
        );

        // --- Slot Machine Game ---
        const SlotMachine = ({ onClose }) => {
            const { user, fetchUserInfo } = useContext(UserContext);
            const { showMessage } = useContext(MessageContext);
            const [reels, setReels] = useState(['?', '?', '?']);
            const [spinning, setSpinning] = useState(false);
            const [lastWin, setLastWin] = useState(0);
            const BET_AMOUNT = 100;
            const symbols = ['üçí', 'üçã', 'üçä', 'üçá', 'üîî', 'üíé', 'üçÄ', '‚≠ê', 'üí∞']; // All possible symbols

            const spinSound = useRef(null);
            const winSound = useRef(null);
            const loseSound = useRef(null);

            useEffect(() => {
                // Initialize Tone.js for sounds
                if (typeof Tone !== 'undefined') {
                    spinSound.current = new Tone.Player("https://assets.mixkit.co/sfx/preview/mixkit-mechanical-slot-machine-spin-1961.mp3").toDestination();
                    winSound.current = new Tone.Player("https://assets.mixkit.co/sfx/preview/mixkit-game-level-win-689.mp3").toDestination();
                    loseSound.current = new Tone.Player("https://assets.mixkit.co/sfx/preview/mixkit-arcade-retro-game-over-213.mp3").toDestination();
                }
            }, []);

            const handleSpin = async () => {
                if (spinning) return;
                if (user.balance < BET_AMOUNT) {
                    showMessage(`–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —Ñ–∞–Ω—Ç–∏–∫—ñ–≤! –ü–æ—Ç—Ä—ñ–±–Ω–æ ${BET_AMOUNT}. –í–∞—à –±–∞–ª–∞–Ω—Å: ${user.balance}`, 'error');
                    return;
                }

                setSpinning(true);
                setLastWin(0);
                if (spinSound.current) {
                    spinSound.current.start();
                }

                try {
                    const response = await fetch(`${API_BASE_URL}/api/spin`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.id })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    
                    // GSAP animation for reels
                    const reelElements = document.querySelectorAll('.symbol-reel');
                    const spinDuration = 2; // seconds

                    const finalSymbols = data.symbols;
                    const animationPromises = Array.from(reelElements).map((reel, index) => {
                        return new Promise(resolve => {
                            const initialPosition = 0;
                            const targetPosition = -2000 - (symbols.indexOf(finalSymbols[index]) * 80); // Spin multiple times + land on target
                            
                            gsap.to(reel, {
                                y: targetPosition,
                                duration: spinDuration + (index * 0.2), // Stagger spins
                                ease: "power2.out",
                                onComplete: () => {
                                    reel.style.transform = `translateY(${targetPosition % (symbols.length * 80)}px)`; // Reset position visually
                                    reel.innerHTML = finalSymbols[index]; // Set final symbol
                                    resolve();
                                }
                            });
                        });
                    });

                    await Promise.all(animationPromises); // Wait for all reels to stop

                    setReels(data.symbols);
                    setLastWin(data.winnings);
                    fetchUserInfo(); // Update balance, XP, level

                    if (data.winnings > 0) {
                        if (winSound.current) winSound.current.start();
                        showMessage(`üéâ –í–∏ –≤–∏–≥—Ä–∞–ª–∏ ${data.winnings} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤! ${data.message}`, 'success');
                    } else {
                        if (loseSound.current) loseSound.current.start();
                        showMessage(`–°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑! ${data.message}`, 'info');
                    }

                } catch (error) {
                    console.error('Error during spin:', error);
                    showMessage(`–ü–æ–º–∏–ª–∫–∞ —Å–ø—ñ–Ω–∞: ${error.message}`, 'error');
                } finally {
                    setSpinning(false);
                    if (spinSound.current && spinSound.current.state === 'started') {
                        spinSound.current.stop();
                    }
                }
            };

            return (
                <Modal title="üé∞ –°–ª–æ—Ç–∏" onClose={onClose}>
                    <div className="flex flex-col items-center justify-center p-4 bg-gray-900 rounded-lg shadow-inner">
                        <div className="flex space-x-2 mb-6 bg-gray-700 p-4 rounded-lg shadow-md">
                            {reels.map((symbol, index) => (
                                <div key={index} className="overflow-hidden w-20 h-20 bg-gray-800 rounded-lg flex items-center justify-center shadow-inner">
                                    <div className="symbol-reel text-5xl flex items-center justify-center h-full w-full" style={{ transform: 'translateY(0)' }}>
                                        {symbol}
                                    </div>
                                </div>
                            ))}
                        </div>
                        <p className="text-xl font-bold text-white mb-4">–û—Å—Ç–∞–Ω–Ω—è –≤–∏–≥—Ä–∞—à: <span className="text-green-400">{lastWin}</span> —Ñ–∞–Ω—Ç–∏–∫—ñ–≤</p>
                        <button
                            onClick={handleSpin}
                            disabled={spinning || user.balance < BET_AMOUNT}
                            className={`w-full py-3 rounded-lg text-white font-bold text-lg shadow-lg transition-all transform ${
                                spinning || user.balance < BET_AMOUNT
                                    ? 'bg-gray-600 cursor-not-allowed'
                                    : 'bg-green-600 hover:bg-green-700 hover:scale-105'
                            }`}
                        >
                            {spinning ? '–ö—Ä—É—Ç–∏—Ç—å—Å—è...' : `–ö—Ä—É—Ç–∏—Ç–∏ (${BET_AMOUNT} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤)`}
                        </button>
                    </div>
                </Modal>
            );
        };

        // --- Coin Flip Game ---
        const CoinFlipGame = ({ onClose }) => {
            const { user, fetchUserInfo } = useContext(UserContext);
            const { showMessage } = useContext(MessageContext);
            const [flipping, setFlipping] = useState(false);
            const [result, setResult] = useState(null); // 'heads' or 'tails'
            const [choice, setChoice] = useState(null); // 'heads' or 'tails'
            const [message, setMessage] = useState('');
            const BET_AMOUNT = 50;

            const flipSound = useRef(null);
            const winSound = useRef(null);
            const loseSound = useRef(null);

            useEffect(() => {
                if (typeof Tone !== 'undefined') {
                    flipSound.current = new Tone.Player("https://assets.mixkit.co/sfx/preview/mixkit-coin-flip-205.mp3").toDestination();
                    winSound.current = new Tone.Player("https://assets.mixkit.co/sfx/preview/mixkit-game-level-win-689.mp3").toDestination();
                    loseSound.current = new Tone.Player("https://assets.mixkit.co/sfx/preview/mixkit-arcade-retro-game-over-213.mp3").toDestination();
                }
            }, []);

            const handleFlip = async (playerChoice) => {
                if (flipping) return;
                if (user.balance < BET_AMOUNT) {
                    showMessage(`–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —Ñ–∞–Ω—Ç–∏–∫—ñ–≤! –ü–æ—Ç—Ä—ñ–±–Ω–æ ${BET_AMOUNT}. –í–∞—à –±–∞–ª–∞–Ω—Å: ${user.balance}`, 'error');
                    return;
                }

                setFlipping(true);
                setResult(null);
                setChoice(playerChoice);
                setMessage('');

                if (flipSound.current) flipSound.current.start();

                try {
                    const response = await fetch(`${API_BASE_URL}/api/coin_flip`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.id, choice: playerChoice })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    
                    // Simulate flip animation
                    const coinElement = document.getElementById('coin');
                    gsap.to(coinElement, {
                        rotationY: 720, // Spin twice
                        duration: 1.5,
                        ease: "power2.out",
                        onComplete: () => {
                            setResult(data.result);
                            setMessage(data.message);
                            fetchUserInfo(); // Update balance, XP, level

                            if (data.winnings > 0) {
                                if (winSound.current) winSound.current.start();
                            } else {
                                if (loseSound.current) loseSound.current.start();
                            }
                            setFlipping(false);
                        }
                    });

                } catch (error) {
                    console.error('Error during coin flip:', error);
                    showMessage(`–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥–∫–∏–¥–∞–Ω–Ω—è –º–æ–Ω–µ—Ç–∫–∏: ${error.message}`, 'error');
                    setFlipping(false);
                } finally {
                    if (flipSound.current && flipSound.current.state === 'started') {
                        flipSound.current.stop();
                    }
                }
            };

            return (
                <Modal title="ü™ô –ü—ñ–¥–∫–∏–¥–∞–Ω–Ω—è –ú–æ–Ω–µ—Ç–∫–∏" onClose={onClose}>
                    <div className="flex flex-col items-center justify-center p-4 bg-gray-900 rounded-lg shadow-inner">
                        <div id="coin" className={`text-6xl mb-6 transform transition-transform duration-500 ${flipping ? 'animate-spin-y' : ''}`}>
                            {result === 'heads' ? 'ü™ô' : result === 'tails' ? 'üí∞' : '‚ùì'}
                        </div>
                        <p className="text-xl text-white mb-4">{message || '–û–±–µ—Ä—ñ—Ç—å –û—Ä–µ–ª –∞–±–æ –†–µ—à–∫–∞'}</p>
                        <div className="flex space-x-4 mb-6">
                            <button
                                onClick={() => handleFlip('heads')}
                                disabled={flipping || user.balance < BET_AMOUNT}
                                className={`px-6 py-3 rounded-lg text-white font-bold text-lg shadow-lg transition-all transform ${
                                    flipping || user.balance < BET_AMOUNT
                                        ? 'bg-gray-600 cursor-not-allowed'
                                        : 'bg-blue-600 hover:bg-blue-700 hover:scale-105'
                                }`}
                            >
                                –û—Ä–µ–ª
                            </button>
                            <button
                                onClick={() => handleFlip('tails')}
                                disabled={flipping || user.balance < BET_AMOUNT}
                                className={`px-6 py-3 rounded-lg text-white font-bold text-lg shadow-lg transition-all transform ${
                                    flipping || user.balance < BET_AMOUNT
                                        ? 'bg-gray-600 cursor-not-allowed'
                                        : 'bg-red-600 hover:bg-red-700 hover:scale-105'
                                }`}
                            >
                                –†–µ—à–∫–∞
                            </button>
                        </div>
                        <p className="text-lg text-gray-300">–°—Ç–∞–≤–∫–∞: {BET_AMOUNT} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤</p>
                    </div>
                </Modal>
            );
        };

        // --- Blackjack Game ---
        const BlackjackGame = ({ onClose }) => {
            const { user, fetchUserInfo } = useContext(UserContext);
            const { showMessage } = useContext(MessageContext);
            const [ws, setWs] = useState(null);
            const [roomState, setRoomState] = useState(null);
            const [betAmount, setBetAmount] = useState(100); // Default bet
            const [message, setMessage] = useState('');
            const [isConnected, setIsConnected] = useState(false);
            const reconnectAttempts = useRef(0);
            const MAX_RECONNECT_ATTEMPTS = 5;
            const RECONNECT_DELAY_MS = 2000;

            const connectWebSocket = useCallback(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    console.log("WebSocket is already open.");
                    return;
                }
                if (!user.id) {
                    console.warn("User ID not available for WebSocket connection.");
                    return;
                }

                const WS_BASE_URL = API_BASE_URL.replace('https://', 'wss://');
                const newWs = new WebSocket(`${WS_BASE_URL}/ws/${user.id}`);
                console.log(`[WS] Attempting to connect to ${WS_BASE_URL}/ws/${user.id}`);
                if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                    Telegram.WebApp.sendData(`JS_DEBUG: Attempting WS connect to ${WS_BASE_URL}/ws/${user.id}`);
                }

                newWs.onopen = () => {
                    console.log('[WS] Connected to WebSocket.');
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData('JS_LOG: WebSocket connected.');
                    }
                    setIsConnected(true);
                    reconnectAttempts.current = 0; // Reset attempts on successful connection
                    newWs.send(JSON.stringify({ action: "request_state" })); // Request initial state
                    console.log('[WS] Sent request_state on open.');
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData('JS_DEBUG: Sent request_state on WS open.');
                    }
                };

                newWs.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('[WS] Received message:', data);
                        if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                            Telegram.WebApp.sendData(`JS_DEBUG: WS received: ${JSON.stringify(data).substring(0, Math.min(JSON.stringify(data).length, 100))}`);
                        }

                        if (data.type === 'ping') {
                            newWs.send(JSON.stringify({ type: 'pong' }));
                            console.log('[WS] Sent pong.');
                        } else if (data.type === 'error') {
                            showMessage(data.message, 'error');
                            setMessage(data.message);
                        } else if (data.type === 'game_message') {
                            showMessage(data.message, 'info');
                            setMessage(data.message);
                        } else if (data.type === 'round_result') {
                            showMessage(data.message, data.winnings > 0 ? 'success' : 'info');
                            setMessage(data.message);
                            fetchUserInfo(); // Update user balance, XP, level after round
                            setRoomState(data); // Update state with final round data
                        } else if (data.type === 'level_up') {
                            showMessage(`üéâ –í—ñ—Ç–∞—î–º–æ! –í–∏ –¥–æ—Å—è–≥–ª–∏ —Ä—ñ–≤–Ω—è ${data.level}!`, 'success');
                            fetchUserInfo(); // Fetch updated user data
                        } else {
                            // This is likely a room state update
                            setRoomState(data);
                            // Clear messages that are not related to current game flow (e.g. old error messages)
                            if (data.status === 'betting' || data.status === 'playing') {
                                setMessage(''); 
                            }
                        }
                    } catch (e) {
                        console.error('[WS] Error parsing message or handling data:', e, event.data);
                        if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                            Telegram.WebApp.sendData(`JS_ERROR: WS message error: ${e.message.substring(0, Math.min(e.message.length, 100))}`);
                        }
                        showMessage(`–ü–æ–º–∏–ª–∫–∞ –æ–±—Ä–æ–±–∫–∏ –¥–∞–Ω–∏—Ö –≤—ñ–¥ —Å–µ—Ä–≤–µ—Ä–∞: ${e.message}`, 'error');
                    }
                };

                newWs.onclose = (event) => {
                    setIsConnected(false);
                    console.log('[WS] Disconnected from WebSocket:', event.code, event.reason);
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData(`JS_WARN: WebSocket disconnected: Code ${event.code}, Reason: ${event.reason.substring(0, Math.min(event.reason.length, 100))}`);
                    }
                    // Attempt to reconnect
                    if (reconnectAttempts.current < MAX_RECONNECT_ATTEMPTS) {
                        reconnectAttempts.current++;
                        console.log(`[WS] Attempting reconnect ${reconnectAttempts.current}/${MAX_RECONNECT_ATTEMPTS}...`);
                        if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                            Telegram.WebApp.sendData(`JS_DEBUG: WS reconnect attempt ${reconnectAttempts.current}.`);
                        }
                        setTimeout(connectWebSocket, RECONNECT_DELAY_MS);
                    } else {
                        showMessage('–ó\'—î–¥–Ω–∞–Ω–Ω—è –∑ –≥—Ä–æ—é –≤—Ç—Ä–∞—á–µ–Ω–æ. –ë—É–¥—å –ª–∞—Å–∫–∞, —Å–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ.', 'error');
                        if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                            Telegram.WebApp.sendData('JS_ERROR: Max WS reconnect attempts reached.');
                        }
                    }
                };

                newWs.onerror = (error) => {
                    console.error('[WS] WebSocket error:', error);
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData(`JS_ERROR: WebSocket error: ${error.message || 'Unknown error'}`);
                    }
                    newWs.close(); // Close immediately on error to trigger onclose
                };

                setWs(newWs);
            }, [user.id, showMessage]);

            useEffect(() => {
                if (user.id && !ws) {
                    connectWebSocket();
                }
                // Cleanup on component unmount
                return () => {
                    if (ws) {
                        console.log('[WS] Closing WebSocket on component unmount.');
                        ws.close();
                        setWs(null);
                        setIsConnected(false);
                    }
                };
            }, [user.id, ws, connectWebSocket]);

            const sendWebSocketMessage = (action, payload = {}) => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    const messageToSend = { action, user_id: user.id, room_id: roomState?.room_id, ...payload };
                    ws.send(JSON.stringify(messageToSend));
                    console.log('[WS] Sent message:', messageToSend);
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData(`JS_DEBUG: WS sent: ${JSON.stringify(messageToSend).substring(0, Math.min(JSON.stringify(messageToSend).length, 100))}`);
                    }
                } else {
                    showMessage('–ó\'—î–¥–Ω–∞–Ω–Ω—è –∑ —Å–µ—Ä–≤–µ—Ä–æ–º –Ω–µ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ. –°–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è.', 'error');
                    console.warn('[WS] WebSocket not open. State:', ws?.readyState);
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData('JS_WARN: WS not open for sending.');
                    }
                    // Attempt to reconnect if not connected
                    if (!isConnected) {
                        connectWebSocket();
                    }
                }
            };

            const handleBet = () => {
                if (user.balance < betAmount) {
                    showMessage(`–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —Ñ–∞–Ω—Ç–∏–∫—ñ–≤! –ü–æ—Ç—Ä—ñ–±–Ω–æ ${betAmount}. –í–∞—à –±–∞–ª–∞–Ω—Å: ${user.balance}`, 'error');
                    return;
                }
                sendWebSocketMessage('bet', { amount: betAmount });
            };

            const handleHit = () => {
                sendWebSocketMessage('hit');
            };

            const handleStand = () => {
                sendWebSocketMessage('stand');
            };

            const getPlayerById = (playerId) => roomState?.players.find(p => p.user_id === playerId);
            const currentPlayer = getPlayerById(user.id);
            const isMyTurn = roomState?.current_player_turn === user.id;
            const isBettingPhase = roomState?.status === 'betting';
            const isPlayingPhase = roomState?.status === 'playing';
            const isWaitingPhase = roomState?.status === 'waiting' || roomState?.status === 'starting_timer';
            const isRoundEndPhase = roomState?.status === 'round_end';

            const canBet = isBettingPhase && !currentPlayer?.has_bet && user.balance >= betAmount;
            const canHitOrStand = isPlayingPhase && isMyTurn && currentPlayer?.is_playing;

            return (
                <Modal title="‚ô†Ô∏è –ë–ª–µ–∫–¥–∂–µ–∫" onClose={onClose}>
                    <div className="flex flex-col items-center justify-center p-4 bg-gray-900 rounded-lg shadow-inner text-white">
                        {!isConnected && (
                            <div className="text-red-400 mb-4 text-center">
                                <p>–ó\'—î–¥–Ω–∞–Ω–Ω—è –≤—Ç—Ä–∞—á–µ–Ω–æ –∞–±–æ –≤—Å—Ç–∞–Ω–æ–≤–ª—é—î—Ç—å—Å—è...</p>
                                <button
                                    onClick={connectWebSocket}
                                    className="mt-2 px-4 py-2 bg-blue-600 rounded-md hover:bg-blue-700 transition-colors"
                                >
                                    –ü–µ—Ä–µ–ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è
                                </button>
                            </div>
                        )}

                        {roomState ? (
                            <>
                                <p className="text-lg mb-2">–ö—ñ–º–Ω–∞—Ç–∞: <span className="font-bold text-yellow-300">{roomState.room_id}</span></p>
                                <p className="text-md mb-4">–ì—Ä–∞–≤—Ü—ñ–≤: {roomState.player_count}/{roomState.max_players} (–ú—ñ–Ω: {roomState.min_players})</p>

                                {isWaitingPhase && (
                                    <p className="text-center text-gray-300 mb-4">
                                        –û—á—ñ–∫—É–≤–∞–Ω–Ω—è –≥—Ä–∞–≤—Ü—ñ–≤... ({roomState.timer > 0 ? `–ì—Ä–∞ –ø–æ—á–Ω–µ—Ç—å—Å—è —á–µ—Ä–µ–∑ ${roomState.timer} —Å–µ–∫.` : '–ó–∞—á–µ–∫–∞–π—Ç–µ'})
                                    </p>
                                )}
                                {isBettingPhase && (
                                    <div className="mb-4 text-center">
                                        <p className="text-yellow-300 text-xl font-bold">–ó—Ä–æ–±—ñ—Ç—å –≤–∞—à—É —Å—Ç–∞–≤–∫—É!</p>
                                        <p className="text-gray-400 text-sm">–¢–∞–π–º–µ—Ä —Å—Ç–∞–≤–æ–∫: {roomState.timer} —Å–µ–∫.</p>
                                        <input
                                            type="number"
                                            value={betAmount}
                                            onChange={(e) => setBetAmount(Math.max(1, parseInt(e.target.value) || 1))}
                                            min="1"
                                            className="mt-2 p-2 w-24 bg-gray-700 text-white rounded-md text-center"
                                            disabled={!canBet}
                                        />
                                        <button
                                            onClick={handleBet}
                                            disabled={!canBet}
                                            className={`mt-2 ml-2 px-4 py-2 rounded-lg text-white font-bold transition-all transform ${
                                                canBet ? 'bg-green-600 hover:bg-green-700 hover:scale-105' : 'bg-gray-600 cursor-not-allowed'
                                            }`}
                                        >
                                            –°—Ç–∞–≤–∫–∞ ({betAmount})
                                        </button>
                                        {currentPlayer?.has_bet && !currentPlayer?.is_playing && (
                                            <p className="text-red-300 mt-2">–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —Ñ–∞–Ω—Ç–∏–∫—ñ–≤ –¥–ª—è —Å—Ç–∞–≤–∫–∏. –í–∏ –Ω–µ –±–µ—Ä–µ—Ç–µ —É—á–∞—Å—Ç—å —É —Ü—å–æ–º—É —Ä–∞—É–Ω–¥—ñ.</p>
                                        )}
                                        {currentPlayer?.has_bet && currentPlayer?.is_playing && (
                                            <p className="text-green-300 mt-2">–í–∞—à–∞ —Å—Ç–∞–≤–∫–∞ –ø—Ä–∏–π–Ω—è—Ç–∞. –û—á—ñ–∫—É—î–º–æ —ñ–Ω—à–∏—Ö –≥—Ä–∞–≤—Ü—ñ–≤.</p>
                                        )}
                                    </div>
                                )}
                                {isPlayingPhase && (
                                    <p className="text-center text-blue-300 text-xl font-bold mb-4">
                                        {isMyTurn ? '–í–∞—à —Ö—ñ–¥!' : `–•—ñ–¥ –≥—Ä–∞–≤—Ü—è ${roomState.players.find(p => p.user_id === roomState.current_player_turn)?.username || '–ù–µ–≤—ñ–¥–æ–º–∏–π'}`}
                                    </p>
                                )}
                                {isRoundEndPhase && (
                                    <p className="text-center text-yellow-300 text-xl font-bold mb-4">–†–∞—É–Ω–¥ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!</p>
                                )}

                                {message && (
                                    <p className="text-center text-lg font-semibold mb-4 text-purple-300">{message}</p>
                                )}

                                {/* Players' Hands */}
                                <div className="w-full grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                                    {roomState.players.map(player => (
                                        <div
                                            key={player.user_id}
                                            className={`p-4 rounded-lg shadow-md ${player.user_id === user.id ? 'bg-blue-800 border-2 border-blue-500' : 'bg-gray-800'} ${roomState.current_player_turn === player.user_id ? 'border-4 border-yellow-500 animate-pulse' : ''}`}
                                        >
                                            <p className="font-bold text-lg mb-1">
                                                {player.username} {player.user_id === user.id ? '(–í–∏)' : ''}
                                            </p>
                                            <p className="text-sm text-gray-300">–°—Ç–∞–≤–∫–∞: {player.bet}</p>
                                            <p className="text-sm text-gray-300">–†–∞—Ö—É–Ω–æ–∫: {player.score} {player.is_busted ? '(–ü–µ—Ä–µ–±—ñ—Ä!)' : ''}</p>
                                            <div className="flex flex-wrap gap-1 mt-2">
                                                {player.hand.length > 0 ? (
                                                    player.hand.map((card, idx) => (
                                                        <span key={idx} className="bg-gray-700 px-2 py-1 rounded-md text-sm">
                                                            {card}
                                                        </span>
                                                    ))
                                                ) : (
                                                    <span className="text-gray-500">–ù–µ–º–∞—î –∫–∞—Ä—Ç</span>
                                                )}
                                            </div>
                                            {!player.is_playing && player.has_bet && player.score <= 21 && roomState.status === 'playing' && (
                                                <p className="text-green-400 text-sm mt-2">–ó—É–ø–∏–Ω–∏–≤—Å—è</p>
                                            )}
                                        </div>
                                    ))}
                                </div>

                                {/* Actions */}
                                {isPlayingPhase && isMyTurn && currentPlayer?.is_playing && (
                                    <div className="flex space-x-4 mt-4">
                                        <button
                                            onClick={handleHit}
                                            disabled={!canHitOrStand}
                                            className={`px-6 py-3 rounded-lg text-white font-bold text-lg shadow-lg transition-all transform ${
                                                canHitOrStand ? 'bg-blue-600 hover:bg-blue-700 hover:scale-105' : 'bg-gray-600 cursor-not-allowed'
                                            }`}
                                        >
                                            –í–∑—è—Ç–∏ –∫–∞—Ä—Ç—É
                                        </button>
                                        <button
                                            onClick={handleStand}
                                            disabled={!canHitOrStand}
                                            className={`px-6 py-3 rounded-lg text-white font-bold text-lg shadow-lg transition-all transform ${
                                                canHitOrStand ? 'bg-red-600 hover:bg-red-700 hover:scale-105' : 'bg-gray-600 cursor-not-allowed'
                                            }`}
                                        >
                                            –ó—É–ø–∏–Ω–∏—Ç–∏—Å—å
                                        </button>
                                    </div>
                                )}
                            </>
                        ) : (
                            <p className="text-center text-gray-400">–ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ –∫—ñ–º–Ω–∞—Ç–∏ –ë–ª–µ–∫–¥–∂–µ–∫—É...</p>
                        )}
                    </div>
                </Modal>
            );
        };

        // --- Daily Bonus Component ---
        const DailyBonusButton = () => {
            const { user, fetchUserInfo } = useContext(UserContext);
            const { showMessage } = useContext(MessageContext);
            const [cooldownTime, setCooldownTime] = useState(null);
            const DAILY_BONUS_AMOUNT = 300; // Must match backend

            useEffect(() => {
                if (user.last_daily_bonus_claim) {
                    const lastClaim = user.last_daily_bonus_claim;
                    const nextClaimTime = new Date(lastClaim.getTime() + (24 * 60 * 60 * 1000)); // 24 hours
                    const now = new Date();
                    if (now < nextClaimTime) {
                        setCooldownTime(nextClaimTime);
                    } else {
                        setCooldownTime(null);
                    }
                } else {
                    setCooldownTime(null);
                }
            }, [user.last_daily_bonus_claim]);

            useEffect(() => {
                const interval = setInterval(() => {
                    if (cooldownTime) {
                        const now = new Date();
                        if (now >= cooldownTime) {
                            setCooldownTime(null);
                            fetchUserInfo(); // Refresh user data to enable button
                        }
                    }
                }, 1000); // Update every second

                return () => clearInterval(interval);
            }, [cooldownTime, fetchUserInfo]);

            const formatTimeLeft = (endTime) => {
                const now = new Date();
                const timeLeftMs = endTime - now;
                if (timeLeftMs <= 0) return '–ì–æ—Ç–æ–≤–æ!';

                const hours = Math.floor(timeLeftMs / (1000 * 60 * 60));
                const minutes = Math.floor((timeLeftMs % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeLeftMs % (1000 * 60)) / 1000);
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            };

            const handleClaim = async () => {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/claim_daily_bonus`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.id })
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    showMessage(`+${data.amount} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤! ${data.message}`, 'success');
                    fetchUserInfo(); // Update user data and cooldown
                } catch (error) {
                    console.error('Error claiming daily bonus:', error);
                    showMessage(`–ü–æ–º–∏–ª–∫–∞: ${error.message}`, 'error');
                }
            };

            const isButtonDisabled = cooldownTime !== null;

            return (
                <button
                    onClick={handleClaim}
                    disabled={isButtonDisabled}
                    className={`flex-1 px-4 py-2 rounded-lg text-white font-bold transition-all transform ${
                        isButtonDisabled
                            ? 'bg-gray-600 cursor-not-allowed'
                            : 'bg-blue-600 hover:bg-blue-700 hover:scale-105'
                    }`}
                >
                    –©–æ–¥–µ–Ω–Ω–∞ –í–∏–Ω–∞–≥–æ—Ä–æ–¥–∞ {isButtonDisabled && `(${formatTimeLeft(cooldownTime)})`}
                </button>
            );
        };

        // --- Quick Bonus Component ---
        const QuickBonusButton = () => {
            const { user, fetchUserInfo } = useContext(UserContext);
            const { showMessage } = useContext(MessageContext);
            const [cooldownTime, setCooldownTime] = useState(null);
            const QUICK_BONUS_AMOUNT = 100; // Must match backend

            useEffect(() => {
                if (user.last_quick_bonus_claim) {
                    const lastClaim = user.last_quick_bonus_claim;
                    const nextClaimTime = new Date(lastClaim.getTime() + (15 * 60 * 1000)); // 15 minutes
                    const now = new Date();
                    if (now < nextClaimTime) {
                        setCooldownTime(nextClaimTime);
                    } else {
                        setCooldownTime(null);
                    }
                } else {
                    setCooldownTime(null);
                }
            }, [user.last_quick_bonus_claim]);

            useEffect(() => {
                const interval = setInterval(() => {
                    if (cooldownTime) {
                        const now = new Date();
                        if (now >= cooldownTime) {
                            setCooldownTime(null);
                            fetchUserInfo(); // Refresh user data to enable button
                        }
                    }
                }, 1000); // Update every second

                return () => clearInterval(interval);
            }, [cooldownTime, fetchUserInfo]);

            const formatTimeLeft = (endTime) => {
                const now = new Date();
                const timeLeftMs = endTime - now;
                if (timeLeftMs <= 0) return '–ì–æ—Ç–æ–≤–æ!';

                const minutes = Math.floor((timeLeftMs % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeLeftMs % (1000 * 60)) / 1000);
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            };

            const handleClaim = async () => {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/claim_quick_bonus`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.id })
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    showMessage(`+${data.amount} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤! ${data.message}`, 'success');
                    fetchUserInfo(); // Update user data and cooldown
                } catch (error) {
                    console.error('Error claiming quick bonus:', error);
                    showMessage(`–ü–æ–º–∏–ª–∫–∞: ${error.message}`, 'error');
                }
            };

            const isButtonDisabled = cooldownTime !== null;

            return (
                <button
                    onClick={handleClaim}
                    disabled={isButtonDisabled}
                    className={`flex-1 px-4 py-2 rounded-lg text-white font-bold transition-all transform ${
                        isButtonDisabled
                            ? 'bg-gray-600 cursor-not-allowed'
                            : 'bg-red-600 hover:bg-red-700 hover:scale-105'
                    }`}
                >
                    –®–≤–∏–¥–∫–∏–π –ë–æ–Ω—É—Å {isButtonDisabled && `(${formatTimeLeft(cooldownTime)})`}
                </button>
            );
        };

        // --- Leaderboard Modal ---
        const LeaderboardModal = ({ onClose }) => {
            const { showMessage } = useContext(MessageContext);
            const [leaderboard, setLeaderboard] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);

            const fetchLeaderboard = useCallback(async () => {
                setLoading(true);
                setError(null);
                try {
                    const response = await fetch(`${API_BASE_URL}/api/get_leaderboard`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({}) // No body needed for this endpoint
                    });
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    setLeaderboard(data.leaderboard);
                } catch (err) {
                    console.error('Error fetching leaderboard:', err);
                    setError(`–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ª—ñ–¥–µ—Ä–±–æ—Ä–¥—É: ${err.message}`);
                    showMessage(`–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –ª—ñ–¥–µ—Ä–±–æ—Ä–¥—É: ${err.message}`, 'error');
                } finally {
                    setLoading(false);
                }
            }, [showMessage]);

            useEffect(() => {
                fetchLeaderboard();
            }, [fetchLeaderboard]);

            return (
                <Modal title="üèÜ –î–æ—à–∫–∞ –õ—ñ–¥–µ—Ä—ñ–≤" onClose={onClose}>
                    <div className="bg-gray-900 rounded-lg p-4 max-h-96 overflow-y-auto">
                        {loading && <p className="text-center text-gray-400">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</p>}
                        {error && <p className="text-center text-red-400">{error}</p>}
                        {!loading && !error && leaderboard.length === 0 && (
                            <p className="text-center text-gray-400">–î–æ—à–∫–∞ –ª—ñ–¥–µ—Ä—ñ–≤ –ø–æ—Ä–æ–∂–Ω—è.</p>
                        )}
                        {!loading && !error && leaderboard.length > 0 && (
                            <ul className="space-y-2">
                                {leaderboard.map((entry, index) => (
                                    <li key={entry.user_id} className="flex items-center justify-between bg-gray-800 p-3 rounded-md shadow-sm">
                                        <span className="font-bold text-purple-300 mr-2">{index + 1}.</span>
                                        <div className="flex-1">
                                            <p className="text-white font-semibold">{entry.username}</p>
                                            <p className="text-sm text-blue-300">ID: {entry.user_id}</p>
                                        </div>
                                        <div className="text-right">
                                            <p className="text-white">{entry.balance} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤</p>
                                            <p className="text-sm text-gray-400">–†—ñ–≤–µ–Ω—å {entry.level} (XP: {entry.xp})</p>
                                        </div>
                                    </li>
                                ))}
                            </ul>
                        )}
                    </div>
                </Modal>
            );
        };

        // --- Root Render ---
        const rootElement = document.getElementById('root');
        const initialMessage = document.getElementById('initialLoadingMessage');

        if (!Telegram.WebApp.initDataUnsafe || !Telegram.WebApp.initDataUnsafe.user) {
            if (rootElement) {
                rootElement.innerHTML = `
                    <p class="text-red-500 text-center mt-10 text-lg">
                        –¶–µ –¥–æ–¥–∞—Ç–æ–∫ Telegram Mini App. –ë—É–¥—å –ª–∞—Å–∫–∞, –≤—ñ–¥–∫—Ä–∏–π—Ç–µ –π–æ–≥–æ —á–µ—Ä–µ–∑ Telegram.
                    </p>
                    <p class="text-gray-400 text-center mt-4">
                        –Ø–∫—â–æ –≤–∏ —Ä–æ–∑—Ä–æ–±–Ω–∏–∫, –ø–µ—Ä–µ–≤—ñ—Ä—Ç–µ, —á–∏ –≤–∞—à Telegram WebApp SDK –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ —Ç–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ.
                    </p>
                `;
            }
            if (initialMessage) {
                initialMessage.remove();
            }
            console.error("Telegram WebApp initDataUnsafe or user is missing. Cannot proceed.");
        } else {
            // Remove loading message
            if (initialMessage) {
                initialMessage.remove();
            }
            
            try {
                const root = ReactDOM.createRoot(rootElement);
                root.render(
                    <React.StrictMode>
                        <MessageProvider>
                            <UserProvider>
                                <App />
                            </UserProvider>
                        </MessageProvider>
                    </React.StrictMode>
                );

                if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                    Telegram.WebApp.sendData('JS_LOG: React app rendered successfully into DOM.');
                }
            } catch (e) {
                console.error("Error during final React mounting:", e);
                if (rootElement) {
                    rootElement.innerHTML = `<p class="text-red-500 text-center mt-10 text-lg">
                        –ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫—É –≥—Ä–∏: <br/> ${e.message}
                        <br/> –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –∫–æ–Ω—Å–æ–ª—å –±—Ä–∞—É–∑–µ—Ä–∞ –∞–±–æ –ª–æ–≥–∏ Render.
                    </p>`;
                }
                if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                    Telegram.WebApp.sendData(`JS_FATAL_REACT_MOUNT_ERROR: ${e.message.substring(0, Math.min(e.message.length, 100))}`);
                }
            }
        }
    </script>
</body>
</html>
