<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>–Ü–º–ø–µ—Ä—ñ—è –°–ª–æ—Ç–∞: –í—ñ—Ä—Ç—É–∞–ª—å–Ω–µ –ö–∞–∑–∏–Ω–æ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="./style.css">
    <!-- Third-party libraries that need to be globally available -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body class="flex flex-col items-center justify-between w-screen h-screen bg-gradient-to-br from-purple-900 via-gray-900 to-indigo-900 text-white overflow-hidden">
    <div id="root" class="relative w-full h-full flex flex-col items-center justify-start">
        <!-- React App will be mounted here -->
        <p id="initialLoadingMessage" class="text-xl text-white mt-10">
            –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≥—Ä–∏... –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞—á–µ–∫–∞–π—Ç–µ.
        </p>
    </div>
    
    <!-- React and ReactDOM scripts -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>

    <!-- Your entire React App - processed by Babel in the browser -->
    <script type="text/babel" data-presets="react">
        // Log at the very beginning of this script
        if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
            Telegram.WebApp.sendData('JS_LOG: Babel script block started.');
        } else {
            console.error("JS_ERROR: Telegram.WebApp not available at Babel script block start.");
        }

        // Use window.React for unpkg.com global React
        const React = window.React;
        const { useState, useEffect, createContext, useContext, useCallback, useRef } = window.React;
        const ReactDOM = window.ReactDOM; // Ensure ReactDOM is also accessed globally

        // Ensure Tone is globally available from the CDN script in index.html
        const Tone = window.Tone || {
            context: { state: 'suspended', resume: async () => { console.warn("Tone.context.resume not available. Tone.js might not be loaded."); }, start: async () => { console.warn("Tone.context.start not available. Tone.js might not be loaded."); } },
            MembraneSynth: function() { return { toDestination: () => this, set: () => {}, triggerAttackRelease: () => {} }; },
            PolySynth: function() { return { toDestination: () => this, set: () => {}, triggerAttackRelease: () => {} }; },
            NoiseSynth: function() { return { toDestination: () => this, set: () => {}, triggerAttackRelease: () => {} }; }
        };


        // --- AudioContext Resume (for Tone.js warning) ---
        // –¶–µ –≤–∏—Ä—ñ—à—É—î –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω–Ω—è "The AudioContext was not allowed to start."
        // –ê—É–¥—ñ–æ –º–æ–∂–µ –±—É—Ç–∏ –≤—ñ–¥—Ç–≤–æ—Ä–µ–Ω–æ –ª–∏—à–µ –ø—ñ—Å–ª—è –≤–∑–∞—î–º–æ–¥—ñ—ó –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –∑—ñ —Å—Ç–æ—Ä—ñ–Ω–∫–æ—é.
        const resumeAudioContext = () => {
            if (Tone.context.state !== 'running') {
                try {
                    Tone.context.resume().then(() => {
                        sendTelegramLog('AudioContext resumed successfully.', 'JS_LOG');
                    }).catch(e => {
                        sendTelegramLog(`Failed to resume AudioContext: ${e.message}`, 'JS_ERROR');
                    });
                } catch (e) {
                    sendTelegramLog(`Error trying to resume AudioContext: ${e.message}`, 'JS_ERROR');
                }
            }
        };
        // –î–æ–¥–∞—î–º–æ –æ–±—Ä–æ–±–Ω–∏–∫ –∫–ª—ñ–∫—É –Ω–∞ –≤–µ—Å—å –¥–æ–∫—É–º–µ–Ω—Ç, —â–æ–± —Å–ø—Ä–æ–±—É–≤–∞—Ç–∏ –≤—ñ–¥–Ω–æ–≤–∏—Ç–∏ AudioContext
        document.body.addEventListener('click', resumeAudioContext, { once: true });


        // -----------------------------------------------------------------------------
        // Global User Context
        // -----------------------------------------------------------------------------
        const UserContext = createContext(null);

        const UserProvider = ({ children }) => {
            const [user, setUser] = useState({
                userId: null,
                username: 'Unnamed Player',
                balance: 0,
                xp: 0,
                level: 1,
                nextLevelXp: 100, // Default, will be updated from backend
                lastDailyBonusClaim: null,
                lastQuickBonusClaim: null
            });
            const [isLoading, setIsLoading] = useState(true);
            const [error, setError] = useState(null);
            const isFetchingRef = useRef(false);

            // Backend API URL (–í–ê–® –ê–ö–¢–£–ê–õ–¨–ù–ò–ô URL!)
            const API_BASE_URL = 'https://casino-0h0l.onrender.com'; // <--- –ó–ú–Ü–ù–Ü–¢–¨ –¶–ï–ô –†–Ø–î–û–ö!

            // Helper to send logs to Telegram bot for debugging
            const sendTelegramLog = useCallback((message, type = 'JS_LOG') => {
                if (window.Telegram && window.Telegram.WebApp) {
                    window.Telegram.WebApp.sendData(`${type}: ${message}`);
                } else {
                    console.log(`[${type}] ${message}`);
                }
            }, []);

            const fetchUserData = useCallback(async () => {
                if (isFetchingRef.current) {
                    sendTelegramLog('fetchUserData: Already fetching, skipping call.', 'JS_DEBUG');
                    return; // Prevent multiple concurrent fetches
                }

                isFetchingRef.current = true;
                setIsLoading(true);
                setError(null);
                let currentUserId = null;
                let currentUsername = 'Unnamed Player';

                if (window.Telegram && window.Telegram.WebApp) {
                    window.Telegram.WebApp.expand(); 
                    if (window.Telegram.WebApp.initDataUnsafe?.user?.id) {
                        currentUserId = window.Telegram.WebApp.initDataUnsafe.user.id;
                        currentUsername = window.Telegram.WebApp.initDataUnsafe.user.username || window.Telegram.WebApp.initDataUnsafe.user.first_name || `–ì—Ä–∞–≤–µ—Ü—å ${String(currentUserId).slice(-4)}`;
                        sendTelegramLog(`WebApp Init: User ID ${currentUserId}, Username ${currentUsername}`);
                    } else {
                        sendTelegramLog('WebApp initialized, but user ID is missing from initDataUnsafe. Setting dummy user.', 'JS_WARN');
                        currentUserId = 'dummy_user_12345';
                        currentUsername = 'DemoPlayer';
                        setError('–î–ª—è –ø–æ–≤–Ω–æ—ó —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—ñ –∑–∞–ø—É—Å—Ç—ñ—Ç—å –≥—Ä—É —á–µ—Ä–µ–∑ Telegram.');
                    }
                } else {
                    sendTelegramLog('Telegram.WebApp NOT Initialized (likely direct browser access or local testing). Setting dummy user.', 'JS_WARN');
                    currentUserId = 'dummy_user_local_123';
                    currentUsername = 'LocalPlayer';
                    setError('–î–ª—è –ø–æ–≤–Ω–æ—ó —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—ñ –∑–∞–ø—É—Å—Ç—ñ—Ç—å –≥—Ä—É —á–µ—Ä–µ–∑ Telegram. (–õ–æ–∫–∞–ª—å–Ω–æ)');
                }

                try {
                    if (currentUserId) {
                        const response = await fetch(`${API_BASE_URL}/api/get_balance`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ user_id: currentUserId, username: currentUsername })
                        });

                        if (!response.ok) {
                            const errData = await response.json();
                            sendTelegramLog(`Balance fetch API failed: ${errData.error || 'Unknown error'}`, 'JS_ERROR');
                            throw new Error(errData.error || 'Failed to fetch user data');
                        }

                        const data = await response.json();
                        setUser(prevUser => {
                            const newUserState = {
                                userId: currentUserId,
                                username: currentUsername,
                                balance: data.balance,
                                xp: data.xp,
                                level: data.level,
                                nextLevelXp: data.next_level_xp,
                                lastDailyBonusClaim: data.last_daily_bonus_claim ? new Date(data.last_daily_bonus_claim) : null,
                                lastQuickBonusClaim: data.last_quick_bonus_claim ? new Date(data.last_quick_bonus_claim) : null
                            };
                            if (prevUser.level !== 1 && newUserState.level > prevUser.level) {
                                playLevelUpSound();
                                // showCustomModal(`üéâ –í–∏ –¥–æ—Å—è–≥–ª–∏ –†—ñ–≤–Ω—è ${newUserState.level}! üéâ`, "–ü—ñ–¥–≤–∏—â–µ–Ω–Ω—è –†—ñ–≤–Ω—è!"); // Moved to ModalContext
                            }
                            return newUserState;
                        });
                        sendTelegramLog('User data fetched and updated successfully from backend.');
                    } else {
                         sendTelegramLog('No valid user ID available for fetching data. Skipping API call.', 'JS_WARN');
                         setUser(prevUser => ({
                            ...prevUser,
                            userId: currentUserId,
                            username: currentUsername,
                            balance: 10000,
                            xp: 0,
                            level: 1,
                            nextLevelXp: 100
                         }));
                    }
                } catch (err) {
                    console.error('Error fetching user data:', err);
                    setError(err.message || '–ü–æ–º–∏–ª–∫–∞ –∑–≤ º—è–∑–∫—É –∑ —Å–µ—Ä–≤–µ—Ä–æ–º. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –∑ º—î–¥–Ω–∞–Ω–Ω—è.');
                    sendTelegramLog(`Error during user data fetch: ${err.message}`, 'JS_ERROR');
                } finally {
                    setIsLoading(false);
                    isFetchingRef.current = false;
                }
            }, [sendTelegramLog, API_BASE_URL]);


            useEffect(() => {
                fetchUserData(); 
            }, [fetchUserData]); 

            // No WebSocket cleanup here anymore, it's handled by BlackjackGame component
            return (
                <UserContext.Provider value={{ 
                    user, setUser, fetchUserData, isLoading, error, API_BASE_URL, sendTelegramLog
                }}>
                    {children}
                </UserContext.Provider>
            );
        };

        const useUser = () => useContext(UserContext);


        // -----------------------------------------------------------------------------
        // Audio Context Setup (Tone.js)
        // -----------------------------------------------------------------------------
        let spinStartSound, reelStopSound, winSound, bigWinSound, loseSound, levelUpSound, dailyBonusSound, quickBonusSound, coinFlipSound;

        async function setupSounds() {
            if (Tone.context.state !== 'running') {
                try {
                    await Tone.start();
                    console.log("[Audio] AudioContext is running.");
                    document.getElementById('audioPrompt').style.display = 'none';
                } catch (e) {
                    console.error("[Audio] –ü–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó –∞—É–¥—ñ–æ:", e);
                    document.getElementById('audioPrompt').style.display = 'flex';
                    return;
                }
            } else {
                document.getElementById('audioPrompt').style.display = 'none';
            }

            // Initialize sounds ONLY after Tone.start() is successful or if already running
            if (!spinStartSound) { 
                spinStartSound = new Tone.MembraneSynth({ envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination();
                reelStopSound = new Tone.MembraneSynth({ envelope: { attack: 0.005, decay: 0.05, sustain: 0.01, release: 0.1 } }).toDestination();
                winSound = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 } }).toDestination();
                bigWinSound = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "triangle" }, envelope: { attack: 0.05, decay: 0.5, sustain: 0.2, release: 1.0 } }).toDestination();
                loseSound = new Tone.MembraneSynth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.4 } }).toDestination();
                levelUpSound = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sawtooth" }, envelope: { attack: 0.02, decay: 0.3, sustain: 0.2, release: 0.8 } }).toDestination();
                dailyBonusSound = new Tone.MembraneSynth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 } }).toDestination();
                quickBonusSound = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.3 } }).toDestination();
                coinFlipSound = new Tone.MembraneSynth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.15, sustain: 0.05, release: 0.2 } }).toDestination();
            }
        }

        // Functions to play sounds - check if sound objects are initialized
        function playSpinStartSound() { if (spinStartSound && Tone.context.state === 'running') spinStartSound.triggerAttackRelease("C4", "8n"); }
        function playReelStopSound(note = "D4") { if (reelStopSound && Tone.context.state === 'running') reelStopSound.triggerAttackRelease(note, "16n"); }
        function playWinSoundEffect() { if (winSound && Tone.context.state === 'running') winSound.triggerAttackRelease(["C5", "E5", "G5"], "4n"); }
        function playBigWinSoundEffect() { if (bigWinSound && Tone.context.state === 'running') bigWinSound.triggerAttackRelease(["C5", "G5", "C6"], "1n"); }
        function playLoseSoundEffect() { if (loseSound && Tone.context.state === 'running') loseSound.triggerAttackRelease("C3", "4n"); }
        function playLevelUpSound() { if (levelUpSound && Tone.context.state === 'running') levelUpSound.triggerAttackRelease(["E4", "G4", "C5"], "0.8n"); }
        function playDailyBonusSound() { if (dailyBonusSound && Tone.context.state === 'running') dailyBonusSound.triggerAttackRelease("G4", "0.5n"); }
        function playQuickBonusSound() { if (quickBonusSound && Tone.context.state === 'running') quickBonusSound.triggerAttackRelease("A4", "0.2n"); }
        function playCoinFlipSound() { if (coinFlipSound && Tone.context.state === 'running') coinFlipSound.triggerAttackRelease("C5", "0.1s"); }


        // -----------------------------------------------------------------------------
        // Custom Modal Context & Component
        // -----------------------------------------------------------------------------
        const ModalContext = createContext(null);

        const ModalProvider = ({ children }) => {
            const [modalState, setModalState] = useState({
                isOpen: false,
                title: '',
                message: '',
                onClose: null
            });

            const showModal = useCallback((message, title = "–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è", onClose = null) => {
                setModalState({
                    isOpen: true,
                    title,
                    message,
                    onClose: onClose || (() => setModalState(prev => ({ ...prev, isOpen: false })))
                });
                if (window.Telegram && window.Telegram.WebApp) {
                    Telegram.WebApp.sendData(`JS_LOG: Showing modal: ${title} - ${message.substring(0, Math.min(message.length, 50))}`);
                }
            }, []);

            const hideModal = useCallback(() => {
                setModalState(prev => ({ ...prev, isOpen: false }));
            }, []);

            return (
                <ModalContext.Provider value={{ showModal, hideModal }}>
                    {children}
                    {modalState.isOpen && (
                        <div className="modal fixed inset-0 flex items-center justify-center z-50 bg-black bg-opacity-70 active">
                            <div className="modal-content bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8 text-center w-11/12 max-w-sm relative border-2 border-yellow-400">
                                <button 
                                    className="close-button absolute top-2 right-4 text-gray-400 hover:text-white text-3xl font-bold transition-colors duration-200" 
                                    onClick={modalState.onClose}
                                >
                                    &times;
                                </button>
                                <h3 className="text-xl font-bold mb-2">{modalState.title}</h3>
                                <p className="text-lg md:text-xl font-semibold mb-4">{modalState.message}</p>
                                <button 
                                    className="bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold py-2 px-6 rounded-full text-lg shadow-md transition-all duration-300" 
                                    onClick={modalState.onClose}
                                >
                                    OK
                                </button>
                            </div>
                        </div>
                    )}
                </ModalContext.Provider>
            );
        };

        const useModal = () => useContext(ModalContext);

        // Removed the problematic DOMContentLoaded listener part for customModal buttons here.
        // The only DOMContentLoaded listener now is for audio prompt.
        document.addEventListener('DOMContentLoaded', () => {
            const audioPrompt = document.getElementById('audioPrompt');
            if (audioPrompt) {
                const activateAudioButton = document.getElementById('activateAudioButton');
                if (activateAudioButton) {
                    activateAudioButton.addEventListener('click', async () => {
                        await setupSounds();
                    });
                }
                // Initial check for audio context state
                if (Tone.context.state !== 'running') {
                    audioPrompt.style.display = 'flex';
                } else {
                    audioPrompt.style.display = 'none';
                }
            }
        });


        // -----------------------------------------------------------------------------
        // Slot Machine Game Component
        // -----------------------------------------------------------------------------
        const SYMBOLS = ['üçí', 'üçã', 'üçä', 'üçá', 'üîî', 'üíé', 'üçÄ'];
        const WILD_SYMBOL = '‚≠ê';
        const SCATTER_SYMBOL = 'üí∞';
        const ALL_REEL_SYMBOLS = [...SYMBOLS, WILD_SYMBOL, SCATTER_SYMBOL];
        const REEL_HEIGHT_PX = 90; // Default height for a symbol in a reel
        const REEL_SPIN_CYCLES = 5;
        const REEL_SPIN_DURATION_BASE = 0.8;
        const REEL_STOP_DURATION = 1.0;
        const REEL_STOP_EASE = "power2.out";
        const REEL_STOP_STAGGER = 0.2;
        const BET_AMOUNT = 100; // –°—Ç–∞–≤–∫–∞ –¥–ª—è —Å–ª–æ—Ç—ñ–≤

        const SlotMachine = () => {
            const { user, fetchUserData, API_BASE_URL, sendTelegramLog } = useUser();
            const { showModal } = useModal(); // Use the new modal hook
            const [message, setMessage] = useState('');
            const [messageClass, setMessageClass] = useState('');
            const [isSpinning, setIsSpinning] = useState(false);
            const reelRefs = [useRef(null), useRef(null), useRef(null)]; // Refs for GSAP animation

            const animateReels = useCallback((finalSymbols) => {
                return new Promise(resolve => {
                    const masterTimeline = gsap.timeline({ onComplete: resolve });

                    reelRefs.forEach((reelRef, index) => {
                        const reelContent = reelRef.current.querySelector('.reel-content');
                        
                        const numSpinSymbols = REEL_SPIN_CYCLES * ALL_REEL_SYMBOLS.length;
                        let animationSymbols = [];
                        for (let i = 0; i < numSpinSymbols; i++) {
                            animationSymbols.push(ALL_REEL_SYMBOLS[Math.floor(Math.random() * ALL_REEL_SYMBOLS.length)]);
                        }
                        animationSymbols.push(finalSymbols[index]); // Ensure final symbol is at the end

                        reelContent.innerHTML = animationSymbols.map(s => `<div class="reel-symbol">${s}</div>`).join('');
                        
                        gsap.set(reelContent, { y: 0 }); // Reset position
                        reelRef.current.classList.add('spinning'); // Add spinning class

                        masterTimeline.to(reelContent, {
                            y: -(animationSymbols.length - 1) * REEL_HEIGHT_PX,
                            duration: REEL_SPIN_DURATION_BASE + (index * REEL_STOP_STAGGER),
                            ease: "linear",
                            onStart: () => {
                                if (index === 0) playSpinStartSound();
                            },
                            onUpdate: function() {
                                if (this.progress() > 0.1 && this.progress() < 0.95 && Tone.context.state === 'running') {
                                    playReelStopSound("C4");
                                }
                            }
                        }, 0);

                        masterTimeline.to(reelContent, {
                            y: -((animationSymbols.length - 1) * REEL_HEIGHT_PX),
                            duration: REEL_STOP_DURATION,
                            ease: REEL_STOP_EASE,
                            overwrite: true,
                            onComplete: () => {
                                reelRef.current.classList.remove('spinning');
                                // Set the exact final symbol
                                reelContent.innerHTML = `<div class="reel-symbol">${finalSymbols[index]}</div>`;
                                gsap.set(reelContent, { y: 0 }); // Ensure it snaps to correct position
                                playReelStopSound("G4");
                            }
                        }, `<${index * REEL_STOP_STAGGER}`); // Stagger starts
                    });
                });
            }, [reelRefs]);

            const handleSpin = async () => {
                if (!user.userId) {
                    showModal('‚ö†Ô∏è –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞–ø—É—Å—Ç—ñ—Ç—å –≥—Ä—É —á–µ—Ä–µ–∑ Telegram, —â–æ–± –≥—Ä–∞—Ç–∏.', "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ");
                    return;
                }
                if (isSpinning || user.balance < BET_AMOUNT) {
                    if (user.balance < BET_AMOUNT) {
                        showModal('–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —Ñ–∞–Ω—Ç–∏–∫—ñ–≤ –¥–ª—è —Å–ø—ñ–Ω–∞!', "–ù–∏–∑—å–∫–∏–π –ë–∞–ª–∞–Ω—Å");
                    }
                    return;
                }

                setIsSpinning(true);
                setMessage('');
                sendTelegramLog('Spin button clicked, starting spin process.');

                try {
                    const response = await fetch(`${API_BASE_URL}/api/spin`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.userId })
                    });

                    const data = await response.json();

                    if (response.ok) {
                        await animateReels(data.symbols); // Animate with actual results
                        await fetchUserData(); // Update balance and XP from backend

                        if (data.winnings > 0) {
                            setMessage(`üéâ –í–∏ –≤–∏–≥—Ä–∞–ª–∏ ${data.winnings} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤! üéâ`);
                            if (data.winnings >= 500) {
                                setMessageClass('message big-win-message');
                                playBigWinSoundEffect();
                            } else {
                                setMessageClass('message win-message');
                                playWinSoundEffect();
                            }
                            sendTelegramLog(`Win: ${data.winnings} coins.`);
                        } else {
                            setMessage('üò¢ –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑!');
                            setMessageClass('message lose-message text-red-400');
                            playLoseSoundEffect();
                            sendTelegramLog('Lose on spin.');
                        }
                    } else {
                        showModal(`‚ùå –ü–æ–º–∏–ª–∫–∞: ${data.error || '–ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞.'}`, "–ü–æ–º–∏–ª–∫–∞ –°–ø—ñ–Ω–∞");
                        setMessageClass('text-red-500 font-bold');
                        playLoseSoundEffect();
                        sendTelegramLog(`Spin API failed: ${data.error || 'Unknown'}`, 'JS_ERROR');
                    }
                } catch (error) {
                    console.error('–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ —Å–ø—ñ–Ω—ñ:', error);
                    showModal('üö´ –ù–µ –≤–¥–∞–ª–æ—Å—è –∑ º—î–¥–Ω–∞—Ç–∏—Å—å —ñ–∑ —Å–µ—Ä–≤–µ—Ä–æ–º. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –∑ º—î–¥–Ω–∞–Ω–Ω—è.', "–ü–æ–º–∏–ª–∫–∞");
                    setMessageClass('text-red-500 font-bold');
                    playLoseSoundEffect();
                    sendTelegramLog(`Spin network error: ${error.message}`, 'JS_ERROR');
                } finally {
                    setIsSpinning(false);
                }
            };

            return (
                <div className="flex-grow flex flex-col items-center justify-around p-4 md:p-8 w-full">
                    <h1 className="text-3xl md:text-4xl font-extrabold text-yellow-400 mb-4 drop-shadow-lg leading-tight text-center">
                        –Ü–≥—Ä–æ–≤—ñ –ê–≤—Ç–æ–º–∞—Ç–∏
                    </h1>
                    
                    {/* Slot Machine Reels */}
                    <div className="slot-machine flex justify-center gap-2 mb-4 w-full max-w-xs md:max-w-sm mx-auto relative px-1 py-3">
                        <div className="absolute -top-3 left-1/2 transform -translate-x-1/2 w-3/4 h-2 bg-gradient-to-r from-yellow-400 to-red-500 rounded-t-lg shadow-lg"></div>
                        {/* Reel 1 */}
                        <div id="reel1" ref={reelRefs[0]} className="reel relative w-24 h-24 md:w-28 md:h-28 rounded-lg bg-gray-800 border-3 border-yellow-500 overflow-hidden shadow-inner transform-gpu">
                            <div className="reel-content absolute top-0 left-0 w-full h-full"></div>
                        </div>
                        {/* Reel 2 */}
                        <div id="reel2" ref={reelRefs[1]} className="reel relative w-24 h-24 md:w-28 md:h-28 rounded-lg bg-gray-800 border-3 border-yellow-500 overflow-hidden shadow-inner transform-gpu">
                            <div className="reel-content absolute top-0 left-0 w-full h-full"></div>
                        </div>
                        {/* Reel 3 */}
                        <div id="reel3" ref={reelRefs[2]} className="reel relative w-24 h-24 md:w-28 md:h-28 rounded-lg bg-gray-800 border-3 border-yellow-500 overflow-hidden shadow-inner transform-gpu">
                            <div className="reel-content absolute top-0 left-0 w-full h-full"></div>
                        </div>
                        <div className="absolute -bottom-3 left-1/2 transform -translate-x-1/2 w-3/4 h-2 bg-gradient-to-r from-red-500 to-yellow-400 rounded-b-lg shadow-lg"></div>
                    </div>

                    {/* Spin Button */}
                    <div className="game-controls flex flex-col md:flex-row gap-3 mb-4 w-full max-w-xs md:max-w-sm">
                        <button 
                            id="spinButton"
                            onClick={handleSpin}
                            disabled={isSpinning || user.balance < BET_AMOUNT}
                            className={`spin-button bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white font-extrabold py-3 px-6 rounded-full text-lg md:text-xl shadow-xl transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 w-full uppercase tracking-wider flex items-center justify-center ${!isSpinning && user.balance >= BET_AMOUNT ? 'pulsing' : ''}`}
                        >
                            –ö—Ä—É—Ç–∏—Ç–∏! (–°—Ç–∞–≤–∫–∞: {BET_AMOUNT})
                        </button>
                    </div>
                    
                    <div id="message" className={`message text-base md:text-lg font-semibold mt-4 min-h-[30px] flex items-center justify-center text-center w-full max-w-sm ${messageClass}`}>
                        {message}
                    </div>
                </div>
            );
        };


        // -----------------------------------------------------------------------------
        // Coin Flip Game Component (New Game)
        // -----------------------------------------------------------------------------
        const COIN_FLIP_BET_AMOUNT = 50; // –°—Ç–∞–≤–∫–∞ –¥–ª—è –º–æ–Ω–µ—Ç–∫–∏

        const CoinFlip = () => {
            const { user, fetchUserData, API_BASE_URL, sendTelegramLog } = useUser();
            const { showModal } = useModal(); // Use the new modal hook
            const [message, setMessage] = useState('');
            const [resultCoin, setResultCoin] = useState(''); // 'heads', 'tails', or 'flipping'
            const [isFlipping, setIsFlipping] = useState(false);
            const [lastChoice, setLastChoice] = useState(null); // To show user's choice

            const handleFlip = async (choice) => {
                if (!user.userId) {
                    showModal('‚ö†Ô∏è –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞–ø—É—Å—Ç—ñ—Ç—å –≥—Ä—É —á–µ—Ä–µ–∑ Telegram, —â–æ–± –≥—Ä–∞—Ç–∏.', "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ");
                    return;
                }
                if (isFlipping || user.balance < COIN_FLIP_BET_AMOUNT) {
                    if (user.balance < COIN_FLIP_BET_AMOUNT) {
                        showModal('–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —Ñ–∞–Ω—Ç–∏–∫—ñ–≤ –¥–ª—è –ø—ñ–¥–∫–∏–¥–∞–Ω–Ω—è –º–æ–Ω–µ—Ç–∫–∏!', "–ù–∏–∑—å–∫–∏–π –ë–∞–ª–∞–Ω—Å");
                    }
                    return;
                }

                setIsFlipping(true);
                setMessage('');
                setResultCoin('flipping'); // Indicate flipping state visually
                setLastChoice(choice);
                playCoinFlipSound();
                sendTelegramLog(`Coin Flip: User chose ${choice}, starting flip.`);

                try {
                    const response = await fetch(`${API_BASE_URL}/api/coin_flip`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.userId, choice: choice })
                    });

                    const data = await response.json();

                    if (response.ok) {
                        // Simulate flip animation time
                        await new Promise(resolve => setTimeout(resolve, 1500)); 

                        setResultCoin(data.result); // 'heads' or 'tails' from backend
                        setMessage(data.message); // Win/lose message from backend
                        await fetchUserData(); // Update balance and XP from backend
                        sendTelegramLog(`Coin Flip Result: ${data.result}, Winnings: ${data.winnings}`);
                    } else {
                        showModal(`‚ùå –ü–æ–º–∏–ª–∫–∞: ${data.error || '–ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞.'}`, "–ü–æ–º–∏–ª–∫–∞ –ü—ñ–¥–∫–∏–¥–∞–Ω–Ω—è");
                        sendTelegramLog(`Coin Flip API failed: ${data.error || 'Unknown'}`, 'JS_ERROR');
                    }
                } catch (error) {
                    console.error('–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –ø—ñ–¥–∫–∏–¥–∞–Ω–Ω—ñ –º–æ–Ω–µ—Ç–∫–∏:', error);
                    showModal('üö´ –ù–µ –≤–¥–∞–ª–æ—Å—è –∑ º—î–¥–Ω–∞—Ç–∏—Å—å —ñ–∑ —Å–µ—Ä–≤–µ—Ä–æ–º. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –∑ º—î–¥–Ω–∞–Ω–Ω—è.', "–ü–æ–º–∏–ª–∫–∞");
                    sendTelegramLog(`Coin Flip network error: ${error.message}`, 'JS_ERROR');
                } finally {
                    setIsFlipping(false);
                }
            };

            const getCoinImage = (result) => {
                if (result === 'heads') {
                    return (
                        <svg className="w-full h-full" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="50" cy="50" r="48" fill="#FFD700" stroke="#DAA520" strokeWidth="2"/>
                            <path d="M50 20C35 20 25 35 25 50C25 65 35 80 50 80C65 80 75 65 75 50C75 35 65 20 50 20ZM50 30C58.2843 30 65 36.7157 65 45H50V30ZM50 70C41.7157 70 35 63.2843 35 55H50V70Z" fill="#8B4513"/>
                            <text x="50" y="55" fontFamily="Arial" fontSize="20" fontWeight="bold" fill="#F5F5DC" textAnchor="middle">–û–†–ï–õ</text>
                        </svg>
                    );
                } else if (result === 'tails') {
                    return (
                        <svg className="w-full h-full" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="50" cy="50" r="48" fill="#C0C0C0" stroke="#A9A9A9" strokeWidth="2"/>
                            <path d="M50 20C35 20 25 35 25 50C25 65 35 80 50 80C65 80 75 65 75 50C75 35 65 20 50 20ZM50 30C58.2843 30 65 36.7157 65 45H50V30ZM50 70C41.7157 70 35 63.2843 35 55H50V70Z" fill="#2F4F4F"/>
                            <text x="50" y="55" fontFamily="Arial" fontSize="20" fontWeight="bold" fill="#F5F5DC" textAnchor="middle">–†–ï–®–ö–ê</text>
                        </svg>
                    );
                }
                return (
                    <svg className="w-full h-full" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="50" cy="50" r="48" fill="#FFD700" stroke="#DAA520" strokeWidth="2"/>
                        <text x="50" y="58" fontFamily="Arial" fontSize="40" fontWeight="bold" fill="#8B4513" textAnchor="middle">?</text>
                    </svg>
                );
            };


            return (
                <div className="flex-grow flex flex-col items-center justify-around p-4 md:p-8 w-full">
                    {/* Removed H1 "–ü—ñ–¥–∫–∏–¥–∞–Ω–Ω—è –ú–æ–Ω–µ—Ç–∫–∏" */}

                    <div className="coin-flip-area flex flex-col items-center mb-6">
                        <div className={`coin-display transition-transform duration-500 ease-out ${isFlipping ? 'animate-spin-3d' : ''}`}>
                            {getCoinImage(resultCoin)}
                        </div>
                        {/* Show message from backend after flip */}
                        {!isFlipping && message && (
                            <p className={`message text-gray-300 text-lg mt-2 text-center font-bold ${message.includes('–í—ñ—Ç–∞—î–º–æ') ? 'text-green-400' : 'text-red-400'}`}>
                                {message}
                            </p>
                        )}
                        {/* Show user's choice while flipping or before result, if no message */}
                        {isFlipping && lastChoice && <p className="text-gray-300 text-lg mt-2">–í–∞—à –≤–∏–±—ñ—Ä: {lastChoice === 'heads' ? '–û—Ä–µ–ª' : '–†–µ—à–∫–∞'}</p>}
                        {!isFlipping && !message && lastChoice && <p className="text-gray-300 text-lg mt-2">–í–∏ –æ–±—Ä–∞–ª–∏: {lastChoice === 'heads' ? '–û—Ä–µ–ª' : '–†–µ—à–∫–∞'}</p>}

                    </div>

                    <div className="game-controls flex flex-col md:flex-row gap-3 mb-4 w-full max-w-xs md:max-w-sm">
                        <button
                            onClick={() => handleFlip('heads')}
                            disabled={isFlipping || user.balance < COIN_FLIP_BET_AMOUNT}
                            className="spin-button bg-gradient-to-r from-blue-500 to-indigo-600 hover:from-blue-600 hover:to-indigo-700 text-white font-extrabold py-3 px-6 rounded-full text-lg md:text-xl shadow-xl transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 w-full uppercase tracking-wider flex items-center justify-center"
                        >
                            –û—Ä–µ–ª (–°—Ç–∞–≤–∫–∞: {COIN_FLIP_BET_AMOUNT})
                        </button>
                        <button
                            onClick={() => handleFlip('tails')}
                            disabled={isFlipping || user.balance < COIN_FLIP_BET_AMOUNT}
                            className="spin-button bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 text-white font-extrabold py-3 px-6 rounded-full text-lg md:text-xl shadow-xl transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 w-full uppercase tracking-wider flex items-center justify-center mt-3 md:mt-0"
                        >
                            –†–µ—à–∫–∞ (–°—Ç–∞–≤–∫–∞: {COIN_FLIP_BET_AMOUNT})
                        </button>
                    </div>
                </div>
            );
        };


        // -----------------------------------------------------------------------------
        // Leaderboard Component
        // -----------------------------------------------------------------------------
        const Leaderboard = () => {
            const { API_BASE_URL, sendTelegramLog } = useUser();
            const [leaderboardData, setLeaderboardData] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);

            const fetchLeaderboard = useCallback(async () => {
                setLoading(true);
                setError(null);
                sendTelegramLog('Fetching leaderboard data...');
                try {
                    const response = await fetch(`${API_BASE_URL}/api/get_leaderboard`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({})
                    });

                    if (!response.ok) {
                        const errData = await response.json();
                        sendTelegramLog(`Leaderboard API error: ${errData.error || 'Unknown'}`, 'JS_ERROR');
                        throw new Error(errData.error || 'Failed to fetch leaderboard data');
                    }

                    const data = await response.json();
                    sendTelegramLog(`Leaderboard data received, count: ${data.leaderboard ? data.leaderboard.length : 0}`);
                    
                    // Sorting is handled by backend query (ORDER BY level DESC, xp DESC)
                    setLeaderboardData(data.leaderboard || []);

                } catch (err) {
                    console.error('Error fetching leaderboard:', err);
                    setError(err.message || '–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–æ—à–∫–∏ –ª—ñ–¥–µ—Ä—ñ–≤.');
                    sendTelegramLog(`Leaderboard network error: ${err.message}`, 'JS_ERROR');
                } finally {
                    setLoading(false);
                }
            }, [API_BASE_URL, sendTelegramLog]);

            useEffect(() => {
                fetchLeaderboard();
            }, [fetchLeaderboard]);

            return (
                <div className="flex-grow flex flex-col items-center justify-start p-4 md:p-8 w-full">
                    <h2 className="text-3xl font-extrabold text-yellow-400 mb-6">üëë –î–æ—à–∫–∞ –õ—ñ–¥–µ—Ä—ñ–≤ üëë</h2>
                    <div id="leaderboardTableContainer" className="overflow-x-auto w-full max-w-lg bg-gray-800 rounded-xl shadow-2xl p-4 border-2 border-yellow-400">
                        {loading && <p className="text-yellow-300 mt-4 text-center">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</p>}
                        {error && <p className="text-red-500 mt-4 text-center">{error}</p>}
                        {!loading && !error && leaderboardData.length === 0 && (
                            <p className="py-4 text-center text-gray-400">–ù–∞—Ä–∞–∑—ñ –Ω–µ–º–∞—î –ª—ñ–¥–µ—Ä—ñ–≤. –ë—É–¥—å –ø–µ—Ä—à–∏–º!</p>
                        )}
                        {!loading && !error && leaderboardData.length > 0 && (
                            <table className="w-full text-left text-sm md:text-base text-gray-300">
                                <thead className="text-xs md:text-sm text-gray-100 uppercase bg-gray-700">
                                    <tr>
                                        <th scope="col" className="py-2 px-3">#</th>
                                        <th scope="col" className="py-2 px-3">–Ü–º'—è</th>
                                        {/* Show Level and XP instead of Balance, as it's more relevant for ranking */}
                                        <th scope="col" className="py-2 px-3 text-right">–†—ñ–≤–µ–Ω—å</th>
                                        <th scope="col" className="py-2 px-3 text-right">XP</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {leaderboardData.map((player, index) => (
                                        <tr key={index} className={(index % 2 === 0) ? 'bg-gray-800' : 'bg-gray-700'}>
                                            <td className="py-2 px-3 font-bold">{index + 1}</td>
                                            <td className="py-2 px-3">{player.username}</td>
                                            <td className="py-2 px-3 text-right">{player.level}</td>
                                            <td className="py-2 px-3 text-right">{player.xp}</td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        )}
                    </div>
                </div>
            );
        };

        // -----------------------------------------------------------------------------
        // Blackjack Game Component (Multiplayer)
        // -----------------------------------------------------------------------------
        const BLACKJACK_BET_AMOUNT = 200; // Fixed bet amount for Blackjack

        const BlackjackGame = () => {
            const { user, fetchUserData, API_BASE_URL, sendTelegramLog, setUser } = useUser();
            const { showModal } = useModal(); // Use the new modal hook
            
            // Moved WebSocket state and refs to this component
            const wsRef = useRef(null);
            const wsReconnectAttempts = useRef(0);
            const wsReconnectTimeout = useRef(null);

            const [blackjackRoomState, setBlackjackRoomState] = useState({
                room_id: null,
                status: "disconnected", // Initial status
                dealer_hand: [], 
                dealer_score: 0, 
                players: [],
                current_player_turn: null,
                player_count: 0,
                min_players: 0,
                max_players: 0,
                timer: 0
            });
            const [blackjackGameMessage, setBlackjackGameMessage] = useState("–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å '–ë–ª–µ–∫–¥–∂–µ–∫', —â–æ–± –ø—Ä–∏—î–¥–Ω–∞—Ç–∏—Å—è.");
            const [showBetModal, setShowBetModal] = useState(false);
            const [localTimer, setLocalTimer] = useState(0); 

            // Helper to determine game status message
            const getGameStatusMessage = useCallback((state, currentUserId) => {
                if (!state || !state.room_id) {
                    if (state.status === "connecting") return "–ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ —Å–µ—Ä–≤–µ—Ä–∞...";
                    if (state.status === "disconnected") return "–í—ñ–¥–∫–ª—é—á–µ–Ω–æ –≤—ñ–¥ –≥—Ä–∏. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è.";
                    if (state.status === "error") return "–ü–æ–º–∏–ª–∫–∞ –≥—Ä–∏. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è.";
                    return "–û—á—ñ–∫—É–≤–∞–Ω–Ω—è –∫—ñ–º–Ω–∞—Ç–∏...";
                }
                
                const currentPlayer = state.players.find(p => p.user_id === currentUserId);
                
                if (!currentPlayer && (state.status !== "disconnected" && state.status !== "error")) {
                    return "–ü—Ä–∏—î–¥–Ω—É—î–º–æ—Å—å –¥–æ –≥—Ä–∏...";
                }
                if (!currentPlayer && (state.status === "disconnected" || state.status === "error")) {
                    return "–í–∏ –≤—ñ–¥–∫–ª—é—á–µ–Ω—ñ –≤—ñ–¥ –∫—ñ–º–Ω–∞—Ç–∏. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è.";
                }

                const areAllPlayersFinishedBetting = () => {
                    if (!state.players || state.players.length === 0) return false;
                    return state.players.every(p => p.has_bet || !p.is_playing);
                };


                switch (state.status) {
                    case "connecting": return "–ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ —Å–µ—Ä–≤–µ—Ä–∞...";
                    case "waiting": return `–û—á—ñ–∫—É–≤–∞–Ω–Ω—è –≥—Ä–∞–≤—Ü—ñ–≤ (${state.player_count}/${state.min_players})`;
                    case "starting_timer": return `–ì—Ä–∞ —Ä–æ–∑–ø–æ—á–Ω–µ—Ç—å—Å—è —á–µ—Ä–µ–∑ ${state.timer} —Å–µ–∫—É–Ω–¥! (${state.player_count}/${state.min_players})`;
                    case "betting": 
                        if (currentPlayer && currentPlayer.has_bet) {
                            if (areAllPlayersFinishedBetting()) {
                                return "–í—Å—ñ —Å—Ç–∞–≤–∫–∏ –∑—Ä–æ–±–ª–µ–Ω—ñ, —Ä–∞—É–Ω–¥ –ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è!";
                            } else {
                                return "–í–∞—à–∞ —Å—Ç–∞–≤–∫–∞ –ø—Ä–∏–π–Ω—è—Ç–∞. –û—á—ñ–∫—É–≤–∞–Ω–Ω—è —ñ–Ω—à–∏—Ö –≥—Ä–∞–≤—Ü—ñ–≤...";
                            }
                        } else {
                            return "–ó—Ä–æ–±—ñ—Ç—å –≤–∞—à—É —Å—Ç–∞–≤–∫—É!";
                        }
                    case "playing": 
                        if (state.current_player_turn === currentUserId) {
                            return "–í–∞—à —Ö—ñ–¥! (–£–¥–∞—Ä / –°—Ç–æ–ø)";
                        } else {
                            const activePlayer = state.players.find(p => p.user_id === state.current_player_turn);
                            return `–•—ñ–¥ –≥—Ä–∞–≤—Ü—è: ${activePlayer ? activePlayer.username : '–ù–µ–≤—ñ–¥–æ–º–∏–π'}`;
                        }
                    case "round_end": return "–†–∞—É–Ω–¥ –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –†–µ–∑—É–ª—å—Ç–∞—Ç–∏...";
                    case "disconnected": return "–í–∏ –≤—ñ–¥–∫–ª—é—á–µ–Ω—ñ –≤—ñ–¥ –≥—Ä–∏. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è.";
                    case "error": return "–ü–æ–º–∏–ª–∫–∞ –≥—Ä–∏. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è.";
                    default: return `–°—Ç–∞—Ç—É—Å –∫—ñ–º–Ω–∞—Ç–∏: ${state.status}`;
                }
            }, [user.userId]); // Depend on user.userId for the current player check

            // Debounce for sendWsMessage to prevent spamming request_state
            const sendWsMessageDebounceTimer = useRef(null);
            const sendWsMessage = useCallback((action, payload = {}) => {
                // Clear any existing debounce timer for 'request_state' action
                if (action === "request_state" && sendWsMessageDebounceTimer.current) {
                    clearTimeout(sendWsMessageDebounceTimer.current);
                }

                // If it's a 'request_state' action, debounce it
                if (action === "request_state") {
                    sendWsMessageDebounceTimer.current = setTimeout(() => {
                        if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
                            const message = { action, ...payload };
                            wsRef.current.send(JSON.stringify(message));
                            sendTelegramLog(`WS Sent (debounced): ${action} with payload ${JSON.stringify(payload).substring(0, 50)}`);
                        } else {
                            sendTelegramLog(`WS Error (debounced): Tried to send ${action} but WebSocket not open. Current readyState: ${wsRef.current ? wsRef.current.readyState : 'null'}`, 'JS_ERROR');
                            // showModal("–ü–æ–º–∏–ª–∫–∞: WebSocket –Ω–µ –ø—ñ–¥–∫–ª—é—á–µ–Ω–∏–π. –°–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è.", "–ü–æ–º–∏–ª–∫–∞ –∑–≤'—è–∑–∫—É");
                        }
                    }, 500); // Debounce for 500ms
                } else {
                    // For other actions, send immediately
                    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
                        const message = { action, ...payload };
                        wsRef.current.send(JSON.stringify(message));
                        sendTelegramLog(`WS Sent (immediate): ${action} with payload ${JSON.stringify(payload).substring(0, 50)}`);
                    } else {
                        sendTelegramLog(`WS Error (immediate): Tried to send ${action} but WebSocket not open. Current readyState: ${wsRef.current ? wsRef.current.readyState : 'null'}`, 'JS_ERROR');
                        showModal("–ü–æ–º–∏–ª–∫–∞: WebSocket –Ω–µ –ø—ñ–¥–∫–ª—é—á–µ–Ω–∏–π. –°–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è.", "–ü–æ–º–∏–ª–∫–∞ –∑–≤'—è–∑–∫—É");
                    }
                }
            }, [sendTelegramLog, showModal]); // Added showModal to dependencies


            // Blackjack WebSocket Connection Management
            const connectBlackjackWebSocket = useCallback(() => {
                if (!user.userId) {
                    sendTelegramLog('connectBlackjackWebSocket: User ID not available, skipping WS connection.', 'JS_DEBUG');
                    showModal('‚ö†Ô∏è –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞–ø—É—Å—Ç—ñ—Ç—å –≥—Ä—É —á–µ—Ä–µ–∑ Telegram, —â–æ–± –æ—Ç—Ä–∏–º–∞—Ç–∏ User ID.', "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ");
                    return;
                }
                if (!API_BASE_URL) {
                    sendTelegramLog('connectBlackjackWebSocket: API_BASE_URL not available, skipping WS connection.', 'JS_ERROR');
                    showModal('–ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞: URL —Å–µ—Ä–≤–µ—Ä–∞ –Ω–µ –Ω–∞–ª–∞—à—Ç–æ–≤–∞–Ω–æ.', '–ü–æ–º–∏–ª–∫–∞ –ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó');
                    return;
                }

                // IMPORTANT: Only proceed if there's no current WebSocket or it's explicitly closed/closing
                // This prevents creating multiple connections if one is already open or connecting
                if (wsRef.current && (wsRef.current.readyState === WebSocket.OPEN || wsRef.current.readyState === WebSocket.CONNECTING)) {
                    sendTelegramLog('connectBlackjackWebSocket: Existing WS connection found and is open or connecting, reusing.', 'JS_DEBUG');
                    return;
                }
                
                // Clear any old, stale WebSocket reference if it's not open/connecting
                if (wsRef.current && (wsRef.current.readyState === WebSocket.CLOSING || wsRef.current.readyState === WebSocket.CLOSED)) {
                    sendTelegramLog('connectBlackjackWebSocket: Existing WS connection found but closing/closed, clearing ref for new connection.', 'JS_DEBUG');
                    wsRef.current = null;
                }

                const websocketUrl = `wss://${new URL(API_BASE_URL).host}/ws/${user.userId}`;
                sendTelegramLog(`connectBlackjackWebSocket: Attempting to establish NEW WebSocket to: ${websocketUrl}`);
                setBlackjackRoomState(prev => ({ ...prev, status: "connecting" })); // Set connecting status
                setBlackjackGameMessage("–ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ –≥—Ä–∏...");

                const newWs = new WebSocket(websocketUrl);

                newWs.onopen = () => {
                    sendTelegramLog("Blackjack WS: Connected.");
                    setBlackjackGameMessage("–ü—ñ–¥–∫–ª—é—á–µ–Ω–æ. –®—É–∫–∞—î–º–æ –∫—ñ–º–Ω–∞—Ç—É...");
                    sendWsMessage("request_state"); // Request initial state after connection
                    wsReconnectAttempts.current = 0; // Reset reconnect attempts on successful connection
                    if (wsReconnectTimeout.current) {
                        clearTimeout(wsReconnectTimeout.current);
                        wsReconnectTimeout.current = null;
                    }
                };

                newWs.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        // Handle ping messages to keep connection alive
                        if (message.type === "ping") {
                            // Respond with pong to server's ping
                            newWs.send(JSON.stringify({ type: "pong" }));
                            sendTelegramLog("Blackjack WS: Received ping, sent pong.");
                            return; 
                        }

                        sendTelegramLog(`Blackjack WS: Received: ${JSON.stringify(message).substring(0, 100)}`);

                        if (message.type === "error") {
                            showModal(message.message, "–ü–æ–º–∏–ª–∫–∞ –ì—Ä–∏"); // Use new showModal
                            setBlackjackGameMessage(message.message);
                            sendTelegramLog(`Blackjack WS Error Message: ${message.message}`, 'JS_ERROR');
                        } else if (message.type === "game_message") {
                            setBlackjackGameMessage(message.message);
                            sendTelegramLog(`Blackjack WS Game Message: ${message.message}`);
                        } else if (message.type === "level_up") {
                            playLevelUpSound();
                            showModal(`üéâ –í–∏ –¥–æ—Å—è–≥–ª–∏ –†—ñ–≤–Ω—è ${message.level}! üéâ`, "–ü—ñ–¥–≤–∏—â–µ–Ω–Ω—è –†—ñ–≤–Ω—è!"); // Use new showModal
                            fetchUserData(); // Update all user stats
                            sendTelegramLog(`Blackjack WS Level Up: ${message.level}`);
                        } else if (message.room_id) { // It's a room state update
                            setBlackjackRoomState(prevState => {
                                const newTimer = (message.status === "starting_timer" || message.status === "betting" || message.status === "playing") ? message.timer : 0;
                                sendTelegramLog(`Blackjack WS State Update: Status=${message.status}, Timer=${message.timer}, Players=${message.players.length}`);
                                // Log player-specific details for debugging freeze
                                message.players.forEach(p => {
                                    sendTelegramLog(`  Player ${p.username} (${p.user_id}): Score=${p.score}, Bet=${p.bet}, is_playing=${p.is_playing}, has_bet=${p.has_bet}`);
                                });
                                return { ...message, timer: newTimer }; 
                            });
                            // Only update general game message if it's not a round_result (which has its own specific message)
                            if (message.type !== "round_result") {
                                setBlackjackGameMessage(getGameStatusMessage(message, user.userId));
                            }
                        } else if (message.type === "round_result") {
                            const { message: resultMsg, winnings, balance, xp, level, next_level_xp, final_player_score } = message;
                            setBlackjackGameMessage(resultMsg);
                            showModal( // Use new showModal
                                `–†–µ–∑—É–ª—å—Ç–∞—Ç: ${resultMsg}<br/>–í–∞—à —Ä–∞—Ö—É–Ω–æ–∫: ${final_player_score}<br/>–í–∏–≥—Ä–∞—à: ${winnings} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤!`,
                                "–†–µ–∑—É–ª—å—Ç–∞—Ç –†–∞—É–Ω–¥—É"
                            );
                            if (winnings > 0) {
                                playWinSoundEffect();
                            } else {
                                playLoseSoundEffect();
                            }
                            setUser(prevUser => ({
                                ...prevUser,
                                balance: balance,
                                xp: xp,
                                level: level,
                                nextLevelXp: next_level_xp
                            }));
                            sendTelegramLog('User data updated from round_result message.');
                        } else {
                            sendTelegramLog(`Blackjack WS: Received UNKNOWN message type: ${JSON.stringify(message).substring(0, 100)}`, 'JS_ERROR');
                            showModal(`–ù–µ–≤—ñ–¥–æ–º–∞ –¥—ñ—è: ${JSON.stringify(message).substring(0, 50)}...`, "–ü–æ–º–∏–ª–∫–∞ –ì—Ä–∏");
                        }
                    } catch (e) {
                        sendTelegramLog(`Blackjack WS: Error parsing message or in onmessage handler: ${e.message}. Raw data: ${event.data.substring(0, 100)}`, 'JS_ERROR');
                        console.error("Blackjack WS onmessage error:", e);
                        showModal(`–ü–æ–º–∏–ª–∫–∞ –æ–±—Ä–æ–±–∫–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: ${e.message}`, "–ü–æ–º–∏–ª–∫–∞ –ì—Ä–∏");
                    }
                };

                newWs.onclose = (event) => {
                    sendTelegramLog(`Blackjack WS: Disconnected. Code: ${event.code}, Reason: ${event.reason}.`, 'JS_WARN');
                    setBlackjackGameMessage("–í—ñ–¥–∫–ª—é—á–µ–Ω–æ –≤—ñ–¥ –≥—Ä–∏. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è.");
                    setBlackjackRoomState(prev => ({ 
                        ...prev, 
                        status: "disconnected", 
                        room_id: null, 
                        timer: 0,
                        dealer_hand: [], 
                        dealer_score: 0, 
                        players: [],
                        current_player_turn: null,
                        player_count: 0,
                        min_players: 0,
                        max_players: 0,
                    }));
                    wsRef.current = null; // Clear the ref on close

                    // Only attempt reconnect if it was not a clean close (code 1000) or user explicitly left (handled by leave_room)
                    // And if we haven't reached max attempts
                    // If the user explicitly leaves, we don't want to auto-reconnect.
                    // The `leave_room` action should trigger a clean close (code 1000) and break the loop.
                    if (event.code !== 1000 && wsReconnectAttempts.current < 5) { // 1000 is normal closure
                        wsReconnectAttempts.current++;
                        const delay = Math.min(1000 * (wsReconnectAttempts.current + 1), 5000);
                        sendTelegramLog(`Attempting to reconnect WS in ${delay / 1000} seconds (attempt ${wsReconnectAttempts.current}).`, 'JS_LOG');
                        wsReconnectTimeout.current = setTimeout(() => connectBlackjackWebSocket(), delay);
                    } else if (event.code !== 1000) { // If it was an unclean close and max attempts reached
                        sendTelegramLog('Max WebSocket reconnect attempts reached. Please refresh.', 'JS_ERROR');
                        showModal('–í—ñ–¥–∫–ª—é—á–µ–Ω–æ –≤—ñ–¥ –≥—Ä–∏. –ë—É–¥—å –ª–∞—Å–∫–∞, –æ–Ω–æ–≤—ñ—Ç—å —Å—Ç–æ—Ä—ñ–Ω–∫—É –∞–±–æ —Å–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è –∑–Ω–æ–≤—É.', '–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è');
                    }
                };

                newWs.onerror = (error) => {
                    sendTelegramLog(`Blackjack WS: Error: ${error.message || error}`, 'JS_ERROR');
                    setBlackjackGameMessage(`–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è: ${error.message || error}`);
                    setBlackjackRoomState(prev => ({ ...prev, status: "error", room_id: null, timer: 0 }));
                    if (wsRef.current) {
                        wsRef.current.close(); // Force close to trigger onclose and reconnect logic
                    }
                    wsRef.current = null;
                };

                wsRef.current = newWs;
            }, [user.userId, API_BASE_URL, sendTelegramLog, fetchUserData, getGameStatusMessage, setUser, sendWsMessage, showModal]);


            // Effect to connect to WebSocket and request state when component mounts
            useEffect(() => {
                if (user.userId) {
                    sendTelegramLog('BlackjackGame component mounted. Attempting to connect WS.');
                    connectBlackjackWebSocket();
                }

                // Cleanup function for when BlackjackGame component unmounts
                return () => {
                    sendTelegramLog('BlackjackGame cleanup: Component unmounted.');
                    if (wsRef.current) {
                        if (wsRef.current.readyState === WebSocket.OPEN) {
                            sendTelegramLog('BlackjackGame cleanup: Closing WebSocket connection cleanly.');
                            // Send leave_room message if in a room
                            if (user.userId && blackjackRoomState.room_id) {
                                try {
                                    wsRef.current.send(JSON.stringify({ action: 'leave_room', user_id: user.userId, room_id: blackjackRoomState.room_id }));
                                    sendTelegramLog(`BlackjackGame cleanup: Sent leave_room for user ${user.userId} from room ${blackjackRoomState.room_id}.`);
                                } catch (e) {
                                    sendTelegramLog(`BlackjackGame cleanup: Error sending leave_room on unmount: ${e.message}`, 'JS_ERROR');
                                }
                            }
                            wsRef.current.close(1000, "Component unmounted."); // Clean close code
                        } else {
                            sendTelegramLog(`BlackjackGame cleanup: WS not open, current state: ${wsRef.current.readyState}. No explicit close needed.`);
                        }
                        wsRef.current = null; // Ensure ref is cleared
                    }
                    if (sendWsMessageDebounceTimer.current) {
                        clearTimeout(sendWsMessageDebounceTimer.current);
                    }
                    if (wsReconnectTimeout.current) {
                        clearTimeout(wsReconnectTimeout.current);
                        wsReconnectTimeout.current = null;
                    }
                    // Reset blackjack state when component unmounts
                    setBlackjackRoomState({
                        room_id: null,
                        status: "disconnected",
                        dealer_hand: [], 
                        dealer_score: 0, 
                        players: [],
                        current_player_turn: null,
                        player_count: 0,
                        min_players: 0,
                        max_players: 0,
                        timer: 0
                    });
                    setBlackjackGameMessage("–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å '–ë–ª–µ–∫–¥–∂–µ–∫', —â–æ–± –ø—Ä–∏—î–¥–Ω–∞—Ç–∏—Å—è.");
                };
            }, [user.userId, connectBlackjackWebSocket, sendTelegramLog, blackjackRoomState.room_id]);


            // Effect to update local timer based on blackjackRoomState.status
            useEffect(() => {
                let timerInterval;
                if ((blackjackRoomState.status === "starting_timer" || blackjackRoomState.status === "betting" || blackjackRoomState.status === "playing") && blackjackRoomState.timer > 0) {
                    setLocalTimer(blackjackRoomState.timer); // Set initial local timer from backend
                    timerInterval = setInterval(() => {
                        setLocalTimer(prevTimer => {
                            if (prevTimer <= 1) {
                                clearInterval(timerInterval);
                                return 0;
                            }
                            return prevTimer - 1;
                        });
                    }, 1000);
                } else {
                    setLocalTimer(0); // Reset timer if not in a timed state
                }
                return () => clearInterval(timerInterval); // Cleanup interval on unmount or status change
            }, [blackjackRoomState.status, blackjackRoomState.timer]); // Depend on backend timer for initial sync

            const getCardDisplay = (card) => {
                if (card === "Hidden") return "üÇ†"; // Card back
                const rank = card.slice(0, -1);
                const suit = card.slice(-1);
                let colorClass = '';
                if (suit === '‚ô•' || suit === '‚ô¶') {
                    colorClass = 'text-red-600'; // Red for hearts/diamonds
                } else {
                    colorClass = 'text-gray-900'; // Black for spades/clubs
                }
                return (
                    <div className={`card ${colorClass}`}>
                        <span className="card-rank">{rank}</span>
                        <span className="card-suit">{suit}</span>
                    </div>
                );
            };
            
            const renderPlayerHand = (player) => {
                const isCurrentPlayer = player.user_id === user.userId;
                return (
                    <div key={player.user_id} className={`player-card-container ${blackjackRoomState.current_player_turn === player.user_id ? 'current-turn-highlight' : ''}`}>
                        <p className="player-username font-bold text-lg mb-1">{player.username} {isCurrentPlayer ? "(–í–∏)" : ""}</p>
                        <div className="flex flex-wrap justify-center gap-1 mb-1">
                            {player.hand.map((cardStr, idx) => (
                                <div key={idx} className="card-item relative">{getCardDisplay(cardStr)}</div>
                            ))}
                        </div>
                        <p className="text-sm">–†–∞—Ö—É–Ω–æ–∫: {player.score} | –°—Ç–∞–≤–∫–∞: {player.bet}</p>
                        {blackjackRoomState.status === "betting" && !player.has_bet && isCurrentPlayer && (
                            <p className="text-yellow-300 text-sm animate-pulse">–ó—Ä–æ–±—ñ—Ç—å —Å—Ç–∞–≤–∫—É!</p>
                        )}
                        {/* New message for players not playing this round */}
                        {blackjackRoomState.status !== "betting" && !player.is_playing && player.user_id === user.userId && (
                            <p className="text-red-400 text-sm mt-1">–í–∏ –Ω–µ –±–µ—Ä–µ—Ç–µ —É—á–∞—Å—Ç—å —É —Ü—å–æ–º—É —Ä–∞—É–Ω–¥—ñ.</p>
                        )}
                    </div>
                );
            };

            // Determine if the "Make Bet" button should be active for the current user
            const canMakeBet = blackjackRoomState.status === "betting" && user.balance >= BLACKJACK_BET_AMOUNT && blackjackRoomState.players.some(p => p.user_id === user.userId && !p.has_bet);
            const canHitStand = blackjackRoomState.status === "playing" && blackjackRoomState.current_player_turn === user.userId;
            const isWaitingForOthersToBet = blackjackRoomState.status === "betting" && blackjackRoomState.players.some(p => p.user_id === user.userId && p.has_bet) && !allPlayersHaveBet();

            const allPlayersHaveBet = () => {
                if (blackjackRoomState.players.length === 0) return false;
                // Consider a player as "finished betting" if they have bet OR they are not playing this round
                return blackjackRoomState.players.every(p => p.has_bet || !p.is_playing);
            };


            return (
                <div className="blackjack-game flex-grow flex flex-col items-center justify-between p-4 md:p-8 w-full min-h-0">
                    <h1 className="text-3xl md:text-4xl font-extrabold text-yellow-400 mb-4 drop-shadow-lg leading-tight text-center">
                        ‚ô¶Ô∏è –ë–ª–µ–∫–¥–∂–µ–∫ ‚ô¶Ô∏è
                    </h1>
                    
                    <div className="game-status-message-box bg-gray-700 p-3 rounded-lg w-full max-w-lg text-center shadow-lg mb-4 border border-yellow-500">
                        <p className="text-xl font-bold text-yellow-300">{blackjackGameMessage}</p>
                    </div>

                    {/* Timer display for starting game - now uses localTimer */}
                    {(blackjackRoomState.status === "starting_timer" || blackjackRoomState.status === "betting" || blackjackRoomState.status === "playing") && localTimer > 0 && (
                        <div className="text-4xl font-extrabold text-red-500 mb-4 animate-pulse-fast">
                            {localTimer}
                        </div>
                    )}

                    {/* Players' Hands */}
                    <div className="players-area flex-grow w-full max-w-lg overflow-y-auto p-2 bg-gray-900 rounded-xl shadow-inner border border-gray-700 min-h-0">
                        {blackjackRoomState.players.length === 0 && blackjackRoomState.status !== "disconnected" && blackjackRoomState.status !== "error" ? (
                            <p className="text-center text-gray-400 mt-4">–û—á—ñ–∫—É–≤–∞–Ω–Ω—è –≥—Ä–∞–≤—Ü—ñ–≤...</p>
                        ) : (
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                {blackjackRoomState.players.map(renderPlayerHand)}
                            </div>
                        )}
                    </div>
                    
                    {/* Game Controls */}
                    <div className="game-controls flex flex-col md:flex-row gap-3 mt-4 w-full max-w-xs md:max-w-md">
                        {/* Connect/Reconnect button - always show if disconnected or error */}
                        {(blackjackRoomState.status === "disconnected" || blackjackRoomState.status === "error") && (
                            <button
                                onClick={connectBlackjackWebSocket}
                                className="spin-button bg-gray-500 hover:bg-gray-600 text-white py-3 px-6 rounded-full text-lg shadow-xl transition-all duration-300 transform hover:scale-105 active:scale-95 w-full uppercase"
                            >
                                –ü—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—å –¥–æ –≥—Ä–∏
                            </button>
                        )}

                        {/* Bet button */}
                        {blackjackRoomState.status === "betting" && (
                            <>
                                <button
                                    onClick={() => setShowBetModal(true)}
                                    disabled={!canMakeBet || isWaitingForOthersToBet}
                                    className="spin-button bg-gradient-to-r from-green-500 to-emerald-600 text-white py-3 px-6 rounded-full text-lg shadow-xl transition-all duration-300 transform hover:scale-105 active:scale-95 w-full uppercase"
                                >
                                    –ó—Ä–æ–±–∏—Ç–∏ —Å—Ç–∞–≤–∫—É ({BLACKJACK_BET_AMOUNT})
                                </button>
                                {isWaitingForOthersToBet && (
                                    <p className="text-gray-400 text-center text-sm mt-2">–û—á—ñ–∫—É—î–º–æ —ñ–Ω—à–∏—Ö –≥—Ä–∞–≤—Ü—ñ–≤...</p>
                                )}
                            </>
                        )}

                        {/* Hit/Stand buttons */}
                        {blackjackRoomState.status === "playing" && blackjackRoomState.current_player_turn === user.userId && (
                            <>
                                <button
                                    onClick={() => sendWsMessage("hit")}
                                    disabled={!canHitStand}
                                    className="spin-button bg-gradient-to-r from-blue-500 to-indigo-600 text-white py-3 px-6 rounded-full text-lg shadow-xl transition-all duration-300 transform hover:scale-105 active:scale-95 w-full uppercase"
                                >
                                    –í–∑—è—Ç–∏ –∫–∞—Ä—Ç—É (Hit)
                                </button>
                                <button
                                    onClick={() => sendWsMessage("stand")}
                                    disabled={!canHitStand}
                                    className="spin-button bg-gradient-to-r from-red-500 to-orange-600 text-white py-3 px-6 rounded-full text-lg shadow-xl transition-all duration-300 transform hover:scale-105 active:scale-95 w-full uppercase"
                                >
                                    –ó—É–ø–∏–Ω–∏—Ç–∏—Å—å (Stand)
                                </button>
                            </>
                        )}
                        {blackjackRoomState.status === "round_end" && (
                            <p className="text-center text-yellow-300 font-semibold text-lg">
                                –ù–æ–≤–∏–π —Ä–∞—É–Ω–¥ –Ω–µ–∑–∞–±–∞—Ä–æ–º...
                            </p>
                        )}
                        {/* Leave Room button for when player is in a room and not disconnected */}
                        {blackjackRoomState.room_id && blackjackRoomState.status !== "disconnected" && (
                            <button
                                onClick={() => {
                                    sendWsMessage("leave_room", { room_id: blackjackRoomState.room_id });
                                    // Reset local state immediately after sending leave_room
                                    setBlackjackRoomState({ // Reset to initial disconnected state
                                        room_id: null,
                                        status: "disconnected",
                                        dealer_hand: [],
                                        dealer_score: 0,
                                        players: [],
                                        current_player_turn: null,
                                        player_count: 0,
                                        min_players: 0,
                                        max_players: 0,
                                        timer: 0
                                    });
                                    setBlackjackGameMessage("–í–∏ –ø–æ–∫–∏–Ω—É–ª–∏ –∫—ñ–º–Ω–∞—Ç—É.");
                                    // Explicitly close WebSocket if it's still open after sending leave_room
                                    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
                                        wsRef.current.close(1000, "User left room.");
                                    }
                                }}
                                className="spin-button bg-gray-500 hover:bg-gray-600 text-white py-3 px-6 rounded-full text-lg shadow-xl transition-all duration-300 transform hover:scale-105 active:scale-95 w-full uppercase mt-3 md:mt-0"
                            >
                                –ó–∞–ª–∏—à–∏—Ç–∏ –∫—ñ–º–Ω–∞—Ç—É
                            </button>
                        )}
                    </div>

                    {/* Bet Input Modal - if we wanted variable bets */}
                    {showBetModal && (
                        <div className="modal fixed inset-0 flex items-center justify-center z-50 bg-black bg-opacity-70 active">
                            <div className="modal-content bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8 text-center w-11/12 max-w-sm relative border-2 border-yellow-400">
                                <button className="close-button absolute top-2 right-4 text-gray-400 hover:text-white text-3xl font-bold transition-colors duration-200" onClick={() => setShowBetModal(false)}>&times;</button>
                                <h3 className="text-xl font-bold mb-4">–ó—Ä–æ–±–∏—Ç–∏ –°—Ç–∞–≤–∫—É</h3>
                                <p className="mb-4">–í–∞—à–∞ –ø–æ—Ç–æ—á–Ω–∞ —Å—Ç–∞–≤–∫–∞: {BLACKJACK_BET_AMOUNT} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤.</p>
                                <button 
                                    onClick={() => { 
                                        sendWsMessage("bet", { amount: BLACKJACK_BET_AMOUNT }); 
                                        setShowBetModal(false); 
                                    }}
                                    className="bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold py-2 px-6 rounded-full text-lg shadow-md transition-all duration-300"
                                >
                                    –ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏ —Å—Ç–∞–≤–∫—É
                                </button>
                                <button
                                    onClick={() => setShowBetModal(false)}
                                    className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-full text-lg shadow-md transition-all duration-300 mt-2 ml-2"
                                >
                                    –°–∫–∞—Å—É–≤–∞—Ç–∏
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            );
        };


        // -----------------------------------------------------------------------------
        // Placeholder Game Components
        // -----------------------------------------------------------------------------
        const GamePlaceholder = ({ gameName, icon }) => {
            const { sendTelegramLog } = useUser();
            useEffect(() => {
                sendTelegramLog(`Navigated to placeholder game: ${gameName}`);
            }, [gameName, sendTelegramLog]);

            return (
                <div className="flex-grow flex flex-col items-center justify-center p-4 md:p-8 w-full">
                    <h1 className="text-4xl md:text-5xl font-extrabold text-yellow-400 mb-6 drop-shadow-lg leading-tight text-center">
                        {icon} {gameName} {icon}
                    </h1>
                    <p className="text-xl md:text-2xl text-gray-300 text-center max-w-md">
                        –¶—è –≥—Ä–∞ –∑–∞—Ä–∞–∑ —É —Ä–æ–∑—Ä–æ–±—Ü—ñ. –°–ª—ñ–¥–∫—É–π—Ç–µ –∑–∞ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è–º–∏!
                    </p>
                    <p className="mt-4 text-md text-gray-400">
                        –î—è–∫—É—î–º–æ –∑–∞ —Ç–µ—Ä–ø—ñ–Ω–Ω—è!
                    </p>
                </div>
            );
        };


        // -----------------------------------------------------------------------------
        // Top Header Component (Balance, XP, Level, Bonuses)
        // -----------------------------------------------------------------------------
        const TopHeader = () => { 
            const { user, fetchUserData, API_BASE_URL, sendTelegramLog } = useUser();
            const { showModal } = useModal(); // Use the new modal hook
            const [dailyBonusCooldownText, setDailyBonusCooldownText] = useState('');
            const [quickBonusCooldownText, setQuickBonusCooldownText] = useState('');

            // Helper for time formatting
            const formatTime = (ms) => {
                const totalSeconds = Math.floor(ms / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                
                if (hours > 0) {
                    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                } else {
                    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            };

            // Daily Bonus Logic
            const updateDailyBonusCountdown = useCallback(() => {
                const now = new Date();
                const cooldownDuration = 24 * 60 * 60 * 1000; // 24 hours in ms
                
                const dailyBonusButtonElement = document.getElementById('dailyBonusButton'); // Access via DOM
                if (!dailyBonusButtonElement) return;

                if (!user.lastDailyBonusClaim || (now.getTime() - user.lastDailyBonusClaim.getTime()) >= cooldownDuration) {
                    setDailyBonusCooldownText('');
                    dailyBonusButtonElement.disabled = false;
                    dailyBonusButtonElement.classList.add('pulsing');
                } else {
                    const timeLeft = cooldownDuration - (now.getTime() - user.lastDailyBonusClaim.getTime());
                    setDailyBonusCooldownText(`(${formatTime(timeLeft)})`);
                    dailyBonusButtonElement.disabled = true;
                    dailyBonusButtonElement.classList.remove('pulsing');
                }
            }, [user.lastDailyBonusClaim]);

            useEffect(() => {
                const interval = setInterval(updateDailyBonusCountdown, 1000);
                updateDailyBonusCountdown(); // Initial call
                return () => clearInterval(interval);
            }, [updateDailyBonusCountdown]);

            const handleClaimDailyBonus = async () => {
                if (!user.userId) {
                    showModal('‚ö†Ô∏è –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞–ø—É—Å—Ç—ñ—Ç—å –≥—Ä—É —á–µ—Ä–µ–∑ Telegram, —â–æ–± –æ—Ç—Ä–∏–º–∞—Ç–∏ User ID.', "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ");
                    return;
                }
                const dailyBonusButtonElement = document.getElementById('dailyBonusButton');
                if (dailyBonusButtonElement && dailyBonusButtonElement.disabled) return;

                if(dailyBonusButtonElement) {
                    dailyBonusButtonElement.disabled = true;
                    dailyBonusButtonElement.classList.remove('pulsing');
                }
                sendTelegramLog('Attempting to claim daily bonus...');

                try {
                    const response = await fetch(`${API_BASE_URL}/api/claim_daily_bonus`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.userId })
                    });

                    const data = await response.json();

                    if (response.ok) {
                        playDailyBonusSound();
                        showModal(`üéâ –í–∏ –æ—Ç—Ä–∏–º–∞–ª–∏ ${data.amount} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤!`, "–©–æ–¥–µ–Ω–Ω–∞ –í–∏–Ω–∞–≥–æ—Ä–æ–¥–∞!");
                        fetchUserData();
                        sendTelegramLog(`Daily Bonus claimed: ${data.amount}`);
                    } else {
                        showModal(`‚ùå –ü–æ–º–∏–ª–∫–∞: ${data.error || '–ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞.'}`, "–ü–æ–º–∏–ª–∫–∞ –í–∏–Ω–∞–≥–æ—Ä–æ–¥–∏");
                        fetchUserData(); // Fetch updated data to refresh cooldown
                        sendTelegramLog(`Daily Bonus API failed: ${data.error || 'Unknown'}`, 'JS_ERROR');
                    }
                } catch (error) {
                    console.error('–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ —â–æ–¥–µ–Ω–Ω–æ—ó –≤–∏–Ω–∞–≥–æ—Ä–æ–¥–∏:', error);
                    showModal('üö´ –ù–µ –≤–¥–∞–ª–æ—Å—è –∑ º—î–¥–Ω–∞—Ç–∏—Å—å —ñ–∑ —Å–µ—Ä–≤–µ—Ä–æ–º –¥–ª—è –≤–∏–Ω–∞–≥–æ—Ä–æ–¥–∏.', "–ü–æ–º–∏–ª–∫–∞");
                    if(dailyBonusButtonElement) {
                        dailyBonusButtonElement.disabled = false;
                        dailyBonusButtonElement.classList.add('pulsing');
                    }
                    sendTelegramLog(`Daily Bonus network error: ${error.message}`, 'JS_ERROR');
                }
            };

            // Quick Bonus Logic
            const updateQuickBonusCountdown = useCallback(() => {
                const now = new Date();
                const cooldownDuration = 15 * 60 * 1000; // 15 minutes in ms
                
                const quickBonusButtonElement = document.getElementById('quickBonusButton');
                const quickBonusCooldownElement = document.getElementById('quickBonusCooldown');
                if (!quickBonusButtonElement || !quickBonusCooldownElement) return;


                if (!user.lastQuickBonusClaim || (now.getTime() - user.lastQuickBonusClaim.getTime()) >= cooldownDuration) {
                    setQuickBonusCooldownText('');
                    quickBonusButtonElement.disabled = false;
                    quickBonusButtonElement.classList.add('pulsing');
                    quickBonusButtonElement.classList.remove('active-countdown'); // Hide timer
                } else {
                    const timeLeft = cooldownDuration - (now.getTime() - user.lastQuickBonusClaim.getTime());
                    setQuickBonusCooldownText(formatTime(timeLeft));
                    quickBonusButtonElement.disabled = true;
                    quickBonusButtonElement.classList.remove('pulsing');
                    quickBonusButtonElement.classList.add('active-countdown'); // Show timer
                }
            }, [user.lastQuickBonusClaim]);

            useEffect(() => {
                const interval = setInterval(updateQuickBonusCountdown, 1000);
                updateQuickBonusCountdown(); // Initial call
                return () => clearInterval(interval);
            }, [updateQuickBonusCountdown]);

            const handleClaimQuickBonus = async () => {
                if (!user.userId) {
                    showModal('‚ö†Ô∏è –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞–ø—É—Å—Ç—ñ—Ç—å –≥—Ä—É —á–µ—Ä–µ–∑ Telegram, —â–æ–± –æ—Ç—Ä–∏–º–∞—Ç–∏ User ID.', "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ");
                    return;
                }
                const quickBonusButtonElement = document.getElementById('quickBonusButton');
                if (quickBonusButtonElement && quickBonusButtonElement.disabled) return;

                if(quickBonusButtonElement) {
                    quickBonusButtonElement.disabled = true;
                    quickBonusButtonElement.classList.remove('pulsing');
                    quickBonusButtonElement.classList.remove('active-countdown');
                    setQuickBonusCooldownText('');
                }
                sendTelegramLog('Attempting to claim quick bonus...');

                try {
                    const response = await fetch(`${API_BASE_URL}/api/claim_quick_bonus`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.userId })
                    });

                    const data = await response.json();

                    if (response.ok) {
                        playQuickBonusSound();
                        showModal(`üí∞ –í–∏ –æ—Ç—Ä–∏–º–∞–ª–∏ ${data.amount} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤!`, "–®–≤–∏–¥–∫–∏–π –ë–æ–Ω—É—Å!");
                        fetchUserData();
                        sendTelegramLog(`Quick Bonus claimed: ${data.amount}`);
                    } else {
                        showModal(`‚ùå –ü–æ–º–∏–ª–∫–∞: ${data.error || '–ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞.'}`, "–ü–æ–º–∏–ª–∫–∞ –ë–æ–Ω—É—Å—É");
                        fetchUserData(); // Fetch updated data to refresh cooldown
                        sendTelegramLog(`Quick Bonus API failed: ${data.error || 'Unknown'}`, 'JS_ERROR');
                    }
                } catch (error) {
                    console.error('–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ —à–≤–∏–¥–∫–æ–≥–æ –±–æ–Ω—É—Å—É:', error);
                    showModal('üö´ –ù–µ –≤–¥–∞–ª–æ—Å—è –∑ º—î–¥–Ω–∞—Ç–∏—Å—å —ñ–∑ —Å–µ—Ä–≤–µ—Ä–æ–º –¥–ª—è —à–≤–∏–¥–∫–æ–≥–æ –±–æ–Ω—É—Å—É.', "–ü–æ–º–∏–ª–∫–∞");
                    if(quickBonusButtonElement) {
                        quickBonusButtonElement.disabled = false;
                        quickBonusButtonElement.classList.add('pulsing');
                    }
                    sendTelegramLog(`Quick Bonus network error: ${error.message}`, 'JS_ERROR');
                }
            };


            const xpProgress = Math.min(100, (user.xp / user.nextLevelXp) * 100);

            return (
                <div className="app-header w-full h-16 bg-gradient-to-b from-yellow-700 to-yellow-900 shadow-lg flex items-center justify-center text-xl font-bold text-gray-900 uppercase tracking-widest z-10 flex-shrink-0 relative">
                    –Ü–º–ø–µ—Ä—ñ—è –°–ª–æ—Ç–∞
                    {/* Quick Bonus Button */}
                    <button 
                        id="quickBonusButton" 
                        onClick={handleClaimQuickBonus}
                        className="quick-bonus-button absolute left-2 md:left-4 top-1/2 -translate-y-1/2 w-12 h-12 rounded-full bg-blue-600 hover:bg-blue-700 text-white flex items-center justify-center text-lg font-bold shadow-md transition-all duration-200 ease-in-out transform hover:scale-105 active:scale-95"
                    >
                        üí∞
                        <span id="quickBonusCooldown" className="quick-bonus-countdown">{quickBonusCooldownText}</span>
                    </button>
                    {/* Leaderboard Button was here, now removed as per your request to avoid duplication. Only in bottom nav now. */}

                    {/* Balance and Level Display */}
                    <div className="balance-area absolute top-16 left-1/2 transform -translate-x-1/2 bg-gray-800 rounded-b-xl py-2 px-4 shadow-inner border border-gray-700 border-t-0 w-full max-w-xs md:max-w-sm z-20">
                        <div className="flex justify-between items-center w-full mb-1">
                            <span className="text-base md:text-lg text-gray-300 font-medium">–ë–∞–ª–∞–Ω—Å:</span>
                            <span className={`font-bold text-yellow-300 text-2xl md:text-3xl ${user.balance !== 0 ? 'animate-pulse-balance' : ''}`}>{user.balance}</span>
                            <span className="text-base md:text-lg text-gray-300 font-medium ml-2">—Ñ–∞–Ω—Ç–∏–∫—ñ–≤</span>
                        </div>
                        <div className="level-progress w-full mt-1">
                            <div className="flex justify-between items-center text-xs text-gray-400 mb-0.5">
                                <span>–†—ñ–≤–µ–Ω—å: <span className="font-bold text-white">{user.level}</span></span>
                                <span>XP: <span className="font-bold text-white">{user.xp}</span>/<span className="font-bold text-white">{user.nextLevelXp}</span></span>
                            </div>
                            <div className="xp-bar w-full bg-gray-600 rounded-full h-2">
                                <div className="h-full bg-blue-500 rounded-full transition-all duration-300 ease-out" style={{ width: `${xpProgress}%` }}></div>
                            </div>
                        </div>
                        {/* Daily Bonus Button - moved here for visual grouping */}
                        <button 
                            id="dailyBonusButton" 
                            onClick={handleClaimDailyBonus}
                            className="daily-bonus-button bg-gradient-to-r from-blue-500 to-indigo-600 hover:from-blue-600 hover:to-indigo-700 text-white font-bold py-2 px-4 rounded-full text-sm shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 flex items-center justify-center whitespace-nowrap mt-2 w-full"
                        >
                            –©–æ–¥–µ–Ω–Ω–∞ –í–∏–Ω–∞–≥–æ—Ä–æ–¥–∞ <span id="dailyBonusCooldown" className="ml-2 text-xs text-blue-200">{dailyBonusCooldownText}</span>
                        </button>
                    </div>
                </div>
            );
        };


        // -----------------------------------------------------------------------------
        // Main App Component
        // -----------------------------------------------------------------------------
        function App() {
            const { isLoading, error, fetchUserData } = useUser();
            const { showModal } = useModal(); // Use the new modal hook
            const [currentPage, setCurrentPage] = useState('slots'); // 'slots', 'coin_flip', 'leaderboard', 'blackjack', 'game3', 'game4', 'game5'

            const renderGame = () => {
                if (isLoading) {
                    return (
                        <div className="flex flex-col items-center justify-center w-full h-full text-white">
                            <p className="text-xl">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö –≥—Ä–∞–≤—Ü—è...</p>
                        </div>
                    );
                }

                if (error) {
                    return (
                        <div className="flex flex-col items-center justify-center w-full h-full text-white text-center p-4">
                            <p className="text-xl text-red-500 font-bold mb-4">–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è:</p>
                            <p className="text-lg mb-6">{error}</p>
                            <button 
                                onClick={fetchUserData}
                                className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-full text-lg shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95"
                            >
                                –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –∑–Ω–æ–≤—É
                            </button>
                        </div>
                    );
                }

                switch (currentPage) {
                    case 'slots':
                        return <SlotMachine />;
                    case 'coin_flip':
                        return <CoinFlip />;
                    case 'leaderboard':
                        return <Leaderboard />;
                    case 'blackjack':
                        return <BlackjackGame />; 
                    case 'game3': 
                        return <GamePlaceholder gameName="–ö–æ–ª–µ—Å–æ –§–æ—Ä—Ç—É–Ω–∏" icon="üé≤" />;
                    case 'game5': 
                        return <GamePlaceholder gameName="–ü–æ–∫–µ—Ä" icon="üÉè" />;
                    default:
                        return <SlotMachine />;
                }
            };

            // Log for App component render
            useEffect(() => {
                if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                    Telegram.WebApp.sendData(`JS_LOG: App component rendered. Current page: ${currentPage}. IsLoading: ${isLoading}. Error: ${error}`);
                }
            }, [currentPage, isLoading, error]);


            return (
                <div className="casino-app-container relative w-full h-full flex flex-col items-center justify-between bg-gradient-to-br from-purple-900 via-gray-900 to-indigo-900 text-white overflow-hidden">
                    {/* Top Header with Balance, XP, Level, Bonuses */}
                    <TopHeader />

                    {/* Main Game Content Area - renders current game */}
                    <div className="relative flex-grow flex flex-col items-center justify-around w-full main-content-area overflow-y-auto min-h-0"> 
                        {renderGame()}
                    </div>

                    {/* Bottom Navigation */}
                    <div className="bottom-nav fixed bottom-0 w-full h-16 bg-gradient-to-t from-yellow-700 to-yellow-900 shadow-lg flex justify-around items-center z-30">
                        <button
                            onClick={() => setCurrentPage('slots')}
                            className={`nav-button p-2 rounded-full text-2xl transition-all duration-200 ${currentPage === 'slots' ? 'bg-yellow-500 text-gray-900 scale-110 shadow-lg' : 'text-gray-700 hover:text-gray-800'}`}
                        >
                            üé∞
                        </button>
                        <button
                            onClick={() => setCurrentPage('coin_flip')}
                            className={`nav-button p-2 rounded-full text-2xl transition-all duration-200 ${currentPage === 'coin_flip' ? 'bg-yellow-500 text-gray-900 scale-110 shadow-lg' : 'text-gray-700 hover:text-gray-800'}`}
                        >
                            ü™ô
                        </button>
                        <button
                            onClick={() => setCurrentPage('blackjack')} 
                            className={`nav-button p-2 rounded-full text-2xl transition-all duration-200 ${currentPage === 'blackjack' ? 'bg-yellow-500 text-gray-900 scale-110 shadow-lg' : 'text-gray-700 hover:text-gray-800'}`}
                        >
                            ‚ô†Ô∏è 
                        </button>
                        <button
                            onClick={() => setCurrentPage('leaderboard')}
                            className={`nav-button p-2 rounded-full text-2xl transition-all duration-200 ${currentPage === 'leaderboard' ? 'bg-yellow-500 text-gray-900 scale-110 shadow-lg' : 'text-gray-700 hover:text-gray-800'}`}
                        >
                            üëë
                        </button>
                        {/* Placeholder buttons for 2 more games */}
                        <button
                            onClick={() => setCurrentPage('game3')}
                            className={`nav-button p-2 rounded-full text-2xl transition-all duration-200 ${currentPage === 'game3' ? 'bg-yellow-500 text-gray-900 scale-110 shadow-lg' : 'text-gray-700 hover:text-gray-800'}`}
                        >
                            üé≤
                        </button>
                        <button
                            onClick={() => setCurrentPage('game5')}
                            className={`nav-button p-2 rounded-full text-2xl transition-all duration-200 ${currentPage === 'game5' ? 'bg-yellow-500 text-gray-900 scale-110 shadow-lg' : 'text-gray-700 hover:text-gray-800'}`}
                        >
                            üÉè
                        </button>
                    </div>

                    {/* Audio Context Activation Prompt */}
                    <div id="audioPrompt" className="audio-prompt fixed inset-0 bg-gray-900 bg-opacity-95 flex flex-col items-center justify-center text-center p-8 z-50 hidden">
                        <p className="text-xl md:text-2xl font-bold mb-4">–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å, —â–æ–± —É–≤—ñ–º–∫–Ω—É—Ç–∏ –∑–≤—É–∫</p>
                        <button id="activateAudioButton" className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-full text-lg shadow-lg transition-all duration-300 ease-in-out">
                            –£–≤—ñ–º–∫–Ω—É—Ç–∏
                        </button>
                    </div>
                </div>
            );
        }
        
        // This is the core mounting logic of the React app
        // It runs AFTER the Babel script has parsed everything above
        // And we ensure React and ReactDOM are actually loaded
        try {
            if (typeof React === 'undefined' || typeof ReactDOM === 'undefined') {
                const rootElement = document.getElementById('root');
                if (rootElement) {
                    rootElement.innerHTML = `<p class="text-red-500 text-center mt-10 text-lg">
                        –ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞: React –∞–±–æ ReactDOM –Ω–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ. <br/> –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è CDN.
                    </p>`;
                }
                if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                    Telegram.WebApp.sendData('JS_FATAL_REACT_ERROR: React or ReactDOM undefined.');
                }
                console.error("React or ReactDOM is undefined. Check CDN scripts.");
            } else {
                const rootElement = document.getElementById('root');
                const initialMessage = document.getElementById('initialLoadingMessage');

                if (!rootElement) {
                    console.error("Error: Root element with ID 'root' not found for ReactDOM.createRoot.");
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData('JS_ERROR: Root element not found for ReactDOM.');
                    }
                    if (initialMessage) {
                        initialMessage.textContent = '–ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞: –ö–æ—Ä–µ–Ω–µ–≤–∏–π –µ–ª–µ–º–µ–Ω—Ç –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.';
                        initialMessage.classList.add('text-red-500');
                    }
                } else {
                    // Remove loading message
                    if (initialMessage) {
                        initialMessage.remove();
                    }

                    const root = ReactDOM.createRoot(rootElement);
                    root.render(
                        <React.StrictMode>
                            <UserProvider>
                                <ModalProvider> {/* Wrap App with ModalProvider */}
                                    <App />
                                </ModalProvider>
                            </UserProvider>
                        </React.StrictMode>
                    );

                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData('JS_LOG: React app rendered successfully into DOM.');
                    }
                }
            }
        } catch (e) {
            console.error("Error during final React mounting:", e);
            const rootElement = document.getElementById('root');
            if (rootElement) {
                rootElement.innerHTML = `<p class="text-red-500 text-center mt-10 text-lg">
                    –ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫—É –≥—Ä–∏: <br/> ${e.message}
                    <br/> –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –∫–æ–Ω—Å–æ–ª—å –±—Ä–∞—É–∑–µ—Ä–∞ –∞–±–æ –ª–æ–≥–∏ Render.
                </p>`;
            }
            if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                Telegram.WebApp.sendData(`JS_FATAL_REACT_MOUNT_ERROR: ${e.message.substring(0, Math.min(e.message.length, 100))}`);
            }
        }
    </script>
</body>
</html>
