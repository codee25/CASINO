<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>–Ü–º–ø–µ—Ä—ñ—è –°–ª–æ—Ç–∞: –í—ñ—Ä—Ç—É–∞–ª—å–Ω–µ –ö–∞–∑–∏–Ω–æ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="./style.css">
    <!-- Third-party libraries that need to be globally available -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body class="flex flex-col items-center justify-between w-screen h-screen bg-gradient-to-br from-purple-900 via-gray-900 to-indigo-900 text-white overflow-hidden">
    <div id="root" class="relative w-full h-full flex flex-col items-center justify-start">
        <!-- React App will be mounted here -->
        <p id="initialLoadingMessage" class="text-xl text-white mt-10">
            –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –≥—Ä–∏... –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞—á–µ–∫–∞–π—Ç–µ.
        </p>
    </div>
    
    <!-- React and ReactDOM scripts -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>

    <!-- Your entire React App - processed by Babel in the browser -->
    <script type="text/babel" data-presets="react">
        // Log at the very beginning of this script
        if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
            Telegram.WebApp.sendData('JS_LOG: Babel script block started.');
        } else {
            console.error("JS_ERROR: Telegram.WebApp not available at Babel script block start.");
        }

        // Use window.React for unpkg.com global React
        const React = window.React;
        const { useState, useEffect, createContext, useContext, useCallback, useRef } = window.React;
        const ReactDOM = window.ReactDOM; // Ensure ReactDOM is also accessed globally

        // Ensure Tone is globally available from the CDN script in index.html
        const Tone = window.Tone || {
            context: { state: 'suspended', resume: async () => { console.warn("Tone.context.resume not available. Tone.js might not be loaded."); }, start: async () => { console.warn("Tone.context.start not available. Tone.js might not be loaded."); } },
            MembraneSynth: function() { return { toDestination: () => this, set: () => {}, triggerAttackRelease: () => {} }; },
            PolySynth: function() { return { toDestination: () => this, set: () => {}, triggerAttackRelease: () => {} }; },
            NoiseSynth: function() { return { toDestination: () => this, set: () => {}, triggerAttackRelease: () => {} }; }
        };


        // -----------------------------------------------------------------------------
        // Global User Context
        // -----------------------------------------------------------------------------
        const UserContext = createContext(null);

        const UserProvider = ({ children }) => {
            const [user, setUser] = useState({
                userId: null,
                username: 'Unnamed Player',
                balance: 0,
                xp: 0,
                level: 1,
                nextLevelXp: 100, // Default, will be updated from backend
                lastDailyBonusClaim: null,
                lastQuickBonusClaim: null
            });
            const [isLoading, setIsLoading] = useState(true);
            const [error, setError] = useState(null);

            // Backend API URL (–í–ê–® –ê–ö–¢–£–ê–õ–¨–ù–ò–ô URL!)
            // !!! –í–°–¢–ê–í–¢–ï –°–Æ–î–ò –ê–ö–¢–£–ê–õ–¨–ù–ò–ô URL –í–ê–®–û–ì–û WEB SERVICE (–ë–û–¢–ê) –ù–ê RENDER.COM !!!
            // –ù–ê–ü–†–ò–ö–õ–ê–î: 'https://–≤–∞—à-—É–Ω—ñ–∫–∞–ª—å–Ω–∏–π-–¥–æ–º–µ–Ω.onrender.com'
            // –ù–ï –ó–ê–ë–£–î–¨–¢–ï –ó–ú–Ü–ù–ò–¢–ò –¶–ï–ô –†–Ø–î–û–ö –ù–ê –°–í–Ü–ô –ê–ö–¢–£–ê–õ–¨–ù–ò–ô URL –ë–ï–ö–ï–ù–î–£!
            const API_BASE_URL = 'https://casino-0h0l.onrender.com';            // –ù–∞–ø—Ä–∏–∫–ª–∞–¥: 'https://casino-0h0l.onrender.com'
            // –ê–ë–û: 'http://localhost:8000' –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ—ó —Ä–æ–∑—Ä–æ–±–∫–∏

            // Helper to send logs to Telegram bot for debugging
            const sendTelegramLog = useCallback((message, type = 'JS_LOG') => {
                if (window.Telegram && window.Telegram.WebApp) {
                    window.Telegram.WebApp.sendData(`${type}: ${message}`);
                } else {
                    console.log(`[${type}] ${message}`);
                }
            }, []);

            const fetchUserData = useCallback(async () => {
                setIsLoading(true);
                setError(null);
                let currentUserId = null;
                let currentUsername = 'Unnamed Player';

                // Check for Telegram.WebApp availability and get user data
                if (window.Telegram && window.Telegram.WebApp) {
                    // Try to expand the web app as early as possible
                    window.Telegram.WebApp.expand(); 
                    if (window.Telegram.WebApp.initDataUnsafe?.user?.id) {
                        currentUserId = window.Telegram.WebApp.initDataUnsafe.user.id;
                        currentUsername = window.Telegram.WebApp.initDataUnsafe.user.username || window.Telegram.WebApp.initDataUnsafe.user.first_name || `–ì—Ä–∞–≤–µ—Ü—å ${String(currentUserId).slice(-4)}`;
                        sendTelegramLog(`WebApp Init: User ID ${currentUserId}, Username ${currentUsername}`);
                    } else {
                        sendTelegramLog('WebApp initialized, but user ID is missing from initDataUnsafe. Setting dummy user.', 'JS_WARN');
                        currentUserId = 'dummy_user_12345'; // Fallback to dummy ID if user data not available
                        currentUsername = 'DemoPlayer';
                        setError('–î–ª—è –ø–æ–≤–Ω–æ—ó —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—ñ –∑–∞–ø—É—Å—Ç—ñ—Ç—å –≥—Ä—É —á–µ—Ä–µ–∑ Telegram.');
                    }
                } else {
                    sendTelegramLog('Telegram.WebApp NOT Initialized (likely direct browser access or local testing). Setting dummy user.', 'JS_WARN');
                    currentUserId = 'dummy_user_local_123'; // Fallback to dummy ID for local testing
                    currentUsername = 'LocalPlayer';
                    setError('–î–ª—è –ø–æ–≤–Ω–æ—ó —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—ñ –∑–∞–ø—É—Å—Ç—ñ—Ç—å –≥—Ä—É —á–µ—Ä–µ–∑ Telegram. (–õ–æ–∫–∞–ª—å–Ω–æ)');
                }

                try {
                    // Only attempt fetch if a user ID is available (even dummy)
                    if (currentUserId) {
                        const response = await fetch(`${API_BASE_URL}/api/get_balance`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ user_id: currentUserId, username: currentUsername })
                        });

                        if (!response.ok) {
                            const errData = await response.json();
                            sendTelegramLog(`Balance fetch API failed: ${errData.detail || 'Unknown error'}`, 'JS_ERROR');
                            throw new Error(errData.detail || 'Failed to fetch user data');
                        }

                        const data = await response.json();
                        setUser(prevUser => {
                            const newUserState = {
                                userId: currentUserId,
                                username: currentUsername,
                                balance: data.balance,
                                xp: data.xp,
                                level: data.level,
                                nextLevelXp: data.next_level_xp,
                                lastDailyBonusClaim: data.last_daily_bonus_claim ? new Date(data.last_daily_bonus_claim) : null,
                                lastQuickBonusClaim: data.last_quick_bonus_claim ? new Date(data.last_quick_bonus_claim) : null
                            };
                            // Play level up sound if level increased
                            if (prevUser.level !== 1 && newUserState.level > prevUser.level) {
                                playLevelUpSound();
                                showCustomModal(`üéâ –í–∏ –¥–æ—Å—è–≥–ª–∏ –†—ñ–≤–Ω—è ${newUserState.level}! üéâ`, "–ü—ñ–¥–≤–∏—â–µ–Ω–Ω—è –†—ñ–≤–Ω—è!");
                            }
                            return newUserState;
                        });
                        sendTelegramLog('User data fetched and updated successfully from backend.');
                    } else {
                         sendTelegramLog('No valid user ID available for fetching data. Skipping API call.', 'JS_WARN');
                         setUser(prevUser => ({
                            ...prevUser,
                            userId: currentUserId,
                            username: currentUsername,
                            balance: 10000, // Default balance for unauthenticated dummy users
                            xp: 0,
                            level: 1,
                            nextLevelXp: 100
                         }));
                    }
                } catch (err) {
                    console.error('Error fetching user data:', err);
                    setError(err.message || '–ü–æ–º–∏–ª–∫–∞ –∑–≤ º—è–∑–∫—É –∑ —Å–µ—Ä–≤–µ—Ä–æ–º. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –∑ º—î–¥–Ω–∞–Ω–Ω—è.');
                    sendTelegramLog(`Error during user data fetch: ${err.message}`, 'JS_ERROR');
                } finally {
                    setIsLoading(false);
                }
            }, [sendTelegramLog, API_BASE_URL]);


            useEffect(() => {
                fetchUserData(); 
            }, [fetchUserData]);

            return (
                <UserContext.Provider value={{ user, setUser, fetchUserData, isLoading, error, API_BASE_URL, sendTelegramLog }}>
                    {children}
                </UserContext.Provider>
            );
        };

        const useUser = () => useContext(UserContext);


        // -----------------------------------------------------------------------------
        // Audio Context Setup (Tone.js)
        // -----------------------------------------------------------------------------
        let spinStartSound, reelStopSound, winSound, bigWinSound, loseSound, levelUpSound, dailyBonusSound, quickBonusSound, coinFlipSound;

        async function setupSounds() {
            if (Tone.context.state !== 'running') {
                try {
                    await Tone.start();
                    console.log("[Audio] AudioContext is running.");
                    document.getElementById('audioPrompt').style.display = 'none';
                } catch (e) {
                    console.error("[Audio] –ü–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó –∞—É–¥—ñ–æ:", e);
                    document.getElementById('audioPrompt').style.display = 'flex';
                    return;
                }
            } else {
                document.getElementById('audioPrompt').style.display = 'none';
            }

            // Initialize sounds ONLY after Tone.start() is successful or if already running
            if (!spinStartSound) { // Prevent re-initialization if already done
                spinStartSound = new Tone.MembraneSynth({ envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination();
                reelStopSound = new Tone.MembraneSynth({ envelope: { attack: 0.005, decay: 0.05, sustain: 0.01, release: 0.1 } }).toDestination();
                winSound = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 } }).toDestination();
                bigWinSound = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "triangle" }, envelope: { attack: 0.05, decay: 0.5, sustain: 0.2, release: 1.0 } }).toDestination();
                loseSound = new Tone.MembraneSynth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.4 } }).toDestination();
                levelUpSound = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "sawtooth" }, envelope: { attack: 0.02, decay: 0.3, sustain: 0.2, release: 0.8 } }).toDestination();
                dailyBonusSound = new Tone.MembraneSynth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 } }).toDestination();
                quickBonusSound = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.3 } }).toDestination();
                coinFlipSound = new Tone.MembraneSynth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.15, sustain: 0.05, release: 0.2 } }).toDestination();
            }
        }

        // Functions to play sounds - check if sound objects are initialized
        function playSpinStartSound() { if (spinStartSound && Tone.context.state === 'running') spinStartSound.triggerAttackRelease("C4", "8n"); }
        function playReelStopSound(note = "D4") { if (reelStopSound && Tone.context.state === 'running') reelStopSound.triggerAttackRelease(note, "16n"); }
        function playWinSoundEffect() { if (winSound && Tone.context.state === 'running') winSound.triggerAttackRelease(["C5", "E5", "G5"], "4n"); }
        function playBigWinSoundEffect() { if (bigWinSound && Tone.context.state === 'running') bigWinSound.triggerAttackRelease(["C5", "G5", "C6"], "1n"); }
        function playLoseSoundEffect() { if (loseSound && Tone.context.state === 'running') loseSound.triggerAttackRelease("C3", "4n"); }
        function playLevelUpSound() { if (levelUpSound && Tone.context.state === 'running') levelUpSound.triggerAttackRelease(["E4", "G4", "C5"], "0.8n"); }
        function playDailyBonusSound() { if (dailyBonusSound && Tone.context.state === 'running') dailyBonusSound.triggerAttackRelease("G4", "0.5n"); }
        function playQuickBonusSound() { if (quickBonusSound && Tone.context.state === 'running') quickBonusSound.triggerAttackRelease("A4", "0.2n"); }
        function playCoinFlipSound() { if (coinFlipSound && Tone.context.state === 'running') coinFlipSound.triggerAttackRelease("C5", "0.1s"); }


        // -----------------------------------------------------------------------------
        // Custom Modal for Alerts
        // -----------------------------------------------------------------------------
        function showCustomModal(msg, title = "–ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è") {
            const modalElement = document.getElementById('customModal');
            const modalMessageElement = document.getElementById('modalMessage');
            if (modalElement && modalMessageElement) {
                modalMessageElement.innerHTML = `<h3 class="text-xl font-bold mb-2">${title}</h3><p>${msg}</p>`;
                modalElement.classList.add('active');
                if (window.Telegram && window.Telegram.WebApp) {
                    Telegram.WebApp.sendData(`JS_LOG: Showing modal: ${title} - ${msg.substring(0, Math.min(msg.length, 50))}`);
                }
            }
        }
        // Add event listeners for modal close buttons outside React for simplicity
        document.addEventListener('DOMContentLoaded', () => {
            const customModal = document.getElementById('customModal');
            if (customModal) {
                customModal.querySelector('.close-button').addEventListener('click', () => {
                    customModal.classList.remove('active');
                });
                customModal.querySelector('.modal-content button').addEventListener('click', () => {
                    customModal.classList.remove('active');
                });
            }
            const audioPrompt = document.getElementById('audioPrompt');
            if (audioPrompt) {
                const activateAudioButton = document.getElementById('activateAudioButton');
                if (activateAudioButton) {
                    activateAudioButton.addEventListener('click', async () => {
                        await setupSounds();
                    });
                }
                // Initial check for audio context state
                if (Tone.context.state !== 'running') {
                    audioPrompt.style.display = 'flex';
                } else {
                    audioPrompt.style.display = 'none';
                }
            }
        });


        // -----------------------------------------------------------------------------
        // Slot Machine Game Component
        // -----------------------------------------------------------------------------
        const SYMBOLS = ['üçí', 'üçã', 'üçä', 'üçá', 'üîî', 'üíé', 'üçÄ'];
        const WILD_SYMBOL = '‚≠ê';
        const SCATTER_SYMBOL = 'üí∞';
        const ALL_REEL_SYMBOLS = [...SYMBOLS, WILD_SYMBOL, SCATTER_SYMBOL];
        const REEL_HEIGHT_PX = 90; // Default height for a symbol in a reel
        const REEL_SPIN_CYCLES = 5;
        const REEL_SPIN_DURATION_BASE = 0.8;
        const REEL_STOP_DURATION = 1.0;
        const REEL_STOP_EASE = "power2.out";
        const REEL_STOP_STAGGER = 0.2;
        const BET_AMOUNT = 100; // –°—Ç–∞–≤–∫–∞ –¥–ª—è —Å–ª–æ—Ç—ñ–≤

        const SlotMachine = () => {
            const { user, fetchUserData, API_BASE_URL, sendTelegramLog } = useUser();
            const [message, setMessage] = useState('');
            const [messageClass, setMessageClass] = useState('');
            const [isSpinning, setIsSpinning] = useState(false);
            const reelRefs = [useRef(null), useRef(null), useRef(null)]; // Refs for GSAP animation

            const animateReels = useCallback((finalSymbols) => {
                return new Promise(resolve => {
                    const masterTimeline = gsap.timeline({ onComplete: resolve });

                    reelRefs.forEach((reelRef, index) => {
                        const reelContent = reelRef.current.querySelector('.reel-content');
                        
                        const numSpinSymbols = REEL_SPIN_CYCLES * ALL_REEL_SYMBOLS.length;
                        let animationSymbols = [];
                        for (let i = 0; i < numSpinSymbols; i++) {
                            animationSymbols.push(ALL_REEL_SYMBOLS[Math.floor(Math.random() * ALL_REEL_SYMBOLS.length)]);
                        }
                        animationSymbols.push(finalSymbols[index]); // Ensure final symbol is at the end

                        reelContent.innerHTML = animationSymbols.map(s => `<div class="reel-symbol">${s}</div>`).join('');
                        
                        gsap.set(reelContent, { y: 0 }); // Reset position
                        reelRef.current.classList.add('spinning'); // Add spinning class

                        masterTimeline.to(reelContent, {
                            y: -(animationSymbols.length - 1) * REEL_HEIGHT_PX,
                            duration: REEL_SPIN_DURATION_BASE + (index * REEL_STOP_STAGGER),
                            ease: "linear",
                            onStart: () => {
                                if (index === 0) playSpinStartSound();
                            },
                            onUpdate: function() {
                                if (this.progress() > 0.1 && this.progress() < 0.95 && Tone.context.state === 'running') {
                                    playReelStopSound("C4");
                                }
                            }
                        }, 0);

                        masterTimeline.to(reelContent, {
                            y: -((animationSymbols.length - 1) * REEL_HEIGHT_PX),
                            duration: REEL_STOP_DURATION,
                            ease: REEL_STOP_EASE,
                            overwrite: true,
                            onComplete: () => {
                                reelRef.current.classList.remove('spinning');
                                // Set the exact final symbol
                                reelContent.innerHTML = `<div class="reel-symbol">${finalSymbols[index]}</div>`;
                                gsap.set(reelContent, { y: 0 }); // Ensure it snaps to correct position
                                playReelStopSound("G4");
                            }
                        }, `<${index * REEL_STOP_STAGGER}`); // Stagger starts
                    });
                });
            }, [reelRefs]);

            const handleSpin = async () => {
                if (!user.userId) {
                    showCustomModal('‚ö†Ô∏è –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞–ø—É—Å—Ç—ñ—Ç—å –≥—Ä—É —á–µ—Ä–µ–∑ Telegram, —â–æ–± –≥—Ä–∞—Ç–∏.', "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ");
                    return;
                }
                if (isSpinning || user.balance < BET_AMOUNT) {
                    if (user.balance < BET_AMOUNT) {
                        showCustomModal('–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —Ñ–∞–Ω—Ç–∏–∫—ñ–≤ –¥–ª—è —Å–ø—ñ–Ω–∞!', "–ù–∏–∑—å–∫–∏–π –ë–∞–ª–∞–Ω—Å");
                    }
                    return;
                }

                setIsSpinning(true);
                setMessage('');
                sendTelegramLog('Spin button clicked, starting spin process.');

                try {
                    const response = await fetch(`${API_BASE_URL}/api/spin`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.userId })
                    });

                    const data = await response.json();

                    if (response.ok) {
                        await animateReels(data.symbols); // Animate with actual results
                        
                        // === –î–û–î–ê–ù–û: –ó–ê—Ç—Ä–∏–º–∫–∞ –ø–µ—Ä–µ–¥ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è–º UI ===
                        await new Promise(resolve => setTimeout(resolve, 1500)); // –ó–∞—Ç—Ä–∏–º–∫–∞ 1.5 —Å–µ–∫—É–Ω–¥–∏

                        await fetchUserData(); // Update balance and XP from backend

                        if (data.winnings > 0) {
                            setMessage(`üéâ –í–∏ –≤–∏–≥—Ä–∞–ª–∏ ${data.winnings} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤! üéâ`);
                            if (data.winnings >= 500) {
                                setMessageClass('message big-win-message');
                                playBigWinSoundEffect();
                            } else {
                                setMessageClass('message win-message');
                                playWinSoundEffect();
                            }
                            sendTelegramLog(`Win: ${data.winnings} coins.`);
                        } else {
                            setMessage('üò¢ –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑!');
                            setMessageClass('message lose-message text-red-400');
                            playLoseSoundEffect();
                            sendTelegramLog('Lose on spin.');
                        }
                    } else {
                        showCustomModal(`‚ùå –ü–æ–º–∏–ª–∫–∞: ${data.detail || '–ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞.'}`, "–ü–æ–º–∏–ª–∫–∞ –°–ø—ñ–Ω–∞");
                        setMessageClass('text-red-500 font-bold');
                        playLoseSoundEffect();
                        sendTelegramLog(`Spin API failed: ${data.detail || 'Unknown'}`, 'JS_ERROR');
                    }
                } catch (error) {
                    console.error('–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ —Å–ø—ñ–Ω—ñ:', error);
                    showCustomModal('üö´ –ù–µ –≤–¥–∞–ª–æ—Å—è –∑ º—î–¥–Ω–∞—Ç–∏—Å—å —ñ–∑ —Å–µ—Ä–≤–µ—Ä–æ–º. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –∑ º—î–¥–Ω–∞–Ω–Ω—è.', "–ü–æ–º–∏–ª–∫–∞");
                    setMessageClass('text-red-500 font-bold');
                    playLoseSoundEffect();
                    sendTelegramLog(`Spin network error: ${error.message}`, 'JS_ERROR');
                } finally {
                    setIsSpinning(false);
                }
            };

            return (
                <div className="flex-grow flex flex-col items-center justify-around p-4 md:p-8 w-full">
                    <h1 className="text-3xl md:text-4xl font-extrabold text-yellow-400 mb-4 drop-shadow-lg leading-tight text-center">
                        –Ü–≥—Ä–æ–≤—ñ –ê–≤—Ç–æ–º–∞—Ç–∏
                    </h1>
                    
                    {/* Slot Machine Reels */}
                    <div className="slot-machine flex justify-center gap-2 mb-4 w-full max-w-xs md:max-w-sm mx-auto relative px-1 py-3">
                        <div className="absolute -top-3 left-1/2 transform -translate-x-1/2 w-3/4 h-2 bg-gradient-to-r from-yellow-400 to-red-500 rounded-t-lg shadow-lg"></div>
                        {/* Reel 1 */}
                        <div id="reel1" ref={reelRefs[0]} className="reel relative w-24 h-24 md:w-28 md:h-28 rounded-lg bg-gray-800 border-3 border-yellow-500 overflow-hidden shadow-inner transform-gpu">
                            <div className="reel-content absolute top-0 left-0 w-full h-full"></div>
                        </div>
                        {/* Reel 2 */}
                        <div id="reel2" ref={reelRefs[1]} className="reel relative w-24 h-24 md:w-28 md:h-28 rounded-lg bg-gray-800 border-3 border-yellow-500 overflow-hidden shadow-inner transform-gpu">
                            <div className="reel-content absolute top-0 left-0 w-full h-full"></div>
                        </div>
                        {/* Reel 3 */}
                        <div id="reel3" ref={reelRefs[2]} className="reel relative w-24 h-24 md:w-28 md:h-28 rounded-lg bg-gray-800 border-3 border-yellow-500 overflow-hidden shadow-inner transform-gpu">
                            <div className="reel-content absolute top-0 left-0 w-full h-full"></div>
                            </div>
                        <div className="absolute -bottom-3 left-1/2 transform -translate-x-1/2 w-3/4 h-2 bg-gradient-to-r from-red-500 to-yellow-400 rounded-b-lg shadow-lg"></div>
                    </div>

                    {/* Spin Button */}
                    <div className="game-controls flex flex-col md:flex-row gap-3 mb-4 w-full max-w-xs md:max-w-sm">
                        <button 
                            id="spinButton"
                            onClick={handleSpin}
                            disabled={isSpinning || user.balance < BET_AMOUNT}
                            className={`spin-button bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white font-extrabold py-3 px-6 rounded-full text-lg md:text-xl shadow-xl transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 w-full uppercase tracking-wider flex items-center justify-center ${!isSpinning && user.balance >= BET_AMOUNT ? 'pulsing' : ''}`}
                        >
                            –ö—Ä—É—Ç–∏—Ç–∏! (–°—Ç–∞–≤–∫–∞: {BET_AMOUNT})
                        </button>
                    </div>
                    
                    <div id="message" className={`message text-base md:text-lg font-semibold mt-4 min-h-[30px] flex items-center justify-center text-center w-full max-w-sm ${messageClass}`}>
                        {message}
                    </div>
                </div>
            );
        };


        // -----------------------------------------------------------------------------
        // Coin Flip Game Component (New Game)
        // -----------------------------------------------------------------------------
        const COIN_FLIP_BET_AMOUNT = 50; // –°—Ç–∞–≤–∫–∞ –¥–ª—è –º–æ–Ω–µ—Ç–∫–∏

        const CoinFlip = () => {
            const { user, fetchUserData, API_BASE_URL, sendTelegramLog } = useUser();
            const [message, setMessage] = useState('');
            const [resultCoin, setResultCoin] = useState(''); // 'heads', 'tails', or 'flipping'
            const [isFlipping, setIsFlipping] = useState(false);
            const [lastChoice, setLastChoice] = useState(null); // To show user's choice

            const handleFlip = async (choice) => {
                if (!user.userId) {
                    showCustomModal('‚ö†Ô∏è –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞–ø—É—Å—Ç—ñ—Ç—å –≥—Ä—É —á–µ—Ä–µ–∑ Telegram, —â–æ–± –≥—Ä–∞—Ç–∏.', "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ");
                    return;
                }
                if (isFlipping || user.balance < COIN_FLIP_BET_AMOUNT) {
                    if (user.balance < COIN_FLIP_BET_AMOUNT) {
                        showCustomModal('–ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ —Ñ–∞–Ω—Ç–∏–∫—ñ–≤ –¥–ª—è –ø—ñ–¥–∫–∏–¥–∞–Ω–Ω—è –º–æ–Ω–µ—Ç–∫–∏!', "–ù–∏–∑—å–∫–∏–π –ë–∞–ª–∞–Ω—Å");
                    }
                    return;
                }

                setIsFlipping(true);
                setMessage('');
                setResultCoin('flipping'); // Indicate flipping state visually
                setLastChoice(choice);
                playCoinFlipSound();
                sendTelegramLog(`Coin Flip: User chose ${choice}, starting flip.`);

                try {
                    const response = await fetch(`${API_BASE_URL}/api/coin_flip`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.userId, choice: choice })
                    });

                    const data = await response.json();

                    if (response.ok) {
                        // Simulate flip animation time
                        await new Promise(resolve => setTimeout(resolve, 1500)); 

                        setResultCoin(data.result); // 'heads' or 'tails' from backend
                        setMessage(data.message); // Win/lose message from backend
                        await fetchUserData(); // Update balance and XP from backend
                        sendTelegramLog(`Coin Flip Result: ${data.result}, Winnings: ${data.winnings}`);
                    } else {
                        showCustomModal(`‚ùå –ü–æ–º–∏–ª–∫–∞: ${data.detail || '–ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞.'}`, "–ü–æ–º–∏–ª–∫–∞ –ü—ñ–¥–∫–∏–¥–∞–Ω–Ω—è");
                        sendTelegramLog(`Coin Flip API failed: ${data.detail || 'Unknown'}`, 'JS_ERROR');
                    }
                } catch (error) {
                    console.error('–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –ø—ñ–¥–∫–∏–¥–∞–Ω–Ω—ñ –º–æ–Ω–µ—Ç–∫–∏:', error);
                    showCustomModal('üö´ –ù–µ –≤–¥–∞–ª–æ—Å—è –∑ º—î–¥–Ω–∞—Ç–∏—Å—å —ñ–∑ —Å–µ—Ä–≤–µ—Ä–æ–º. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –∑ º—î–¥–Ω–∞–Ω–Ω—è.', "–ü–æ–º–∏–ª–∫–∞");
                    sendTelegramLog(`Coin Flip network error: ${error.message}`, 'JS_ERROR');
                } finally {
                    setIsFlipping(false);
                }
            };

            const getCoinImage = (result) => {
                if (result === 'heads') {
                    return (
                        <svg className="w-full h-full" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="50" cy="50" r="48" fill="#FFD700" stroke="#DAA520" strokeWidth="2"/>
                            <path d="M50 20C35 20 25 35 25 50C25 65 35 80 50 80C65 80 75 65 75 50C75 35 65 20 50 20ZM50 30C58.2843 30 65 36.7157 65 45H50V30ZM50 70C41.7157 70 35 63.2843 35 55H50V70Z" fill="#8B4513"/>
                            <text x="50" y="55" fontFamily="Arial" fontSize="20" fontWeight="bold" fill="#F5F5DC" textAnchor="middle">–û–†–ï–õ</text>
                        </svg>
                    );
                } else if (result === 'tails') {
                    return (
                        <svg className="w-full h-full" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="50" cy="50" r="48" fill="#C0C0C0" stroke="#A9A9A9" strokeWidth="2"/>
                            <path d="M50 20C35 20 25 35 25 50C25 65 35 80 50 80C65 80 75 65 75 50C75 35 65 20 50 20ZM50 30C58.2843 30 65 36.7157 65 45H50V30ZM50 70C41.7157 70 35 63.2843 35 55H50V70Z" fill="#2F4F4F"/>
                            <text x="50" y="55" fontFamily="Arial" fontSize="20" fontWeight="bold" fill="#F5F5DC" textAnchor="middle">–†–ï–®–ö–ê</text>
                        </svg>
                    );
                }
                return (
                    <svg className="w-full h-full" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="50" cy="50" r="48" fill="#FFD700" stroke="#DAA520" strokeWidth="2"/>
                        <text x="50" y="58" fontFamily="Arial" fontSize="40" fontWeight="bold" fill="#8B4513" textAnchor="middle">?</text>
                    </svg>
                );
            };


            return (
                <div className="flex-grow flex flex-col items-center justify-around p-4 md:p-8 w-full">
                    {/* Removed H1 "–ü—ñ–¥–∫–∏–¥–∞–Ω–Ω—è –ú–æ–Ω–µ—Ç–∫–∏" */}

                    <div className="coin-flip-area flex flex-col items-center mb-6">
                        <div className={`coin-display transition-transform duration-500 ease-out ${isFlipping ? 'animate-spin-3d' : ''}`}>
                            {getCoinImage(resultCoin)}
                        </div>
                        {/* Show message from backend after flip */}
                        {!isFlipping && message && (
                            <p className={`message text-gray-300 text-lg mt-2 text-center font-bold ${message.includes('–í—ñ—Ç–∞—î–º–æ') ? 'text-green-400' : 'text-red-400'}`}>
                                {message}
                            </p>
                        )}
                        {/* Show user's choice while flipping or before result, if no message */}
                        {isFlipping && lastChoice && <p className="text-gray-300 text-lg mt-2">–í–∞—à –≤–∏–±—ñ—Ä: {lastChoice === 'heads' ? '–û—Ä–µ–ª' : '–†–µ—à–∫–∞'}</p>}
                        {!isFlipping && !message && lastChoice && <p className="text-gray-300 text-lg mt-2">–í–∏ –æ–±—Ä–∞–ª–∏: {lastChoice === 'heads' ? '–û—Ä–µ–ª' : '–†–µ—à–∫–∞'}</p>}

                    </div>

                    <div className="game-controls flex flex-col md:flex-row gap-3 mb-4 w-full max-w-xs md:max-w-sm">
                        <button
                            onClick={() => handleFlip('heads')}
                            disabled={isFlipping || user.balance < COIN_FLIP_BET_AMOUNT}
                            className="spin-button bg-gradient-to-r from-blue-500 to-indigo-600 hover:from-blue-600 hover:to-indigo-700 text-white font-extrabold py-3 px-6 rounded-full text-lg md:text-xl shadow-xl transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 w-full uppercase tracking-wider flex items-center justify-center"
                        >
                            –û—Ä–µ–ª (–°—Ç–∞–≤–∫–∞: {COIN_FLIP_BET_AMOUNT})
                        </button>
                        <button
                            onClick={() => handleFlip('tails')}
                            disabled={isFlipping || user.balance < COIN_FLIP_BET_AMOUNT}
                            className="spin-button bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 text-white font-extrabold py-3 px-6 rounded-full text-lg md:text-xl shadow-xl transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 w-full uppercase tracking-wider flex items-center justify-center mt-3 md:mt-0"
                        >
                            –†–µ—à–∫–∞ (–°—Ç–∞–≤–∫–∞: {COIN_FLIP_BET_AMOUNT})
                        </button>
                    </div>
                </div>
            );
        };


        // -----------------------------------------------------------------------------
        // Leaderboard Component
        // -----------------------------------------------------------------------------
        const Leaderboard = () => {
            const { API_BASE_URL, sendTelegramLog } = useUser();
            const [leaderboardData, setLeaderboardData] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);

            const fetchLeaderboard = useCallback(async () => {
                setLoading(true);
                setError(null);
                sendTelegramLog('Fetching leaderboard data...');
                try {
                    const response = await fetch(`${API_BASE_URL}/api/get_leaderboard`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({})
                    });

                    if (!response.ok) {
                        const errData = await response.json();
                        sendTelegramLog(`Leaderboard API error: ${errData.detail || 'Unknown'}`, 'JS_ERROR');
                        throw new Error(errData.detail || 'Failed to fetch leaderboard data');
                    }

                    const data = await response.json();
                    sendTelegramLog(`Leaderboard data received, count: ${data.leaderboard ? data.leaderboard.length : 0}`);
                    
                    // Sorting is handled by backend query (ORDER BY level DESC, xp DESC)
                    setLeaderboardData(data.leaderboard || []);

                } catch (err) {
                    console.error('Error fetching leaderboard:', err);
                    setError(err.message || '–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–æ—à–∫–∏ –ª—ñ–¥–µ—Ä—ñ–≤.');
                    sendTelegramLog(`Leaderboard network error: ${err.message}`, 'JS_ERROR');
                } finally {
                    setLoading(false);
                }
            }, [API_BASE_URL, sendTelegramLog]);

            useEffect(() => {
                fetchLeaderboard();
            }, [fetchLeaderboard]);

            return (
                <div className="flex-grow flex flex-col items-center justify-start p-4 md:p-8 w-full">
                    <h2 className="text-3xl font-extrabold text-yellow-400 mb-6">üëë –î–æ—à–∫–∞ –õ—ñ–¥–µ—Ä—ñ–≤ üëë</h2>
                    <div id="leaderboardTableContainer" className="overflow-x-auto w-full max-w-lg bg-gray-800 rounded-xl shadow-2xl p-4 border-2 border-yellow-400">
                        {loading && <p className="text-yellow-300 mt-4 text-center">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</p>}
                        {error && <p className="text-red-500 mt-4 text-center">{error}</p>}
                        {!loading && !error && leaderboardData.length === 0 && (
                            <p className="py-4 text-center text-gray-400">–ù–∞—Ä–∞–∑—ñ –Ω–µ–º–∞—î –ª—ñ–¥–µ—Ä—ñ–≤. –ë—É–¥—å –ø–µ—Ä—à–∏–º!</p>
                        )}
                        {!loading && !error && leaderboardData.length > 0 && (
                            <table className="w-full text-left text-sm md:text-base text-gray-300">
                                <thead className="text-xs md:text-sm text-gray-100 uppercase bg-gray-700">
                                    <tr>
                                        <th scope="col" className="py-2 px-3">#</th>
                                        <th scope="col" className="py-2 px-3">–Ü–º'—è</th>
                                        {/* Show Level and XP instead of Balance, as it's more relevant for ranking */}
                                        <th scope="col" className="py-2 px-3 text-right">–†—ñ–≤–µ–Ω—å</th>
                                        <th scope="col" className="py-2 px-3 text-right">XP</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {leaderboardData.map((player, index) => (
                                        <tr key={index} className={(index % 2 === 0) ? 'bg-gray-800' : 'bg-gray-700'}>
                                            <td className="py-2 px-3 font-bold">{index + 1}</td>
                                            <td className="py-2 px-3">{player.username}</td>
                                            <td className="py-2 px-3 text-right">{player.level}</td>
                                            <td className="py-2 px-3 text-right">{player.xp}</td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        )}
                    </div>
                </div>
            );
        };

        // -----------------------------------------------------------------------------
        // Blackjack Game Component (Multiplayer)
        // -----------------------------------------------------------------------------
        const BLACKJACK_BET_AMOUNT = 200; // Fixed bet amount for Blackjack

        const BlackjackGame = () => {
            const { user, fetchUserData, API_BASE_URL, sendTelegramLog } = useUser();
            const [ws, setWs] = useState(null);
            const [roomState, setRoomState] = useState({
                room_id: null,
                status: "connecting", // connecting, waiting, starting_timer, betting, playing, dealer_turn, round_end
                dealer_hand: [],
                dealer_score: 0,
                players: [],
                current_player_turn: null,
                player_count: 0,
                min_players: 0,
                max_players: 0,
                timer: 0 // for game start countdown
            });
            const [gameMessage, setGameMessage] = useState("–ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ –≥—Ä–∏...");
            const [betInput, setBetInput] = useState(BLACKJACK_BET_AMOUNT);
            const [showBetModal, setShowBetModal] = useState(false); // State to control bet input modal

            const getCardDisplay = (card) => {
                if (card === "Hidden") return "üÇ†"; // Card back
                const rank = card.slice(0, -1);
                const suit = card.slice(-1);
                let colorClass = '';
                if (suit === '‚ô•' || suit === '‚ô¶') {
                    colorClass = 'text-red-600'; // Red for hearts/diamonds
                } else {
                    colorClass = 'text-gray-900'; // Black for spades/clubs
                }
                return (
                    <div className={`card ${colorClass}`}>
                        <span className="card-rank">{rank}</span>
                        <span className="card-suit">{suit}</span>
                    </div>
                );
            };

            const sendWsMessage = useCallback((action, payload = {}) => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    const message = { action, ...payload };
                    ws.send(JSON.stringify(message));
                    sendTelegramLog(`WS Sent: ${action} with payload ${JSON.stringify(payload).substring(0, 50)}`);
                } else {
                    sendTelegramLog(`WS Error: Tried to send ${action} but WebSocket not open.`, 'JS_ERROR');
                }
            }, [ws, sendTelegramLog]);

            useEffect(() => {
                if (!user.userId || !API_BASE_URL) return;

                // Dynamically determine WebSocket protocol based on API_BASE_URL
                const apiBaseUrlObj = new URL(API_BASE_URL);
                const wsProtocol = apiBaseUrlObj.protocol === 'https:' ? 'wss:' : 'ws:';
                const websocketUrl = `${wsProtocol}//${apiBaseUrlObj.host}/ws/${user.userId}`;

                sendTelegramLog(`Attempting to connect WebSocket to: ${websocketUrl}`);
                const newWs = new WebSocket(websocketUrl);

                newWs.onopen = () => {
                    sendTelegramLog("WebSocket connected for Blackjack.");
                    setGameMessage("–ü—ñ–¥–∫–ª—é—á–µ–Ω–æ. –®—É–∫–∞—î–º–æ –∫—ñ–º–Ω–∞—Ç—É...");
                    // Immediately request state upon connection to get current room status
                    sendWsMessage("request_state"); 
                };

                newWs.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    sendTelegramLog(`WS Received: ${JSON.stringify(message).substring(0, 100)}`);

                    if (message.type === "error") {
                        showCustomModal(message.message, "–ü–æ–º–∏–ª–∫–∞ –ì—Ä–∏");
                        setGameMessage(message.message);
                    } else if (message.type === "game_message") {
                        setGameMessage(message.message);
                    } else if (message.type === "level_up") {
                        playLevelUpSound();
                        showCustomModal(`üéâ –í–∏ –¥–æ—Å—è–≥–ª–∏ –†—ñ–≤–Ω—è ${message.level}! üéâ`, "–ü—ñ–¥–≤–∏—â–µ–Ω–Ω—è –†—ñ–≤–Ω—è!");
                    } else if (message.room_id) { // It's a room state update
                        setRoomState(prevState => {
                            // Only update timer if it's counting down from a larger number
                            const newTimer = message.status === "starting_timer" ? (prevState.timer > message.timer ? prevState.timer : message.timer) : 0;
                            return { ...message, timer: newTimer };
                        });
                        setGameMessage(getGameStatusMessage(message, user.userId));
                        fetchUserData(); // Update balance etc. from user context
                    } else if (message.type === "round_result") {
                        const { message: resultMsg, winnings, balance, xp, level, next_level_xp, final_player_score, final_dealer_score } = message;
                        setGameMessage(resultMsg);
                        showCustomModal(
                            `–†–µ–∑—É–ª—å—Ç–∞—Ç: ${resultMsg}<br/>–í–∞—à —Ä–∞—Ö—É–Ω–æ–∫: ${final_player_score}<br/>–†–∞—Ö—É–Ω–æ–∫ –¥–∏–ª–µ—Ä–∞: ${final_dealer_score}<br/>–í–∏–≥—Ä–∞—à: ${winnings} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤!`,
                            "–†–µ–∑—É–ª—å—Ç–∞—Ç –†–∞—É–Ω–¥—É"
                        );
                        if (winnings > 0) {
                            playWinSoundEffect();
                        } else {
                            playLoseSoundEffect();
                        }
                        // Update user context after game result
                        fetchUserData();
                    }
                };

                newWs.onclose = (event) => {
                    sendTelegramLog(`WebSocket disconnected: Code ${event.code}, Reason: ${event.reason}.`, 'JS_WARN');
                    setGameMessage("–í—ñ–¥–∫–ª—é—á–µ–Ω–æ –≤—ñ–¥ –≥—Ä–∏. –°–ø—Ä–æ–±—É–π—Ç–µ –æ–Ω–æ–≤–∏—Ç–∏.");
                    setRoomState(prev => ({ ...prev, status: "disconnected" }));
                    setWs(null);
                };

                newWs.onerror = (error) => {
                    sendTelegramLog(`WebSocket error: ${error.message}`, 'JS_ERROR');
                    setGameMessage(`–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è: ${error.message}`);
                    setRoomState(prev => ({ ...prev, status: "error" }));
                };

                setWs(newWs);

                // Clean up on component unmount
                return () => {
                    if (newWs.readyState === WebSocket.OPEN) {
                        newWs.close();
                    }
                };
            }, [user.userId, API_BASE_URL, sendWsMessage, sendTelegramLog, fetchUserData]);


            // Timer countdown effect
            useEffect(() => {
                let timerInterval;
                if (roomState.status === "starting_timer" && roomState.timer > 0) {
                    timerInterval = setInterval(() => {
                        setRoomState(prevState => {
                            if (prevState.timer <= 1) {
                                clearInterval(timerInterval);
                                return { ...prevState, timer: 0 };
                            }
                            return { ...prevState, timer: prevState.timer - 1 };
                        });
                    }, 1000);
                } else if (roomState.status !== "starting_timer" && timerInterval) {
                     clearInterval(timerInterval);
                }
                return () => clearInterval(timerInterval);
            }, [roomState.status, roomState.timer]);

            const getGameStatusMessage = (state, currentUserId) => {
                if (!state || !state.room_id) return "–û—á—ñ–∫—É–≤–∞–Ω–Ω—è –∫—ñ–º–Ω–∞—Ç–∏...";
                
                const currentPlayer = state.players.find(p => p.user_id === currentUserId);
                if (!currentPlayer) return "–í–∏ –Ω–µ –≤ —Ü—ñ–π –∫—ñ–º–Ω–∞—Ç—ñ. –ü–µ—Ä–µ–ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è...";

                switch (state.status) {
                    case "connecting": return "–ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ —Å–µ—Ä–≤–µ—Ä–∞...";
                    case "waiting": return `–û—á—ñ–∫—É–≤–∞–Ω–Ω—è –≥—Ä–∞–≤—Ü—ñ–≤ (${state.player_count}/${state.min_players}). ..`;
                    case "starting_timer": return `–ì—Ä–∞ —Ä–æ–∑–ø–æ—á–Ω–µ—Ç—å—Å—è —á–µ—Ä–µ–∑ ${state.timer} —Å–µ–∫—É–Ω–¥. –ì–æ—Ç—É–π—Ç–µ—Å—å! (${state.player_count}/${state.min_players})`;
                    case "betting": return "–ó—Ä–æ–±—ñ—Ç—å –≤–∞—à—É —Å—Ç–∞–≤–∫—É!";
                    case "playing": 
                        if (state.current_player_turn === currentUserId) {
                            return "–í–∞—à —Ö—ñ–¥! (–£–¥–∞—Ä / –°—Ç–æ–ø)";
                        } else {
                            const activePlayer = state.players.find(p => p.user_id === state.current_player_turn);
                            return `–•—ñ–¥ –≥—Ä–∞–≤—Ü—è: ${activePlayer ? activePlayer.username : '–ù–µ–≤—ñ–¥–æ–º–∏–π'}`;
                        }
                    case "dealer_turn": return "–•—ñ–¥ –¥–∏–ª–µ—Ä–∞...";
                    case "round_end": return "–†–∞—É–Ω–¥ –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –†–µ–∑—É–ª—å—Ç–∞—Ç–∏...";
                    case "disconnected": return "–í–∏ –≤—ñ–¥–∫–ª—é—á–µ–Ω—ñ –≤—ñ–¥ –∫—ñ–º–Ω–∞—Ç–∏. –û–Ω–æ–≤—ñ—Ç—å —Å—Ç–æ—Ä—ñ–Ω–∫—É.";
                    case "error": return "–ü–æ–º–∏–ª–∫–∞ –≥—Ä–∏. –°–ø—Ä–æ–±—É–π—Ç–µ –æ–Ω–æ–≤–∏—Ç–∏.";
                    default: return `–°—Ç–∞—Ç—É—Å –∫—ñ–º–Ω–∞—Ç–∏: ${state.status}`;
                }
            };
            
            const renderPlayerHand = (player) => {
                const isCurrentPlayer = player.user_id === user.userId;
                return (
                    <div key={player.user_id} className={`player-card-container ${roomState.current_player_turn === player.user_id ? 'current-turn-highlight' : ''}`}>
                        <p className="player-username font-bold text-lg mb-1">{player.username} {isCurrentPlayer ? "(–í–∏)" : ""}</p>
                        <div className="flex flex-wrap justify-center gap-1 mb-1">
                            {player.hand.map((cardStr, idx) => (
                                <div key={idx} className="card-item relative">{getCardDisplay(cardStr)}</div>
                            ))}
                        </div>
                        <p className="text-sm">–†–∞—Ö—É–Ω–æ–∫: {player.score} | –°—Ç–∞–≤–∫–∞: {player.bet}</p>
                        {roomState.status === "betting" && !player.has_bet && isCurrentPlayer && (
                            <p className="text-yellow-300 text-sm animate-pulse">–ó—Ä–æ–±—ñ—Ç—å —Å—Ç–∞–≤–∫—É!</p>
                        )}
                    </div>
                );
            };

            // Determine if the "Make Bet" button should be active for the current user
            const canMakeBet = roomState.status === "betting" && user.balance >= BLACKJACK_BET_AMOUNT && roomState.players.some(p => p.user_id === user.userId && !p.has_bet);
            const canHitStand = roomState.status === "playing" && roomState.current_player_turn === user.userId;
            const isWaitingForOthersToBet = roomState.status === "betting" && roomState.players.some(p => p.user_id === user.userId && p.has_bet) && !allPlayersHaveBet();

            const allPlayersHaveBet = () => {
                if (roomState.players.length === 0) return false;
                return roomState.players.every(p => p.has_bet);
            };


            return (
                <div className="blackjack-game flex-grow flex flex-col items-center justify-between p-4 md:p-8 w-full">
                    <h1 className="text-3xl md:text-4xl font-extrabold text-yellow-400 mb-4 drop-shadow-lg leading-tight text-center">
                        ‚ô¶Ô∏è –ë–ª–µ–∫–¥–∂–µ–∫ ‚ô¶Ô∏è
                    </h1>
                    
                    <div className="game-status-message-box bg-gray-700 p-3 rounded-lg w-full max-w-lg text-center shadow-lg mb-4 border border-yellow-500">
                        <p className="text-xl font-bold text-yellow-300">{gameMessage}</p>
                    </div>

                    {/* Timer display for starting game */}
                    {roomState.status === "starting_timer" && roomState.timer > 0 && (
                        <div className="text-4xl font-extrabold text-red-500 mb-4 animate-pulse-fast">
                            {roomState.timer}
                        </div>
                    )}

                    {/* Dealer's Hand */}
                    <div className="dealer-area bg-gray-800 p-4 rounded-xl shadow-lg w-full max-w-lg mb-4 text-center border-2 border-green-700">
                        <h2 className="text-2xl font-bold text-orange-400 mb-2">–î–∏–ª–µ—Ä: {roomState.status === "playing" || roomState.status === "dealer_turn" || roomState.status === "round_end" ? roomState.dealer_score : (roomState.dealer_hand.length > 1 ? roomState.dealer_hand[0].slice(0,-1) : '')}</h2>
                        <div className="flex justify-center gap-2 flex-wrap">
                            {roomState.dealer_hand.map((cardStr, idx) => (
                                <div key={idx} className="card-item">{getCardDisplay(cardStr)}</div>
                            ))}
                        </div>
                    </div>

                    {/* Players' Hands */}
                    <div className="players-area flex-grow w-full max-w-lg overflow-y-auto p-2 bg-gray-900 rounded-xl shadow-inner border border-gray-700">
                        {roomState.players.length === 0 ? (
                            <p className="text-center text-gray-400 mt-4">–û—á—ñ–∫—É–≤–∞–Ω–Ω—è –≥—Ä–∞–≤—Ü—ñ–≤...</p>
                        ) : (
                            roomState.players.map(renderPlayerHand)
                        )}
                    </div>
                    
                    {/* Game Controls */}
                    <div className="game-controls flex flex-col md:flex-row gap-3 mt-4 w-full max-w-xs md:max-w-md">
                        {roomState.status === "betting" && (
                            <>
                                <button
                                    onClick={() => setShowBetModal(true)}
                                    disabled={!canMakeBet || isWaitingForOthersToBet}
                                    className="spin-button bg-gradient-to-r from-green-500 to-emerald-600 text-white py-3 px-6 rounded-full text-lg shadow-xl transition-all duration-300 transform hover:scale-105 active:scale-95 w-full uppercase"
                                >
                                    –ó—Ä–æ–±–∏—Ç–∏ —Å—Ç–∞–≤–∫—É ({BLACKJACK_BET_AMOUNT})
                                </button>
                                {isWaitingForOthersToBet && (
                                    <p className="text-gray-400 text-center text-sm mt-2">–û—á—ñ–∫—É—î–º–æ —ñ–Ω—à–∏—Ö –≥—Ä–∞–≤—Ü—ñ–≤...</p>
                                )}
                            </>
                        )}

                        {roomState.status === "playing" && roomState.current_player_turn === user.userId && (
                            <>
                                <button
                                    onClick={() => sendWsMessage("hit")}
                                    disabled={!canHitStand}
                                    className="spin-button bg-gradient-to-r from-blue-500 to-indigo-600 text-white py-3 px-6 rounded-full text-lg shadow-xl transition-all duration-300 transform hover:scale-105 active:scale-95 w-full uppercase"
                                >
                                    –í–∑—è—Ç–∏ –∫–∞—Ä—Ç—É (Hit)
                                </button>
                                <button
                                    onClick={() => sendWsMessage("stand")}
                                    disabled={!canHitStand}
                                    className="spin-button bg-gradient-to-r from-red-500 to-orange-600 text-white py-3 px-6 rounded-full text-lg shadow-xl transition-all duration-300 transform hover:scale-105 active:scale-95 w-full uppercase"
                                >
                                    –ó—É–ø–∏–Ω–∏—Ç–∏—Å—å (Stand)
                                </button>
                            </>
                        )}
                        {roomState.status === "round_end" && (
                            <p className="text-center text-yellow-300 font-semibold text-lg">
                                –ù–æ–≤–∏–π —Ä–∞—É–Ω–¥ –Ω–µ–∑–∞–±–∞—Ä–æ–º...
                            </p>
                        )}
                    </div>

                    {/* Bet Input Modal - if we wanted variable bets */}
                    {showBetModal && (
                        <div className="modal fixed inset-0 flex items-center justify-center z-50 bg-black bg-opacity-70 active">
                            <div className="modal-content bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8 text-center w-11/12 max-w-sm relative border-2 border-yellow-400">
                                <h3 className="text-xl font-bold mb-4">–ó—Ä–æ–±–∏—Ç–∏ –°—Ç–∞–≤–∫—É</h3>
                                <p className="mb-4">–í–∞—à–∞ –ø–æ—Ç–æ—á–Ω–∞ —Å—Ç–∞–≤–∫–∞: {BLACKJACK_BET_AMOUNT} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤.</p>
                                <button 
                                    onClick={() => { 
                                        sendWsMessage("bet", { amount: BLACKJACK_BET_AMOUNT }); 
                                        setShowBetModal(false); 
                                    }}
                                    className="bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold py-2 px-6 rounded-full text-lg shadow-md transition-all duration-300"
                                >
                                    –ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏ —Å—Ç–∞–≤–∫—É
                                </button>
                                <button
                                    onClick={() => setShowBetModal(false)}
                                    className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-full text-lg shadow-md transition-all duration-300 mt-2 ml-2"
                                >
                                    –°–∫–∞—Å—É–≤–∞—Ç–∏
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            );
        };


        // -----------------------------------------------------------------------------
        // Placeholder Game Components
        // -----------------------------------------------------------------------------
        const GamePlaceholder = ({ gameName, icon }) => {
            const { sendTelegramLog } = useUser();
            useEffect(() => {
                sendTelegramLog(`Navigated to placeholder game: ${gameName}`);
            }, [gameName, sendTelegramLog]);

            return (
                <div className="flex-grow flex flex-col items-center justify-center p-4 md:p-8 w-full">
                    <h1 className="text-4xl md:text-5xl font-extrabold text-yellow-400 mb-6 drop-shadow-lg leading-tight text-center">
                        {icon} {gameName} {icon}
                    </h1>
                    <p className="text-xl md:text-2xl text-gray-300 text-center max-w-md">
                        –¶—è –≥—Ä–∞ –∑–∞—Ä–∞–∑ —É —Ä–æ–∑—Ä–æ–±—Ü—ñ. –°–ª—ñ–¥–∫—É–π—Ç–µ –∑–∞ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è–º–∏!
                    </p>
                    <p className="mt-4 text-md text-gray-400">
                        –î—è–∫—É—î–º–æ –∑–∞ —Ç–µ—Ä–ø—ñ–Ω–Ω—è!
                    </p>
                </div>
            );
        };


        // -----------------------------------------------------------------------------
        // Top Header Component (Balance, XP, Level, Bonuses)
        // -----------------------------------------------------------------------------
        const TopHeader = () => { 
            const { user, fetchUserData, API_BASE_URL, sendTelegramLog } = useUser();
            const [dailyBonusCooldownText, setDailyBonusCooldownText] = useState('');
            const [quickBonusCooldownText, setQuickBonusCooldownText] = useState('');

            // Helper for time formatting
            const formatTime = (ms) => {
                const totalSeconds = Math.floor(ms / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                
                if (hours > 0) {
                    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                } else {
                    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            };

            // Daily Bonus Logic
            const updateDailyBonusCountdown = useCallback(() => {
                const now = new Date();
                const cooldownDuration = 24 * 60 * 60 * 1000; // 24 hours in ms
                
                const dailyBonusButtonElement = document.getElementById('dailyBonusButton'); // Access via DOM
                if (!dailyBonusButtonElement) return;

                if (!user.lastDailyBonusClaim || (now.getTime() - user.lastDailyBonusClaim.getTime()) >= cooldownDuration) {
                    setDailyBonusCooldownText('');
                    dailyBonusButtonElement.disabled = false;
                    dailyBonusButtonElement.classList.add('pulsing');
                } else {
                    const timeLeft = cooldownDuration - (now.getTime() - user.lastDailyBonusClaim.getTime());
                    setDailyBonusCooldownText(`(${formatTime(timeLeft)})`);
                    dailyBonusButtonElement.disabled = true;
                    dailyBonusButtonElement.classList.remove('pulsing');
                }
            }, [user.lastDailyBonusClaim]);

            useEffect(() => {
                const interval = setInterval(updateDailyBonusCountdown, 1000);
                updateDailyBonusCountdown(); // Initial call
                return () => clearInterval(interval);
            }, [updateDailyBonusCountdown]);

            const handleClaimDailyBonus = async () => {
                if (!user.userId) {
                    showCustomModal('‚ö†Ô∏è –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞–ø—É—Å—Ç—ñ—Ç—å –≥—Ä—É —á–µ—Ä–µ–∑ Telegram, —â–æ–± –æ—Ç—Ä–∏–º–∞—Ç–∏ User ID.', "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ");
                    return;
                }
                const dailyBonusButtonElement = document.getElementById('dailyBonusButton');
                if (dailyBonusButtonElement && dailyBonusButtonElement.disabled) return;

                if(dailyBonusButtonElement) {
                    dailyBonusButtonElement.disabled = true;
                    dailyBonusButtonElement.classList.remove('pulsing');
                }
                sendTelegramLog('Attempting to claim daily bonus...');

                try {
                    const response = await fetch(`${API_BASE_URL}/api/claim_daily_bonus`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.userId })
                    });

                    const data = await response.json();

                    if (response.ok) {
                        playDailyBonusSound();
                        showCustomModal(`üéâ –í–∏ –æ—Ç—Ä–∏–º–∞–ª–∏ ${data.amount} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤!`, "–©–æ–¥–µ–Ω–Ω–∞ –í–∏–Ω–∞–≥–æ—Ä–æ–¥–∞!");
                        fetchUserData();
                        sendTelegramLog(`Daily Bonus claimed: ${data.amount}`);
                    } else {
                        showCustomModal(`‚ùå –ü–æ–º–∏–ª–∫–∞: ${data.detail || '–ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞.'}`, "–ü–æ–º–∏–ª–∫–∞ –í–∏–Ω–∞–≥–æ—Ä–æ–¥–∏");
                        fetchUserData(); // Fetch updated data to refresh cooldown
                        sendTelegramLog(`Daily Bonus API failed: ${data.detail || 'Unknown'}`, 'JS_ERROR');
                    }
                } catch (error) {
                    console.error('–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ —â–æ–¥–µ–Ω–Ω–æ—ó –≤–∏–Ω–∞–≥–æ—Ä–æ–¥–∏:', error);
                    showCustomModal('üö´ –ù–µ –≤–¥–∞–ª–æ—Å—è –∑ º—î–¥–Ω–∞—Ç–∏—Å—å —ñ–∑ —Å–µ—Ä–≤–µ—Ä–æ–º –¥–ª—è –≤–∏–Ω–∞–≥–æ—Ä–æ–¥–∏.', "–ü–æ–º–∏–ª–∫–∞");
                    if(dailyBonusButtonElement) {
                        dailyBonusButtonElement.disabled = false;
                        dailyBonusButtonElement.classList.add('pulsing');
                    }
                    sendTelegramLog(`Daily Bonus network error: ${error.message}`, 'JS_ERROR');
                }
            };

            // Quick Bonus Logic
            const updateQuickBonusCountdown = useCallback(() => {
                const now = new Date();
                const cooldownDuration = 15 * 60 * 1000; // 15 minutes in ms
                
                const quickBonusButtonElement = document.getElementById('quickBonusButton');
                const quickBonusCooldownElement = document.getElementById('quickBonusCooldown');
                if (!quickBonusButtonElement || !quickBonusCooldownElement) return;


                if (!user.lastQuickBonusClaim || (now.getTime() - user.lastQuickBonusClaim.getTime()) >= cooldownDuration) {
                    setQuickBonusCooldownText('');
                    quickBonusButtonElement.disabled = false;
                    quickBonusButtonElement.classList.add('pulsing');
                    quickBonusButtonElement.classList.remove('active-countdown'); // Hide timer
                } else {
                    const timeLeft = cooldownDuration - (now.getTime() - user.lastQuickBonusClaim.getTime());
                    setQuickBonusCooldownText(formatTime(timeLeft));
                    quickBonusButtonElement.disabled = true;
                    quickBonusButtonElement.classList.remove('pulsing');
                    quickBonusButtonElement.classList.add('active-countdown'); // Show timer
                }
            }, [user.lastQuickBonusClaim]);

            useEffect(() => {
                const interval = setInterval(updateQuickBonusCountdown, 1000);
                updateQuickBonusCountdown(); // Initial call
                return () => clearInterval(interval);
            }, [updateQuickBonusCountdown]);

            const handleClaimQuickBonus = async () => {
                if (!user.userId) {
                    showCustomModal('‚ö†Ô∏è –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞–ø—É—Å—Ç—ñ—Ç—å –≥—Ä—É —á–µ—Ä–µ–∑ Telegram, —â–æ–± –æ—Ç—Ä–∏–º–∞—Ç–∏ User ID.', "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–æ");
                    return;
                }
                const quickBonusButtonElement = document.getElementById('quickBonusButton');
                if (quickBonusButtonElement && quickBonusButtonElement.disabled) return;

                if(quickBonusButtonElement) {
                    quickBonusButtonElement.disabled = true;
                    quickBonusButtonElement.classList.remove('pulsing');
                    quickBonusButtonElement.classList.remove('active-countdown');
                    setQuickBonusCooldownText('');
                }
                sendTelegramLog('Attempting to claim quick bonus...');

                try {
                    const response = await fetch(`${API_BASE_URL}/api/claim_quick_bonus`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: user.userId })
                    });

                    const data = await response.json();

                    if (response.ok) {
                        playQuickBonusSound();
                        showCustomModal(`üí∞ –í–∏ –æ—Ç—Ä–∏–º–∞–ª–∏ ${data.amount} —Ñ–∞–Ω—Ç–∏–∫—ñ–≤!`, "–®–≤–∏–¥–∫–∏–π –ë–æ–Ω—É—Å!");
                        fetchUserData();
                        sendTelegramLog(`Quick Bonus claimed: ${data.amount}`);
                    } else {
                        showCustomModal(`‚ùå –ü–æ–º–∏–ª–∫–∞: ${data.detail || '–ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞.'}`, "–ü–æ–º–∏–ª–∫–∞ –ë–æ–Ω—É—Å—É");
                        fetchUserData(); // Fetch updated data to refresh cooldown
                        sendTelegramLog(`Quick Bonus API failed: ${data.detail || 'Unknown'}`, 'JS_ERROR');
                    }
                } catch (error) {
                    console.error('–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ —à–≤–∏–¥–∫–æ–≥–æ –±–æ–Ω—É—Å—É:', error);
                    showCustomModal('üö´ –ù–µ –≤–¥–∞–ª–æ—Å—è –∑ º—î–¥–Ω–∞—Ç–∏—Å—å —ñ–∑ —Å–µ—Ä–≤–µ—Ä–æ–º –¥–ª—è —à–≤–∏–¥–∫–æ–≥–æ –±–æ–Ω—É—Å—É.', "–ü–æ–º–∏–ª–∫–∞");
                    if(quickBonusButtonElement) {
                        quickBonusButtonElement.disabled = false;
                        quickBonusButtonElement.classList.add('pulsing');
                    }
                    sendTelegramLog(`Quick Bonus network error: ${error.message}`, 'JS_ERROR');
                }
            };


            const xpProgress = Math.min(100, (user.xp / user.nextLevelXp) * 100);

            return (
                <div className="app-header w-full h-16 bg-gradient-to-b from-yellow-700 to-yellow-900 shadow-lg flex items-center justify-center text-xl font-bold text-gray-900 uppercase tracking-widest z-10 flex-shrink-0 relative">
                    –Ü–º–ø–µ—Ä—ñ—è –°–ª–æ—Ç–∞
                    {/* Quick Bonus Button */}
                    <button 
                        id="quickBonusButton" 
                        onClick={handleClaimQuickBonus}
                        className="quick-bonus-button absolute left-2 md:left-4 top-1/2 -translate-y-1/2 w-12 h-12 rounded-full bg-blue-600 hover:bg-blue-700 text-white flex items-center justify-center text-lg font-bold shadow-md transition-all duration-200 ease-in-out transform hover:scale-105 active:scale-95"
                    >
                        üí∞
                        <span id="quickBonusCooldown" className="quick-bonus-countdown">{quickBonusCooldownText}</span>
                    </button>
                    {/* Leaderboard Button was here, now removed as per your request to avoid duplication. Only in bottom nav now. */}

                    {/* Balance and Level Display */}
                    <div className="balance-area absolute top-16 left-1/2 transform -translate-x-1/2 bg-gray-800 rounded-b-xl py-2 px-4 shadow-inner border border-gray-700 border-t-0 w-full max-w-xs md:max-w-sm z-20">
                        <div className="flex justify-between items-center w-full mb-1">
                            <span className="text-base md:text-lg text-gray-300 font-medium">–ë–∞–ª–∞–Ω—Å:</span>
                            <span className={`font-bold text-yellow-300 text-2xl md:text-3xl ${user.balance !== 0 ? 'animate-pulse-balance' : ''}`}>{user.balance}</span>
                            <span className="text-base md:text-lg text-gray-300 font-medium ml-2">—Ñ–∞–Ω—Ç–∏–∫—ñ–≤</span>
                        </div>
                        <div className="level-progress w-full mt-1">
                            <div className="flex justify-between items-center text-xs text-gray-400 mb-0.5">
                                <span>–†—ñ–≤–µ–Ω—å: <span className="font-bold text-white">{user.level}</span></span>
                                <span>XP: <span className="font-bold text-white">{user.xp}</span>/<span className="font-bold text-white">{user.nextLevelXp}</span></span>
                            </div>
                            <div className="xp-bar w-full bg-gray-600 rounded-full h-2">
                                <div className="h-full bg-blue-500 rounded-full transition-all duration-300 ease-out" style={{ width: `${xpProgress}%` }}></div>
                            </div>
                        </div>
                        {/* Daily Bonus Button - moved here for visual grouping */}
                        <button 
                            id="dailyBonusButton" 
                            onClick={handleClaimDailyBonus}
                            className="daily-bonus-button bg-gradient-to-r from-blue-500 to-indigo-600 hover:from-blue-600 hover:to-indigo-700 text-white font-bold py-2 px-4 rounded-full text-sm shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95 flex items-center justify-center whitespace-nowrap mt-2 w-full"
                        >
                            –©–æ–¥–µ–Ω–Ω–∞ –í–∏–Ω–∞–≥–æ—Ä–æ–¥–∞ <span id="dailyBonusCooldown" className="ml-2 text-xs text-blue-200">{dailyBonusCooldownText}</span>
                        </button>
                    </div>
                </div>
            );
        };


        // -----------------------------------------------------------------------------
        // Main App Component
        // -----------------------------------------------------------------------------
        function App() {
            const { isLoading, error, fetchUserData } = useUser();
            const [currentPage, setCurrentPage] = useState('slots'); // 'slots', 'coin_flip', 'leaderboard', 'blackjack', 'game3', 'game4', 'game5'

            const renderGame = () => {
                if (isLoading) {
                    return (
                        <div className="flex flex-col items-center justify-center w-full h-full text-white">
                            <p className="text-xl">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö –≥—Ä–∞–≤—Ü—è...</p>
                        </div>
                    );
                }

                if (error) {
                    return (
                        <div className="flex flex-col items-center justify-center w-full h-full text-white text-center p-4">
                            <p className="text-xl text-red-500 font-bold mb-4">–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è:</p>
                            <p className="text-lg mb-6">{error}</p>
                            <button 
                                onClick={fetchUserData}
                                className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-full text-lg shadow-lg transition-all duration-300 ease-in-out transform hover:scale-105 active:scale-95"
                            >
                                –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –∑–Ω–æ–≤—É
                            </button>
                        </div>
                    );
                }

                switch (currentPage) {
                    case 'slots':
                        return <SlotMachine />;
                    case 'coin_flip':
                        return <CoinFlip />;
                    case 'leaderboard':
                        return <Leaderboard />;
                    case 'blackjack':
                        return <BlackjackGame />; // New Blackjack game
                    case 'game3': // Placeholder for future game
                        return <GamePlaceholder gameName="–ö–æ–ª–µ—Å–æ –§–æ—Ä—Ç—É–Ω–∏" icon="üé≤" />;
                    case 'game5': // Placeholder for future game (Poker)
                        return <GamePlaceholder gameName="–ü–æ–∫–µ—Ä" icon="üÉè" />;
                    default:
                        return <SlotMachine />;
                }
            };

            // Log for App component render
            useEffect(() => {
                if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                    Telegram.WebApp.sendData(`JS_LOG: App component rendered. Current page: ${currentPage}. IsLoading: ${isLoading}. Error: ${error}`);
                }
            }, [currentPage, isLoading, error]);


            return (
                <div className="casino-app-container relative w-full h-full flex flex-col items-center justify-between bg-gradient-to-br from-purple-900 via-gray-900 to-indigo-900 text-white overflow-hidden">
                    {/* Top Header with Balance, XP, Level, Bonuses */}
                    <TopHeader />

                    {/* Main Game Content Area - renders current game */}
                    <div className="relative flex-grow flex flex-col items-center justify-around w-full main-content-area"> 
                        {renderGame()}
                    </div>

                    {/* Bottom Navigation */}
                    <div className="bottom-nav fixed bottom-0 w-full h-16 bg-gradient-to-t from-yellow-700 to-yellow-900 shadow-lg flex justify-around items-center z-30">
                        <button
                            onClick={() => setCurrentPage('slots')}
                            className={`nav-button p-2 rounded-full text-2xl transition-all duration-200 ${currentPage === 'slots' ? 'bg-yellow-500 text-gray-900 scale-110 shadow-lg' : 'text-gray-700 hover:text-gray-800'}`}
                        >
                            üé∞
                        </button>
                        <button
                            onClick={() => setCurrentPage('coin_flip')}
                            className={`nav-button p-2 rounded-full text-2xl transition-all duration-200 ${currentPage === 'coin_flip' ? 'bg-yellow-500 text-gray-900 scale-110 shadow-lg' : 'text-gray-700 hover:text-gray-800'}`}
                        >
                            ü™ô
                        </button>
                        <button
                            onClick={() => setCurrentPage('blackjack')} 
                            className={`nav-button p-2 rounded-full text-2xl transition-all duration-200 ${currentPage === 'blackjack' ? 'bg-yellow-500 text-gray-900 scale-110 shadow-lg' : 'text-gray-700 hover:text-gray-800'}`}
                        >
                            ‚ô†Ô∏è {/* Using a spade icon for Blackjack */}
                        </button>
                        <button
                            onClick={() => setCurrentPage('leaderboard')}
                            className={`nav-button p-2 rounded-full text-2xl transition-all duration-200 ${currentPage === 'leaderboard' ? 'bg-yellow-500 text-gray-900 scale-110 shadow-lg' : 'text-gray-700 hover:text-gray-800'}`}
                        >
                            üëë
                        </button>
                        {/* Placeholder buttons for 2 more games */}
                        <button
                            onClick={() => setCurrentPage('game3')}
                            className={`nav-button p-2 rounded-full text-2xl transition-all duration-200 ${currentPage === 'game3' ? 'bg-yellow-500 text-gray-900 scale-110 shadow-lg' : 'text-gray-700 hover:text-gray-800'}`}
                        >
                            üé≤
                        </button>
                        <button
                            onClick={() => setCurrentPage('game5')}
                            className={`nav-button p-2 rounded-full text-2xl transition-all duration-200 ${currentPage === 'game5' ? 'bg-yellow-500 text-gray-900 scale-110 shadow-lg' : 'text-gray-700 hover:text-gray-800'}`}
                        >
                            üÉè
                        </button>
                    </div>

                    {/* Audio Context Activation Prompt */}
                    <div id="audioPrompt" className="audio-prompt fixed inset-0 bg-gray-900 bg-opacity-95 flex flex-col items-center justify-center text-center p-8 z-50 hidden">
                        <p className="text-xl md:text-2xl font-bold mb-4">–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å, —â–æ–± —É–≤—ñ–º–∫–Ω—É—Ç–∏ –∑–≤—É–∫</p>
                        <button id="activateAudioButton" className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-full text-lg shadow-lg transition-all duration-300 ease-in-out">
                            –£–≤—ñ–º–∫–Ω—É—Ç–∏
                        </button>
                    </div>

                    {/* Custom Modal for Alerts */}
                    <div id="customModal" className="modal fixed inset-0 flex items-center justify-center z-50 bg-black bg-opacity-70 hidden">
                        <div className="modal-content bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8 text-center w-11/12 max-w-sm relative border-2 border-yellow-400">
                            <button className="close-button absolute top-2 right-4 text-gray-400 hover:text-white text-3xl font-bold transition-colors duration-200">&times;</button>
                            <p id="modalMessage" className="text-xl md:text-2xl font-semibold mb-4"></p>
                            <button className="bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold py-2 px-6 rounded-full text-lg shadow-md transition-all duration-300">OK</button>
                        </div>
                    </div>
                </div>
            );
        }
        
        // This is the core mounting logic of the React app
        // It runs AFTER the Babel script has parsed everything above
        // And we ensure React and ReactDOM are actually loaded
        try {
            if (typeof React === 'undefined' || typeof ReactDOM === 'undefined') {
                const rootElement = document.getElementById('root');
                if (rootElement) {
                    rootElement.innerHTML = `<p class="text-red-500 text-center mt-10 text-lg">
                        –ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞: React –∞–±–æ ReactDOM –Ω–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ. <br/> –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è CDN.
                    </p>`;
                }
                if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                    Telegram.WebApp.sendData('JS_FATAL_REACT_ERROR: React or ReactDOM undefined.');
                }
                console.error("React or ReactDOM is undefined. Check CDN scripts.");
            } else {
                const rootElement = document.getElementById('root');
                const initialMessage = document.getElementById('initialLoadingMessage');

                if (!rootElement) {
                    console.error("Error: Root element with ID 'root' not found for ReactDOM.createRoot.");
                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData('JS_ERROR: Root element not found for ReactDOM.');
                    }
                    if (initialMessage) {
                        initialMessage.textContent = '–ö—Ä–∏—Ç–∏—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞: –ö–æ—Ä–µ–Ω–µ–≤–∏–π –µ–ª–µ–º–µ–Ω—Ç –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.';
                        initialMessage.classList.add('text-red-500');
                    }
                } else {
                    // Remove loading message
                    if (initialMessage) {
                        initialMessage.remove();
                    }

                    const root = ReactDOM.createRoot(rootElement);
                    root.render(
                        <React.StrictMode>
                            <UserProvider>
                                <App />
                            </UserProvider>
                        </React.StrictMode>
                    );

                    if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                        Telegram.WebApp.sendData('JS_LOG: React app rendered successfully into DOM.');
                    }
                }
            }
        } catch (e) {
            console.error("Error during final React mounting:", e);
            const rootElement = document.getElementById('root');
            if (rootElement) {
                rootElement.innerHTML = `<p class="text-red-500 text-center mt-10 text-lg">
                    –ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫—É –≥—Ä–∏: <br/> ${e.message}
                    <br/> –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –∫–æ–Ω—Å–æ–ª—å –±—Ä–∞—É–∑–µ—Ä–∞ –∞–±–æ –ª–æ–≥–∏ Render.
                </p>`;
            }
            if (typeof Telegram !== 'undefined' && Telegram.WebApp) {
                Telegram.WebApp.sendData(`JS_FATAL_REACT_MOUNT_ERROR: ${e.message.substring(0, Math.min(e.message.length, 100))}`);
            }
        }
    </script>
</body>
</html>
